"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/notes/page",{

/***/ "(app-pages-browser)/./src/hooks/use-whisper-live.ts":
/*!***************************************!*\
  !*** ./src/hooks/use-whisper-live.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWhisperLive: () => (/* binding */ useWhisperLive)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/hooks/use-toast */ \"(app-pages-browser)/./src/hooks/use-toast.ts\");\n/* __next_internal_client_entry_do_not_use__ useWhisperLive auto */ \n\nfunction encodeWAV(samples, sampleRate) {\n    const bitsPerSample = 16;\n    const bytesPerSample = bitsPerSample / 8;\n    const blockAlign = bytesPerSample // mono\n    ;\n    const byteRate = sampleRate * blockAlign;\n    const dataSize = samples.length * bytesPerSample;\n    const buffer = new ArrayBuffer(44 + dataSize);\n    const view = new DataView(buffer);\n    /* RIFF identifier */ writeString(view, 0, 'RIFF');\n    /* file length minus first 8 bytes */ view.setUint32(4, 36 + dataSize, true);\n    /* WAVE type */ writeString(view, 8, 'WAVE');\n    /* fmt  chunk */ writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true) // chunk length\n    ;\n    view.setUint16(20, 1, true) // PCM\n    ;\n    view.setUint16(22, 1, true) // mono\n    ;\n    view.setUint32(24, sampleRate, true) // sampleRate\n    ;\n    view.setUint32(28, byteRate, true) // byteRate\n    ;\n    view.setUint16(32, blockAlign, true) // blockAlign\n    ;\n    view.setUint16(34, bitsPerSample, true) // bitsPerSample\n    ;\n    /* data chunk */ writeString(view, 36, 'data');\n    view.setUint32(40, dataSize, true);\n    // write PCM samples\n    let offset = 44;\n    for(let i = 0; i < samples.length; i++){\n        // clamp\n        const s1 = Math.max(-1, Math.min(1, samples[i]));\n        // scale to 16‑bit int\n        view.setInt16(offset, s1 < 0 ? s1 * 0x8000 : s1 * 0x7FFF, true);\n        offset += 2;\n    }\n    return view;\n}\nfunction writeString(view, offset, s1) {\n    for(let i = 0; i < s1.length; i++){\n        view.setUint8(offset + i, s1.charCodeAt(i));\n    }\n}\nfunction useWhisperLive(config) {\n    let initialRecordings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    const [recordings, setRecordings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialRecordings);\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        isTranscribing: false,\n        transcript: '',\n        error: null,\n        segments: []\n    });\n    const [audioData, setAudioData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [dataUpdateTrigger, setDataUpdateTrigger] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const recordingBuffers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const sampleRateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const lastSegmentIndexRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const audioDataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const resetSegments = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[resetSegments]\": ()=>{\n            setState({\n                \"useWhisperLive.useCallback[resetSegments]\": (s1)=>({\n                        ...s1,\n                        segments: [],\n                        transcript: ''\n                    })\n            }[\"useWhisperLive.useCallback[resetSegments]\"]);\n        }\n    }[\"useWhisperLive.useCallback[resetSegments]\"], []);\n    const resetRecordings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[resetRecordings]\": ()=>{\n            setRecordings([]);\n        }\n    }[\"useWhisperLive.useCallback[resetRecordings]\"], []);\n    const uidRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));\n    const { toast } = (0,_hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__.useToast)();\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[connect]\": async ()=>{\n            await navigator.mediaDevices.getUserMedia({\n                audio: {\n                    sampleRate: 16000,\n                    channelCount: 1\n                }\n            });\n            console.log('[useWhisperLive] got mic permission');\n            console.log('[useWhisperLive]  connect()', config);\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            // 1) create AudioContext now so we can hand its real sampleRate to the server\n            const ctx = new AudioContext({\n                sampleRate: 16000\n            });\n            ctxRef.current = ctx;\n            // immediately save out the sampleRate for later WAV encoding\n            sampleRateRef.current = ctx.sampleRate;\n            // clear out any old floats from a previous session\n            recordingBuffers.current = [];\n            console.log('[useWhisperLive] audioContext.sampleRate =', sampleRateRef.current);\n            setState({\n                \"useWhisperLive.useCallback[connect]\": (s1)=>({\n                        ...s1,\n                        error: null\n                    })\n            }[\"useWhisperLive.useCallback[connect]\"]);\n            const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\n            // if the user typed “localhost”, swap to 127.0.0.1\n            const host = config.serverUrl === 'localhost' || config.serverUrl === '::1' ? '127.0.0.1' : config.serverUrl;\n            const ws = new WebSocket(\"\".concat(protocol, \"://\").concat(host, \":\").concat(config.port));\n            ws.binaryType = 'arraybuffer';\n            wsRef.current = ws;\n            lastSegmentIndexRef.current = 0;\n            ws.onopen = ({\n                \"useWhisperLive.useCallback[connect]\": async ()=>{\n                    console.log('[useWhisperLive] 🟢 WebSocket OPEN');\n                    const taskName = 'transcribe';\n                    ws.send(JSON.stringify({\n                        task: taskName,\n                        uid: uidRef.current,\n                        language: config.language,\n                        model: config.model,\n                        use_vad: false,\n                        stream: true,\n                        save_recording: config.saveRecording,\n                        output_filename: config.outputFilename,\n                        max_clients: config.maxClients,\n                        max_connection_time: config.maxConnectionTime > 0 ? config.maxConnectionTime : 1200,\n                        sample_rate: sampleRateRef.current,\n                        chunk_size: 4096\n                    }));\n                    await startTranscription();\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s1)=>({\n                                ...s1,\n                                isConnected: true\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            const clearAll = {\n                \"useWhisperLive.useCallback[connect].clearAll\": ()=>{\n                    recordingBuffers.current = [];\n                    setState({\n                        \"useWhisperLive.useCallback[connect].clearAll\": (s1)=>({\n                                ...s1,\n                                transcript: '',\n                                segments: []\n                            })\n                    }[\"useWhisperLive.useCallback[connect].clearAll\"]);\n                }\n            }[\"useWhisperLive.useCallback[connect].clearAll\"];\n            // inside your connect()\n            ws.onmessage = ({\n                \"useWhisperLive.useCallback[connect]\": (e)=>{\n                    console.log('Raw WS Message:', e.data);\n                    if (typeof e.data !== 'string') return;\n                    const msg = JSON.parse(e.data);\n                    if (msg.message === 'SERVER_READY') return;\n                    if (msg.type === 'error') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s1)=>({\n                                    ...s1,\n                                    error: msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    if (msg.type === 'partial' || msg.type === 'transcript') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s1)=>({\n                                    ...s1,\n                                    isTranscribing: true,\n                                    transcript: s1.transcript + msg.text\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    if (msg.type === 'final') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s1)=>({\n                                    ...s1,\n                                    isTranscribing: false,\n                                    transcript: s1.transcript + msg.text + '\\n'\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // ← NEW: handle the `segments` array\n                    if (Array.isArray(msg.segments)) {\n                        let rms = 0;\n                        if (audioDataRef.current) {\n                            const data = audioDataRef.current;\n                            let sum = 0;\n                            for (const x of data)sum += (x - 128) ** 2;\n                            rms = Math.sqrt(sum / data.length) / 128;\n                        }\n                        const segments = msg.segments.map({\n                            \"useWhisperLive.useCallback[connect].segments\": (wsSeg)=>({\n                                    speaker: wsSeg.speaker === 0 ? 'mic' : 'speaker',\n                                    content: wsSeg.text,\n                                    volume: rms\n                                })\n                        }[\"useWhisperLive.useCallback[connect].segments\"]);\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s1)=>({\n                                    ...s1,\n                                    segments: [\n                                        ...s1.segments,\n                                        ...segments\n                                    ],\n                                    isTranscribing: true\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        console.log('[useWhisperLive] Total segments now:', s.segments.length + segments.length);\n                        return;\n                    }\n                    // fallback to any stray `msg.message`\n                    if (msg.message && msg.message !== 'SERVER_READY') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s1)=>({\n                                    ...s1,\n                                    isTranscribing: true,\n                                    transcript: s1.transcript + msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                    }\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onclose = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    // stopTranscription()\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s1)=>({\n                                ...s1,\n                                isConnected: false,\n                                isTranscribing: false\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onerror = ({\n                \"useWhisperLive.useCallback[connect]\": (err)=>{\n                    console.warn('[useWhisperLive] WebSocket error (non‑fatal)', err);\n                // don’t setState or toast here\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n        }\n    }[\"useWhisperLive.useCallback[connect]\"], [\n        config,\n        toast\n    ]);\n    const micRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const systemRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ctxRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const processorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const startTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[startTranscription]\": async ()=>{\n            if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s1)=>({\n                            ...s1,\n                            error: 'Not connected'\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                return;\n            }\n            try {\n                var _config_audioSources;\n                // 1) Screen + system audio (if enabled)\n                let systemStream = null;\n                if ((_config_audioSources = config.audioSources) === null || _config_audioSources === void 0 ? void 0 : _config_audioSources.systemAudio) {\n                    try {\n                        systemStream = await navigator.mediaDevices.getDisplayMedia({\n                            video: true,\n                            audio: true\n                        });\n                        systemRef.current = systemStream;\n                    } catch (e) {\n                        console.warn('System audio share denied or not requested; falling back to mic only');\n                    }\n                }\n                // 2) Microphone\n                const micStream = await navigator.mediaDevices.getUserMedia({\n                    audio: {\n                        sampleRate: 16000,\n                        channelCount: 1\n                    }\n                });\n                micRef.current = micStream;\n                const ctx = ctxRef.current;\n                const dest = ctx.createMediaStreamDestination();\n                // 4) Wire mic → dest\n                const micSrc = ctx.createMediaStreamSource(micStream);\n                micSrc.connect(dest);\n                // 5) Wire system audio → dest\n                if (systemStream) {\n                    const sysSrc = ctx.createMediaStreamSource(systemStream);\n                    sysSrc.connect(dest);\n                }\n                // 6) Instead of wiring mic+sys directly to the processor, we\n                //    take the mixed dest.stream and hook that up:\n                const mixedSrc = ctx.createMediaStreamSource(dest.stream);\n                // 7) Create your ScriptProcessor (bufferSize=4096, mono in/out)\n                const processor = ctx.createScriptProcessor(4096, 1, 1);\n                // 8) Wire the mixed audio into the processor\n                mixedSrc.connect(processor);\n                // 9) On each onaudioprocess, build exactly one packet\n                processor.onaudioprocess = ({\n                    \"useWhisperLive.useCallback[startTranscription]\": (e)=>{\n                        const float32 = e.inputBuffer.getChannelData(0);\n                        const float32Buffer = new Float32Array(float32);\n                        if (config.saveRecording) {\n                            recordingBuffers.current.push(float32Buffer);\n                        }\n                        // → convert to Uint8Array [0..255]\n                        const ui8 = new Uint8Array(float32Buffer.length);\n                        for(let i = 0; i < float32Buffer.length; i++){\n                            ui8[i] = Math.min(255, Math.max(0, Math.floor((float32Buffer[i] + 1) * 127.5)));\n                        }\n                        // send raw float32 PCM to server\n                        if (wsRef.current.readyState === WebSocket.OPEN) {\n                            wsRef.current.send(float32Buffer.buffer);\n                        }\n                        // update visualizer\n                        setAudioData(ui8);\n                        setDataUpdateTrigger({\n                            \"useWhisperLive.useCallback[startTranscription]\": (t)=>t + 1\n                        }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                    }\n                })[\"useWhisperLive.useCallback[startTranscription]\"];\n                // 10) Start it\n                processor.connect(ctx.destination);\n                processorRef.current = processor;\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s1)=>({\n                            ...s1,\n                            isTranscribing: true\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n            } catch (err) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s1)=>({\n                            ...s1,\n                            error: \"Failed to start transcription: \".concat(err.message)\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                toast({\n                    title: 'Transcription Error',\n                    description: err.message,\n                    variant: 'destructive'\n                });\n            }\n        }\n    }[\"useWhisperLive.useCallback[startTranscription]\"], [\n        config,\n        toast\n    ]);\n    const stopTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[stopTranscription]\": async ()=>{\n            var _wsRef_current;\n            // 1) tell the server “END_OF_AUDIO”\n            if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                wsRef.current.send(new TextEncoder().encode(\"END_OF_AUDIO\"));\n            }\n            // 2) immediately tear down the ScriptProcessor & tracks\n            if (processorRef.current) {\n                processorRef.current.disconnect();\n                processorRef.current = null;\n            }\n            if (micRef.current) {\n                micRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                micRef.current = null;\n            }\n            if (systemRef.current) {\n                systemRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                systemRef.current = null;\n            }\n            // 3) if we’ve been saving, flatten + encode + upload while ctx is still open\n            if (config.saveRecording && recordingBuffers.current.length) {\n                console.log('[useWhisperLive] uploading WAV, buffers:', recordingBuffers.current.length);\n                // ◉ use the saved sampleRate\n                const sampleRate = sampleRateRef.current;\n                // ◉ flatten into one Float32Array\n                const totalLength = recordingBuffers.current.reduce({\n                    \"useWhisperLive.useCallback[stopTranscription].totalLength\": (sum, buf)=>sum + buf.length\n                }[\"useWhisperLive.useCallback[stopTranscription].totalLength\"], 0);\n                const interleaved = new Float32Array(totalLength);\n                let offset = 0;\n                for (const buf of recordingBuffers.current){\n                    interleaved.set(buf, offset);\n                    offset += buf.length;\n                }\n                // ◉ encode + upload\n                const wavView = encodeWAV(interleaved, sampleRate);\n                const blob = new Blob([\n                    wavView.buffer\n                ], {\n                    type: 'audio/wav'\n                });\n                const form = new FormData();\n                form.append('file', blob, config.outputFilename || 'recording.wav');\n                try {\n                    const res = await fetch('/api/upload', {\n                        method: 'POST',\n                        body: form\n                    });\n                    if (!res.ok) throw new Error('upload failed');\n                    const { url } = await res.json();\n                    const rec = {\n                        id: Date.now().toString(),\n                        url,\n                        blob\n                    };\n                    setRecordings({\n                        \"useWhisperLive.useCallback[stopTranscription]\": (rs)=>[\n                                ...rs,\n                                rec\n                            ]\n                    }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                } catch (err) {\n                    toast({\n                        title: 'Upload Error',\n                        description: String(err),\n                        variant: 'destructive'\n                    });\n                }\n                recordingBuffers.current = [];\n            }\n            // 4) **now** tear down your AudioContext\n            if (ctxRef.current) {\n                ctxRef.current.close();\n                ctxRef.current = null;\n            }\n            // 5) finally, update state\n            setState({\n                \"useWhisperLive.useCallback[stopTranscription]\": (s1)=>({\n                        ...s1,\n                        isTranscribing: false\n                    })\n            }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n        }\n    }[\"useWhisperLive.useCallback[stopTranscription]\"], [\n        config,\n        toast\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[disconnect]\": ()=>{\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            stopTranscription();\n            setState({\n                \"useWhisperLive.useCallback[disconnect]\": (s1)=>({\n                        ...s1,\n                        isConnected: false,\n                        isTranscribing: false,\n                        transcript: '',\n                        error: null,\n                        segments: []\n                    })\n            }[\"useWhisperLive.useCallback[disconnect]\"]);\n        }\n    }[\"useWhisperLive.useCallback[disconnect]\"], [\n        stopTranscription\n    ]);\n    const clearTranscript = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[clearTranscript]\": ()=>{\n            setState({\n                \"useWhisperLive.useCallback[clearTranscript]\": (s1)=>({\n                        ...s1,\n                        transcript: ''\n                    })\n            }[\"useWhisperLive.useCallback[clearTranscript]\"]);\n        }\n    }[\"useWhisperLive.useCallback[clearTranscript]\"], []);\n    return {\n        state,\n        connect,\n        startTranscription,\n        stopTranscription,\n        disconnect,\n        clearTranscript,\n        wsRef,\n        audioData,\n        dataUpdateTrigger,\n        recordings,\n        resetSegments,\n        deleteRecording: (r)=>setRecordings((rs)=>rs.filter((x)=>x.id !== r.id)),\n        resetRecordings\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utd2hpc3Blci1saXZlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7b0VBRXFEO0FBQ1Q7QUE0QjVDLFNBQVNJLFVBQVVDLE9BQXFCLEVBQUVDLFVBQWtCO0lBQ3hELE1BQU1DLGdCQUFnQjtJQUN0QixNQUFNQyxpQkFBaUJELGdCQUFnQjtJQUN2QyxNQUFNRSxhQUFhRCxlQUFlLE9BQU87O0lBQ3pDLE1BQU1FLFdBQVdKLGFBQWFHO0lBQzlCLE1BQU1FLFdBQVdOLFFBQVFPLE1BQU0sR0FBR0o7SUFDbEMsTUFBTUssU0FBUyxJQUFJQyxZQUFZLEtBQUtIO0lBQ3BDLE1BQU1JLE9BQU8sSUFBSUMsU0FBU0g7SUFFMUIsbUJBQW1CLEdBQ25CSSxZQUFZRixNQUFNLEdBQUc7SUFDckIsbUNBQW1DLEdBQ25DQSxLQUFLRyxTQUFTLENBQUMsR0FBRyxLQUFLUCxVQUFVO0lBQ2pDLGFBQWEsR0FDYk0sWUFBWUYsTUFBTSxHQUFHO0lBQ3JCLGNBQWMsR0FDZEUsWUFBWUYsTUFBTSxJQUFJO0lBQ3RCQSxLQUFLRyxTQUFTLENBQUMsSUFBSSxJQUFJLE1BQXFCLGVBQWU7O0lBQzNESCxLQUFLSSxTQUFTLENBQUMsSUFBSSxHQUFHLE1BQXNCLE1BQU07O0lBQ2xESixLQUFLSSxTQUFTLENBQUMsSUFBSSxHQUFHLE1BQXNCLE9BQU87O0lBQ25ESixLQUFLRyxTQUFTLENBQUMsSUFBSVosWUFBWSxNQUFhLGFBQWE7O0lBQ3pEUyxLQUFLRyxTQUFTLENBQUMsSUFBSVIsVUFBVSxNQUFlLFdBQVc7O0lBQ3ZESyxLQUFLSSxTQUFTLENBQUMsSUFBSVYsWUFBWSxNQUFhLGFBQWE7O0lBQ3pETSxLQUFLSSxTQUFTLENBQUMsSUFBSVosZUFBZSxNQUFVLGdCQUFnQjs7SUFDNUQsY0FBYyxHQUNkVSxZQUFZRixNQUFNLElBQUk7SUFDdEJBLEtBQUtHLFNBQVMsQ0FBQyxJQUFJUCxVQUFVO0lBRTdCLG9CQUFvQjtJQUNwQixJQUFJ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QUdBLEVBQUM7d0JBQUVnQixZQUFZO29CQUFHOztRQUMxQztzREFBRyxFQUFFO0lBRUwsT0FBTztRQUNISjtRQUNBeUI7UUFDQTJDO1FBQ0EyRDtRQUNBRztRQUNBNkI7UUFDQXBKO1FBQ0FKO1FBQ0FFO1FBQ0FYO1FBQ0FrQjtRQUNBZ0osaUJBQWlCLENBQUNDLElBQWlCbEssY0FBYzhKLENBQUFBLEtBQU1BLEdBQUdLLE1BQU0sQ0FBQ2hGLENBQUFBLElBQUtBLEVBQUV3RSxFQUFFLEtBQUtPLEVBQUVQLEVBQUU7UUFDbkZ6STtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIkU6XFxBaXZvaWNldG90ZXh0XFxzcmNcXGhvb2tzXFx1c2Utd2hpc3Blci1saXZlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgdXNlVG9hc3QgfSBmcm9tICdAL2hvb2tzL3VzZS10b2FzdCdcclxuaW1wb3J0IHR5cGUgeyBTZWdtZW50IH0gZnJvbSAnQC90eXBlcy90cmFuc2NyaXB0aW9uJztcclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJlY29yZGluZyB7IGlkOiBzdHJpbmc7IHVybDogc3RyaW5nOyBibG9iPzogQmxvYiB9XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXaGlzcGVyTGl2ZUNvbmZpZyB7XHJcbiAgICBzZXJ2ZXJVcmw6IHN0cmluZ1xyXG4gICAgcG9ydDogbnVtYmVyXHJcbiAgICBsYW5ndWFnZTogc3RyaW5nXHJcbiAgICB0cmFuc2xhdGU6IGJvb2xlYW5cclxuICAgIG1vZGVsOiBzdHJpbmdcclxuICAgIHZhZDogYm9vbGVhblxyXG4gICAgc2F2ZVJlY29yZGluZzogYm9vbGVhblxyXG4gICAgb3V0cHV0RmlsZW5hbWU6IHN0cmluZ1xyXG4gICAgbWF4Q2xpZW50czogbnVtYmVyXHJcbiAgICBtYXhDb25uZWN0aW9uVGltZTogbnVtYmVyXHJcbiAgICBhdWRpb1NvdXJjZXM/OiB7IG1pY3JvcGhvbmU6IGJvb2xlYW47IHN5c3RlbUF1ZGlvOiBib29sZWFuIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIFdoaXNwZXJMaXZlU3RhdGUge1xyXG4gICAgaXNDb25uZWN0ZWQ6IGJvb2xlYW5cclxuICAgIGlzVHJhbnNjcmliaW5nOiBib29sZWFuXHJcbiAgICB0cmFuc2NyaXB0OiBzdHJpbmdcclxuICAgIGVycm9yOiBzdHJpbmcgfCBudWxsXHJcbiAgICBzZWdtZW50czogU2VnbWVudFtdO1xyXG59XHJcbmZ1bmN0aW9uIGVuY29kZVdBVihzYW1wbGVzOiBGbG9hdDMyQXJyYXksIHNhbXBsZVJhdGU6IG51bWJlcik6IERhdGFWaWV3IHtcclxuICAgIGNvbnN0IGJpdHNQZXJTYW1wbGUgPSAxNlxyXG4gICAgY29uc3QgYnl0ZXNQZXJTYW1wbGUgPSBiaXRzUGVyU2FtcGxlIC8gOFxyXG4gICAgY29uc3QgYmxvY2tBbGlnbiA9IGJ5dGVzUGVyU2FtcGxlIC8vIG1vbm9cclxuICAgIGNvbnN0IGJ5dGVSYXRlID0gc2FtcGxlUmF0ZSAqIGJsb2NrQWxpZ25cclxuICAgIGNvbnN0IGRhdGFTaXplID0gc2FtcGxlcy5sZW5ndGggKiBieXRlc1BlclNhbXBsZVxyXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQ0ICsgZGF0YVNpemUpXHJcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcilcclxuXHJcbiAgICAvKiBSSUZGIGlkZW50aWZpZXIgKi9cclxuICAgIHdyaXRlU3RyaW5nKHZpZXcsIDAsICdSSUZGJylcclxuICAgIC8qIGZpbGUgbGVuZ3RoIG1pbnVzIGZpcnN0IDggYnl0ZXMgKi9cclxuICAgIHZpZXcuc2V0VWludDMyKDQsIDM2ICsgZGF0YVNpemUsIHRydWUpXHJcbiAgICAvKiBXQVZFIHR5cGUgKi9cclxuICAgIHdyaXRlU3RyaW5nKHZpZXcsIDgsICdXQVZFJylcclxuICAgIC8qIGZtdCAgY2h1bmsgKi9cclxuICAgIHdyaXRlU3RyaW5nKHZpZXcsIDEyLCAnZm10ICcpXHJcbiAgICB2aWV3LnNldFVpbnQzMigxNiwgMTYsIHRydWUpICAgICAgICAgICAgICAgIC8vIGNodW5rIGxlbmd0aFxyXG4gICAgdmlldy5zZXRVaW50MTYoMjAsIDEsIHRydWUpICAgICAgICAgICAgICAgICAvLyBQQ01cclxuICAgIHZpZXcuc2V0VWludDE2KDIyLCAxLCB0cnVlKSAgICAgICAgICAgICAgICAgLy8gbW9ub1xyXG4gICAgdmlldy5zZXRVaW50MzIoMjQsIHNhbXBsZVJhdGUsIHRydWUpICAgICAgICAvLyBzYW1wbGVSYXRlXHJcbiAgICB2aWV3LnNldFVpbnQzMigyOCwgYnl0ZVJhdGUsIHRydWUpICAgICAgICAgIC8vIGJ5dGVSYXRlXHJcbiAgICB2aWV3LnNldFVpbnQxNigzMiwgYmxvY2tBbGlnbiwgdHJ1ZSkgICAgICAgIC8vIGJsb2NrQWxpZ25cclxuICAgIHZpZXcuc2V0VWludDE2KDM0LCBiaXRzUGVyU2FtcGxlLCB0cnVlKSAgICAgLy8gYml0c1BlclNhbXBsZVxyXG4gICAgLyogZGF0YSBjaHVuayAqL1xyXG4gICAgd3JpdGVTdHJpbmcodmlldywgMzYsICdkYXRhJylcclxuICAgIHZpZXcuc2V0VWludDMyKDQwLCBkYXRhU2l6ZSwgdHJ1ZSlcclxuXHJcbiAgICAvLyB3cml0ZSBQQ00gc2FtcGxlc1xyXG4gICAgbGV0IG9mZnNldCA9IDQ0XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyBjbGFtcFxyXG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgc2FtcGxlc1tpXSkpXHJcbiAgICAgICAgLy8gc2NhbGUgdG8gMTbigJFiaXQgaW50XHJcbiAgICAgICAgdmlldy5zZXRJbnQxNihcclxuICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICBzIDwgMCA/IHMgKiAweDgwMDAgOiBzICogMHg3RkZGLFxyXG4gICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgKVxyXG4gICAgICAgIG9mZnNldCArPSAyXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZpZXdcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVTdHJpbmcodmlldzogRGF0YVZpZXcsIG9mZnNldDogbnVtYmVyLCBzOiBzdHJpbmcpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0ICsgaSwgcy5jaGFyQ29kZUF0KGkpKVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VXaGlzcGVyTGl2ZShjb25maWc6IFdoaXNwZXJMaXZlQ29uZmlnLCBpbml0aWFsUmVjb3JkaW5nczogUmVjb3JkaW5nW10gPSBbXSkge1xyXG4gICAgY29uc3QgW3JlY29yZGluZ3MsIHNldFJlY29yZGluZ3NdID0gdXNlU3RhdGU8UmVjb3JkaW5nW10+KGluaXRpYWxSZWNvcmRpbmdzKVxyXG5cclxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8V2hpc3BlckxpdmVTdGF0ZT4oe1xyXG4gICAgICAgIGlzQ29ubmVjdGVkOiBmYWxzZSxcclxuICAgICAgICBpc1RyYW5zY3JpYmluZzogZmFsc2UsXHJcbiAgICAgICAgdHJhbnNjcmlwdDogJycsXHJcbiAgICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICAgICAgc2VnbWVudHM6IFtdLFxyXG4gICAgfSlcclxuICAgIGNvbnN0IFthdWRpb0RhdGEsIHNldEF1ZGlvRGF0YV0gPSB1c2VTdGF0ZTxVaW50OEFycmF5IHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IFtkYXRhVXBkYXRlVHJpZ2dlciwgc2V0RGF0YVVwZGF0ZVRyaWdnZXJdID0gdXNlU3RhdGUoMClcclxuICAgIGNvbnN0IHdzUmVmID0gdXNlUmVmPFdlYlNvY2tldCB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCByZWNvcmRpbmdCdWZmZXJzID0gdXNlUmVmPEZsb2F0MzJBcnJheVtdPihbXSlcclxuICAgIGNvbnN0IHNhbXBsZVJhdGVSZWYgPSB1c2VSZWY8bnVtYmVyPigwKVxyXG4gICAgY29uc3QgbGFzdFNlZ21lbnRJbmRleFJlZiA9IHVzZVJlZigwKVxyXG4gICAgY29uc3QgYXVkaW9EYXRhUmVmID0gdXNlUmVmPFVpbnQ4QXJyYXkgfCBudWxsPihudWxsKTtcclxuXHJcbiAgICBjb25zdCByZXNldFNlZ21lbnRzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgc2VnbWVudHM6IFtdLCB0cmFuc2NyaXB0OiAnJyB9KSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCByZXNldFJlY29yZGluZ3MgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0UmVjb3JkaW5ncyhbXSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCB1aWRSZWYgPSB1c2VSZWYoXHJcbiAgICAgICAgdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSURcclxuICAgICAgICAgICAgPyBjcnlwdG8ucmFuZG9tVVVJRCgpXHJcbiAgICAgICAgICAgIDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksXHJcbiAgICApXHJcbiAgICBjb25zdCB7IHRvYXN0IH0gPSB1c2VUb2FzdCgpXHJcblxyXG4gICAgY29uc3QgY29ubmVjdCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB7IHNhbXBsZVJhdGU6IDE2MDAwLCBjaGFubmVsQ291bnQ6IDEgfSB9KTtcclxuICAgICAgICBjb25zb2xlLmxvZygnW3VzZVdoaXNwZXJMaXZlXSBnb3QgbWljIHBlcm1pc3Npb24nKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnW3VzZVdoaXNwZXJMaXZlXSAgY29ubmVjdCgpJywgY29uZmlnKTtcclxuICAgICAgICBpZiAod3NSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50LmNsb3NlKClcclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudCA9IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMSkgY3JlYXRlIEF1ZGlvQ29udGV4dCBub3cgc28gd2UgY2FuIGhhbmQgaXRzIHJlYWwgc2FtcGxlUmF0ZSB0byB0aGUgc2VydmVyXHJcbiAgICAgICAgY29uc3QgY3R4ID0gbmV3IEF1ZGlvQ29udGV4dCh7IHNhbXBsZVJhdGU6IDE2MDAwIH0pXHJcbiAgICAgICAgY3R4UmVmLmN1cnJlbnQgPSBjdHhcclxuXHJcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgc2F2ZSBvdXQgdGhlIHNhbXBsZVJhdGUgZm9yIGxhdGVyIFdBViBlbmNvZGluZ1xyXG4gICAgICAgIHNhbXBsZVJhdGVSZWYuY3VycmVudCA9IGN0eC5zYW1wbGVSYXRlXHJcblxyXG4gICAgICAgIC8vIGNsZWFyIG91dCBhbnkgb2xkIGZsb2F0cyBmcm9tIGEgcHJldmlvdXMgc2Vzc2lvblxyXG4gICAgICAgIHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudCA9IFtdXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbdXNlV2hpc3BlckxpdmVdIGF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlID0nLCBzYW1wbGVSYXRlUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogbnVsbCB9KSlcclxuXHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonID8gJ3dzcycgOiAnd3MnO1xyXG5cclxuICAgICAgICAvLyBpZiB0aGUgdXNlciB0eXBlZCDigJxsb2NhbGhvc3TigJ0sIHN3YXAgdG8gMTI3LjAuMC4xXHJcbiAgICAgICAgY29uc3QgaG9zdCA9XHJcbiAgICAgICAgICAgIGNvbmZpZy5zZXJ2ZXJVcmwgPT09ICdsb2NhbGhvc3QnIHx8IGNvbmZpZy5zZXJ2ZXJVcmwgPT09ICc6OjEnXHJcbiAgICAgICAgICAgICAgICA/ICcxMjcuMC4wLjEnXHJcbiAgICAgICAgICAgICAgICA6IGNvbmZpZy5zZXJ2ZXJVcmw7XHJcblxyXG4gICAgICAgIGNvbnN0IHdzID0gbmV3IFdlYlNvY2tldChgJHtwcm90b2NvbH06Ly8ke2hvc3R9OiR7Y29uZmlnLnBvcnR9YCk7XHJcbiAgICAgICAgd3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICAgICAgd3NSZWYuY3VycmVudCA9IHdzO1xyXG4gICAgICAgIGxhc3RTZWdtZW50SW5kZXhSZWYuY3VycmVudCA9IDA7XHJcblxyXG5cclxuICAgICAgICB3cy5vbm9wZW4gPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbdXNlV2hpc3BlckxpdmVdIPCfn6IgV2ViU29ja2V0IE9QRU4nKTtcclxuICAgICAgICAgICAgY29uc3QgdGFza05hbWUgPSAndHJhbnNjcmliZSdcclxuICAgICAgICAgICAgd3Muc2VuZChcclxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrOiB0YXNrTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZFJlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBjb25maWcubGFuZ3VhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IGNvbmZpZy5tb2RlbCxcclxuICAgICAgICAgICAgICAgICAgICB1c2VfdmFkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBzdHJlYW06IHRydWUsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVfcmVjb3JkaW5nOiBjb25maWcuc2F2ZVJlY29yZGluZyxcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRfZmlsZW5hbWU6IGNvbmZpZy5vdXRwdXRGaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhfY2xpZW50czogY29uZmlnLm1heENsaWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4X2Nvbm5lY3Rpb25fdGltZTogY29uZmlnLm1heENvbm5lY3Rpb25UaW1lID4gMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbmZpZy5tYXhDb25uZWN0aW9uVGltZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDEyMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlX3JhdGU6IHNhbXBsZVJhdGVSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgICAgICAgICBjaHVua19zaXplOiA0MDk2LFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgYXdhaXQgc3RhcnRUcmFuc2NyaXB0aW9uKCk7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNDb25uZWN0ZWQ6IHRydWUgfSkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNsZWFyQWxsID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZWNvcmRpbmdCdWZmZXJzLmN1cnJlbnQgPSBbXVxyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIHRyYW5zY3JpcHQ6ICcnLCBzZWdtZW50czogW10gfSkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluc2lkZSB5b3VyIGNvbm5lY3QoKVxyXG4gICAgICAgIHdzLm9ubWVzc2FnZSA9IGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmF3IFdTIE1lc3NhZ2U6JywgZS5kYXRhKVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGUuZGF0YSAhPT0gJ3N0cmluZycpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgbXNnID0gSlNPTi5wYXJzZShlLmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1zZy5tZXNzYWdlID09PSAnU0VSVkVSX1JFQURZJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1zZy50eXBlID09PSAnZXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiBtc2cubWVzc2FnZSB9KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChtc2cudHlwZSA9PT0gJ3BhcnRpYWwnIHx8IG1zZy50eXBlID09PSAndHJhbnNjcmlwdCcpIHtcclxuICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVHJhbnNjcmliaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY3JpcHQ6IHMudHJhbnNjcmlwdCArIG1zZy50ZXh0XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1zZy50eXBlID09PSAnZmluYWwnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucyxcclxuICAgICAgICAgICAgICAgICAgICBpc1RyYW5zY3JpYmluZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjcmlwdDogcy50cmFuc2NyaXB0ICsgbXNnLnRleHQgKyAnXFxuJ1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyDihpAgTkVXOiBoYW5kbGUgdGhlIGBzZWdtZW50c2AgYXJyYXlcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobXNnLnNlZ21lbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJtcyA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9EYXRhUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXVkaW9EYXRhUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB4IG9mIGRhdGEpIHN1bSArPSAoeCAtIDEyOCkgKiogMjtcclxuICAgICAgICAgICAgICAgICAgICBybXMgPSBNYXRoLnNxcnQoc3VtIC8gZGF0YS5sZW5ndGgpIC8gMTI4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzOiBTZWdtZW50W10gPSBtc2cuc2VnbWVudHMubWFwKCh3c1NlZzogeyBzcGVha2VyOiBudW1iZXI7IHRleHQ6IGFueTsgfSkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICBzcGVha2VyOiB3c1NlZy5zcGVha2VyID09PSAwID8gJ21pYycgOiAnc3BlYWtlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogd3NTZWcudGV4dCxcclxuICAgICAgICAgICAgICAgICAgICB2b2x1bWU6IHJtcyxcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucyxcclxuICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHM6IFsuLi5zLnNlZ21lbnRzLCAuLi5zZWdtZW50c10sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlzVHJhbnNjcmliaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1t1c2VXaGlzcGVyTGl2ZV0gVG90YWwgc2VnbWVudHMgbm93OicsIHMuc2VnbWVudHMubGVuZ3RoICsgc2VnbWVudHMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBhbnkgc3RyYXkgYG1zZy5tZXNzYWdlYFxyXG4gICAgICAgICAgICBpZiAobXNnLm1lc3NhZ2UgJiYgbXNnLm1lc3NhZ2UgIT09ICdTRVJWRVJfUkVBRFknKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucyxcclxuICAgICAgICAgICAgICAgICAgICBpc1RyYW5zY3JpYmluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NyaXB0OiBzLnRyYW5zY3JpcHQgKyBtc2cubWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIHdzLm9uY2xvc2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHN0b3BUcmFuc2NyaXB0aW9uKClcclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBpc0Nvbm5lY3RlZDogZmFsc2UsIGlzVHJhbnNjcmliaW5nOiBmYWxzZSB9KSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdzLm9uZXJyb3IgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW3VzZVdoaXNwZXJMaXZlXSBXZWJTb2NrZXQgZXJyb3IgKG5vbuKAkWZhdGFsKScsIGVycik7XHJcbiAgICAgICAgICAgIC8vIGRvbuKAmXQgc2V0U3RhdGUgb3IgdG9hc3QgaGVyZVxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbY29uZmlnLCB0b2FzdF0pXHJcblxyXG4gICAgY29uc3QgbWljUmVmID0gdXNlUmVmPE1lZGlhU3RyZWFtIHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IHN5c3RlbVJlZiA9IHVzZVJlZjxNZWRpYVN0cmVhbSB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCBjdHhSZWYgPSB1c2VSZWY8QXVkaW9Db250ZXh0IHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IHByb2Nlc3NvclJlZiA9IHVzZVJlZjxTY3JpcHRQcm9jZXNzb3JOb2RlIHwgbnVsbD4obnVsbClcclxuXHJcbiAgICBjb25zdCBzdGFydFRyYW5zY3JpcHRpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCF3c1JlZi5jdXJyZW50IHx8IHdzUmVmLmN1cnJlbnQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogJ05vdCBjb25uZWN0ZWQnIH0pKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gMSkgU2NyZWVuICsgc3lzdGVtIGF1ZGlvIChpZiBlbmFibGVkKVxyXG4gICAgICAgICAgICBsZXQgc3lzdGVtU3RyZWFtOiBNZWRpYVN0cmVhbSB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmF1ZGlvU291cmNlcz8uc3lzdGVtQXVkaW8pIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3lzdGVtU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlbzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW86IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3lzdGVtUmVmLmN1cnJlbnQgPSBzeXN0ZW1TdHJlYW07XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1N5c3RlbSBhdWRpbyBzaGFyZSBkZW5pZWQgb3Igbm90IHJlcXVlc3RlZDsgZmFsbGluZyBiYWNrIHRvIG1pYyBvbmx5Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDIpIE1pY3JvcGhvbmVcclxuICAgICAgICAgICAgY29uc3QgbWljU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xyXG4gICAgICAgICAgICAgICAgYXVkaW86IHsgc2FtcGxlUmF0ZTogMTYwMDAsIGNoYW5uZWxDb3VudDogMSB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbWljUmVmLmN1cnJlbnQgPSBtaWNTdHJlYW07XHJcblxyXG5cclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gY3R4UmVmLmN1cnJlbnQhXHJcbiAgICAgICAgICAgIGNvbnN0IGRlc3QgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpXHJcblxyXG4gICAgICAgICAgICAvLyA0KSBXaXJlIG1pYyDihpIgZGVzdFxyXG4gICAgICAgICAgICBjb25zdCBtaWNTcmMgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobWljU3RyZWFtKTtcclxuICAgICAgICAgICAgbWljU3JjLmNvbm5lY3QoZGVzdCk7XHJcblxyXG4gICAgICAgICAgICAvLyA1KSBXaXJlIHN5c3RlbSBhdWRpbyDihpIgZGVzdFxyXG4gICAgICAgICAgICBpZiAoc3lzdGVtU3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzeXNTcmMgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3lzdGVtU3RyZWFtKTtcclxuICAgICAgICAgICAgICAgIHN5c1NyYy5jb25uZWN0KGRlc3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyA2KSBJbnN0ZWFkIG9mIHdpcmluZyBtaWMrc3lzIGRpcmVjdGx5IHRvIHRoZSBwcm9jZXNzb3IsIHdlXHJcbiAgICAgICAgICAgIC8vICAgIHRha2UgdGhlIG1peGVkIGRlc3Quc3RyZWFtIGFuZCBob29rIHRoYXQgdXA6XHJcbiAgICAgICAgICAgIGNvbnN0IG1peGVkU3JjID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKGRlc3Quc3RyZWFtKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDcpIENyZWF0ZSB5b3VyIFNjcmlwdFByb2Nlc3NvciAoYnVmZmVyU2l6ZT00MDk2LCBtb25vIGluL291dClcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gY3R4LmNyZWF0ZVNjcmlwdFByb2Nlc3Nvcig0MDk2LCAxLCAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDgpIFdpcmUgdGhlIG1peGVkIGF1ZGlvIGludG8gdGhlIHByb2Nlc3NvclxyXG4gICAgICAgICAgICBtaXhlZFNyYy5jb25uZWN0KHByb2Nlc3Nvcik7XHJcblxyXG4gICAgICAgICAgICAvLyA5KSBPbiBlYWNoIG9uYXVkaW9wcm9jZXNzLCBidWlsZCBleGFjdGx5IG9uZSBwYWNrZXRcclxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uYXVkaW9wcm9jZXNzID0gZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmbG9hdDMyID0gZS5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmxvYXQzMkJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoZmxvYXQzMilcclxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuc2F2ZVJlY29yZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudC5wdXNoKGZsb2F0MzJCdWZmZXIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDihpIgY29udmVydCB0byBVaW50OEFycmF5IFswLi4yNTVdXHJcbiAgICAgICAgICAgICAgICBjb25zdCB1aTggPSBuZXcgVWludDhBcnJheShmbG9hdDMyQnVmZmVyLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmxvYXQzMkJ1ZmZlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHVpOFtpXSA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAyNTUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAsIE1hdGguZmxvb3IoKGZsb2F0MzJCdWZmZXJbaV0gKyAxKSAqIDEyNy41KSlcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc2VuZCByYXcgZmxvYXQzMiBQQ00gdG8gc2VydmVyXHJcbiAgICAgICAgICAgICAgICBpZiAod3NSZWYuY3VycmVudCEucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgICAgICAgICB3c1JlZi5jdXJyZW50IS5zZW5kKGZsb2F0MzJCdWZmZXIuYnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB2aXN1YWxpemVyXHJcbiAgICAgICAgICAgICAgICBzZXRBdWRpb0RhdGEodWk4KVxyXG4gICAgICAgICAgICAgICAgc2V0RGF0YVVwZGF0ZVRyaWdnZXIodCA9PiB0ICsgMSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMTApIFN0YXJ0IGl0XHJcbiAgICAgICAgICAgIHByb2Nlc3Nvci5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgICAgIHByb2Nlc3NvclJlZi5jdXJyZW50ID0gcHJvY2Vzc29yO1xyXG5cclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBpc1RyYW5zY3JpYmluZzogdHJ1ZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiBgRmFpbGVkIHRvIHN0YXJ0IHRyYW5zY3JpcHRpb246ICR7ZXJyLm1lc3NhZ2V9YCB9KSk7XHJcbiAgICAgICAgICAgIHRvYXN0KHsgdGl0bGU6ICdUcmFuc2NyaXB0aW9uIEVycm9yJywgZGVzY3JpcHRpb246IGVyci5tZXNzYWdlLCB2YXJpYW50OiAnZGVzdHJ1Y3RpdmUnIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtjb25maWcsIHRvYXN0XSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHN0b3BUcmFuc2NyaXB0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIC8vIDEpIHRlbGwgdGhlIHNlcnZlciDigJxFTkRfT0ZfQVVESU/igJ1cclxuICAgICAgICBpZiAod3NSZWYuY3VycmVudD8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudC5zZW5kKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShcIkVORF9PRl9BVURJT1wiKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAyKSBpbW1lZGlhdGVseSB0ZWFyIGRvd24gdGhlIFNjcmlwdFByb2Nlc3NvciAmIHRyYWNrc1xyXG4gICAgICAgIGlmIChwcm9jZXNzb3JSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBwcm9jZXNzb3JSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIHByb2Nlc3NvclJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1pY1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIG1pY1JlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSk7XHJcbiAgICAgICAgICAgIG1pY1JlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN5c3RlbVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHN5c3RlbVJlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSk7XHJcbiAgICAgICAgICAgIHN5c3RlbVJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDMpIGlmIHdl4oCZdmUgYmVlbiBzYXZpbmcsIGZsYXR0ZW4gKyBlbmNvZGUgKyB1cGxvYWQgd2hpbGUgY3R4IGlzIHN0aWxsIG9wZW5cclxuICAgICAgICBpZiAoY29uZmlnLnNhdmVSZWNvcmRpbmcgJiYgcmVjb3JkaW5nQnVmZmVycy5jdXJyZW50Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZVdoaXNwZXJMaXZlXSB1cGxvYWRpbmcgV0FWLCBidWZmZXJzOicsIHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudC5sZW5ndGgpXHJcbiAgICAgICAgICAgIC8vIOKXiSB1c2UgdGhlIHNhdmVkIHNhbXBsZVJhdGVcclxuICAgICAgICAgICAgY29uc3Qgc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGVSZWYuY3VycmVudDtcclxuXHJcbiAgICAgICAgICAgIC8vIOKXiSBmbGF0dGVuIGludG8gb25lIEZsb2F0MzJBcnJheVxyXG4gICAgICAgICAgICBjb25zdCB0b3RhbExlbmd0aCA9IHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudC5yZWR1Y2UoKHN1bSwgYnVmKSA9PiBzdW0gKyBidWYubGVuZ3RoLCAwKTtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJsZWF2ZWQgPSBuZXcgRmxvYXQzMkFycmF5KHRvdGFsTGVuZ3RoKTtcclxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYnVmIG9mIHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJsZWF2ZWQuc2V0KGJ1Ziwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBidWYubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyDil4kgZW5jb2RlICsgdXBsb2FkXHJcbiAgICAgICAgICAgIGNvbnN0IHdhdlZpZXcgPSBlbmNvZGVXQVYoaW50ZXJsZWF2ZWQsIHNhbXBsZVJhdGUpO1xyXG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3dhdlZpZXcuYnVmZmVyXSwgeyB0eXBlOiAnYXVkaW8vd2F2JyB9KTtcclxuICAgICAgICAgICAgY29uc3QgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4gICAgICAgICAgICBmb3JtLmFwcGVuZCgnZmlsZScsIGJsb2IsIGNvbmZpZy5vdXRwdXRGaWxlbmFtZSB8fCAncmVjb3JkaW5nLndhdicpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvdXBsb2FkJywgeyBtZXRob2Q6ICdQT1NUJywgYm9keTogZm9ybSB9KVxyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcigndXBsb2FkIGZhaWxlZCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVybCB9ID0gYXdhaXQgcmVzLmpzb24oKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjOiBSZWNvcmRpbmcgPSB7IGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksIHVybCwgYmxvYiB9XHJcbiAgICAgICAgICAgICAgICBzZXRSZWNvcmRpbmdzKHJzID0+IFsuLi5ycywgcmVjXSlcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgICAgICAgICAgIHRvYXN0KHsgdGl0bGU6ICdVcGxvYWQgRXJyb3InLCBkZXNjcmlwdGlvbjogU3RyaW5nKGVyciksIHZhcmlhbnQ6ICdkZXN0cnVjdGl2ZScgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWNvcmRpbmdCdWZmZXJzLmN1cnJlbnQgPSBbXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gNCkgKipub3cqKiB0ZWFyIGRvd24geW91ciBBdWRpb0NvbnRleHRcclxuICAgICAgICBpZiAoY3R4UmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgY3R4UmVmLmN1cnJlbnQuY2xvc2UoKTtcclxuICAgICAgICAgICAgY3R4UmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gNSkgZmluYWxseSwgdXBkYXRlIHN0YXRlXHJcbiAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBpc1RyYW5zY3JpYmluZzogZmFsc2UgfSkpO1xyXG4gICAgfSwgW2NvbmZpZywgdG9hc3RdKTtcclxuXHJcblxyXG5cclxuXHJcbiAgICBjb25zdCBkaXNjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGlmICh3c1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICAgIH1cclxuICAgICAgICBzdG9wVHJhbnNjcmlwdGlvbigpXHJcbiAgICAgICAgc2V0U3RhdGUocyA9PiAoe1xyXG4gICAgICAgICAgICAuLi5zLFxyXG4gICAgICAgICAgICBpc0Nvbm5lY3RlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzVHJhbnNjcmliaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgdHJhbnNjcmlwdDogJycsXHJcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgICAgICAgICBzZWdtZW50czogW10sICAgIC8vIGNsZWFyIG91dCBhbnkgb2xkIGRpYXJpemVkIHNlZ21lbnRzIHRvb1xyXG4gICAgICAgIH0pKVxyXG4gICAgfSwgW3N0b3BUcmFuc2NyaXB0aW9uXSlcclxuXHJcbiAgICBjb25zdCBjbGVhclRyYW5zY3JpcHQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCB0cmFuc2NyaXB0OiAnJyB9KSlcclxuICAgIH0sIFtdKVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgY29ubmVjdCxcclxuICAgICAgICBzdGFydFRyYW5zY3JpcHRpb24sXHJcbiAgICAgICAgc3RvcFRyYW5zY3JpcHRpb24sXHJcbiAgICAgICAgZGlzY29ubmVjdCxcclxuICAgICAgICBjbGVhclRyYW5zY3JpcHQsXHJcbiAgICAgICAgd3NSZWYsXHJcbiAgICAgICAgYXVkaW9EYXRhLFxyXG4gICAgICAgIGRhdGFVcGRhdGVUcmlnZ2VyLFxyXG4gICAgICAgIHJlY29yZGluZ3MsXHJcbiAgICAgICAgcmVzZXRTZWdtZW50cyxcclxuICAgICAgICBkZWxldGVSZWNvcmRpbmc6IChyOiBSZWNvcmRpbmcpID0+IHNldFJlY29yZGluZ3MocnMgPT4gcnMuZmlsdGVyKHggPT4geC5pZCAhPT0gci5pZCkpLFxyXG4gICAgICAgIHJlc2V0UmVjb3JkaW5ncyxcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZVRvYXN0IiwiZW5jb2RlV0FWIiwic2FtcGxlcyIsInNhbXBsZVJhdGUiLCJiaXRzUGVyU2FtcGxlIiwiYnl0ZXNQZXJTYW1wbGUiLCJibG9ja0FsaWduIiwiYnl0ZVJhdGUiLCJkYXRhU2l6ZSIsImxlbmd0aCIsImJ1ZmZlciIsIkFycmF5QnVmZmVyIiwidmlldyIsIkRhdGFWaWV3Iiwid3JpdGVTdHJpbmciLCJzZXRVaW50MzIiLCJzZXRVaW50MTYiLCJvZmZzZXQiLCJpIiwicyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJzZXRJbnQxNiIsInNldFVpbnQ4IiwiY2hhckNvZGVBdCIsInVzZVdoaXNwZXJMaXZlIiwiY29uZmlnIiwiaW5pdGlhbFJlY29yZGluZ3MiLCJyZWNvcmRpbmdzIiwic2V0UmVjb3JkaW5ncyIsInN0YXRlIiwic2V0U3RhdGUiLCJpc0Nvbm5lY3RlZCIsImlzVHJhbnNjcmliaW5nIiwidHJhbnNjcmlwdCIsImVycm9yIiwic2VnbWVudHMiLCJhdWRpb0RhdGEiLCJzZXRBdWRpb0RhdGEiLCJkYXRhVXBkYXRlVHJpZ2dlciIsInNldERhdGFVcGRhdGVUcmlnZ2VyIiwid3NSZWYiLCJyZWNvcmRpbmdCdWZmZXJzIiwic2FtcGxlUmF0ZVJlZiIsImxhc3RTZWdtZW50SW5kZXhSZWYiLCJhdWRpb0RhdGFSZWYiLCJyZXNldFNlZ21lbnRzIiwicmVzZXRSZWNvcmRpbmdzIiwidWlkUmVmIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJ0b2FzdCIsImNvbm5lY3QiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJhdWRpbyIsImNoYW5uZWxDb3VudCIsImNvbnNvbGUiLCJsb2ciLCJjdXJyZW50IiwiY2xvc2UiLCJjdHgiLCJBdWRpb0NvbnRleHQiLCJjdHhSZWYiLCJwcm90b2NvbCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaG9zdCIsInNlcnZlclVybCIsIndzIiwiV2ViU29ja2V0IiwicG9ydCIsImJpbmFyeVR5cGUiLCJvbm9wZW4iLCJ0YXNrTmFtZSIsInNlbmQiLCJKU09OIiwic3RyaW5naWZ5IiwidGFzayIsInVpZCIsImxhbmd1YWdlIiwibW9kZWwiLCJ1c2VfdmFkIiwic3RyZWFtIiwic2F2ZV9yZWNvcmRpbmciLCJzYXZlUmVjb3JkaW5nIiwib3V0cHV0X2ZpbGVuYW1lIiwib3V0cHV0RmlsZW5hbWUiLCJtYXhfY2xpZW50cyIsIm1heENsaWVudHMiLCJtYXhfY29ubmVjdGlvbl90aW1lIiwibWF4Q29ubmVjdGlvblRpbWUiLCJzYW1wbGVfcmF0ZSIsImNodW5rX3NpemUiLCJzdGFydFRyYW5zY3JpcHRpb24iLCJjbGVhckFsbCIsIm9ubWVzc2FnZSIsImUiLCJkYXRhIiwibXNnIiwicGFyc2UiLCJtZXNzYWdlIiwidHlwZSIsInRleHQiLCJBcnJheSIsImlzQXJyYXkiLCJybXMiLCJzdW0iLCJ4Iiwic3FydCIsIm1hcCIsIndzU2VnIiwic3BlYWtlciIsImNvbnRlbnQiLCJ2b2x1bWUiLCJvbmNsb3NlIiwib25lcnJvciIsImVyciIsIndhcm4iLCJtaWNSZWYiLCJzeXN0ZW1SZWYiLCJwcm9jZXNzb3JSZWYiLCJyZWFkeVN0YXRlIiwiT1BFTiIsInN5c3RlbVN0cmVhbSIsImF1ZGlvU291cmNlcyIsInN5c3RlbUF1ZGlvIiwiZ2V0RGlzcGxheU1lZGlhIiwidmlkZW8iLCJtaWNTdHJlYW0iLCJkZXN0IiwiY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbiIsIm1pY1NyYyIsImNyZWF0ZU1lZGlhU3RyZWFtU291cmNlIiwic3lzU3JjIiwibWl4ZWRTcmMiLCJwcm9jZXNzb3IiLCJjcmVhdGVTY3JpcHRQcm9jZXNzb3IiLCJvbmF1ZGlvcHJvY2VzcyIsImZsb2F0MzIiLCJpbnB1dEJ1ZmZlciIsImdldENoYW5uZWxEYXRhIiwiZmxvYXQzMkJ1ZmZlciIsIkZsb2F0MzJBcnJheSIsInB1c2giLCJ1aTgiLCJVaW50OEFycmF5IiwiZmxvb3IiLCJ0IiwiZGVzdGluYXRpb24iLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwidmFyaWFudCIsInN0b3BUcmFuc2NyaXB0aW9uIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJkaXNjb25uZWN0IiwiZ2V0VHJhY2tzIiwiZm9yRWFjaCIsInN0b3AiLCJ0b3RhbExlbmd0aCIsInJlZHVjZSIsImJ1ZiIsImludGVybGVhdmVkIiwic2V0Iiwid2F2VmlldyIsImJsb2IiLCJCbG9iIiwiZm9ybSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5Iiwib2siLCJFcnJvciIsInVybCIsImpzb24iLCJyZWMiLCJpZCIsIkRhdGUiLCJub3ciLCJycyIsIlN0cmluZyIsImNsZWFyVHJhbnNjcmlwdCIsImRlbGV0ZVJlY29yZGluZyIsInIiLCJmaWx0ZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-whisper-live.ts\n"));

/***/ })

});