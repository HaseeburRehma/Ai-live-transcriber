"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/notes/page",{

/***/ "(app-pages-browser)/./src/hooks/use-whisper-live.ts":
/*!***************************************!*\
  !*** ./src/hooks/use-whisper-live.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWhisperLive: () => (/* binding */ useWhisperLive)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/hooks/use-toast */ \"(app-pages-browser)/./src/hooks/use-toast.ts\");\n/* __next_internal_client_entry_do_not_use__ useWhisperLive auto */ \n\nfunction encodeWAV(samples, sampleRate) {\n    const bitsPerSample = 16;\n    const bytesPerSample = bitsPerSample / 8;\n    const blockAlign = bytesPerSample // mono\n    ;\n    const byteRate = sampleRate * blockAlign;\n    const dataSize = samples.length * bytesPerSample;\n    const buffer = new ArrayBuffer(44 + dataSize);\n    const view = new DataView(buffer);\n    /* RIFF identifier */ writeString(view, 0, 'RIFF');\n    /* file length minus first 8 bytes */ view.setUint32(4, 36 + dataSize, true);\n    /* WAVE type */ writeString(view, 8, 'WAVE');\n    /* fmt  chunk */ writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true) // chunk length\n    ;\n    view.setUint16(20, 1, true) // PCM\n    ;\n    view.setUint16(22, 1, true) // mono\n    ;\n    view.setUint32(24, sampleRate, true) // sampleRate\n    ;\n    view.setUint32(28, byteRate, true) // byteRate\n    ;\n    view.setUint16(32, blockAlign, true) // blockAlign\n    ;\n    view.setUint16(34, bitsPerSample, true) // bitsPerSample\n    ;\n    /* data chunk */ writeString(view, 36, 'data');\n    view.setUint32(40, dataSize, true);\n    // write PCM samples\n    let offset = 44;\n    for(let i = 0; i < samples.length; i++){\n        // clamp\n        const s = Math.max(-1, Math.min(1, samples[i]));\n        // scale to 16â€‘bit int\n        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n        offset += 2;\n    }\n    return view;\n}\nfunction writeString(view, offset, s) {\n    for(let i = 0; i < s.length; i++){\n        view.setUint8(offset + i, s.charCodeAt(i));\n    }\n}\nfunction useWhisperLive(config) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        isTranscribing: false,\n        transcript: '',\n        error: null\n    });\n    const [audioData, setAudioData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [dataUpdateTrigger, setDataUpdateTrigger] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const recordingBuffers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const sampleRateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const uidRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));\n    const { toast } = (0,_hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__.useToast)();\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[connect]\": ()=>{\n            console.log('[useWhisperLive]  connect()', config);\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            // 1) create AudioContext now so we can hand its real sampleRate to the server\n            const ctx = new AudioContext({\n                sampleRate: 16000\n            });\n            ctxRef.current = ctx;\n            // immediately save out the sampleRate for later WAV encoding\n            sampleRateRef.current = ctx.sampleRate;\n            // clear out any old floats from a previous session\n            recordingBuffers.current = [];\n            console.log('[useWhisperLive] audioContext.sampleRate =', sampleRateRef.current);\n            setState({\n                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                        ...s,\n                        error: null\n                    })\n            }[\"useWhisperLive.useCallback[connect]\"]);\n            const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\n            const ws = new WebSocket(\"\".concat(protocol, \"://\").concat(config.serverUrl, \":\").concat(config.port));\n            ws.binaryType = 'arraybuffer';\n            wsRef.current = ws;\n            ws.onopen = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    console.log('[useWhisperLive] ðŸŸ¢ WebSocket OPEN');\n                    const taskName = config.translate ? 'translate' : 'transcribe';\n                    ws.send(JSON.stringify({\n                        task: taskName,\n                        uid: uidRef.current,\n                        language: config.language,\n                        model: config.model,\n                        use_vad: config.vad,\n                        // only send us the newest segment each time:\n                        send_last_n_segments: 1,\n                        save_recording: config.saveRecording,\n                        output_filename: config.outputFilename,\n                        max_clients: config.maxClients,\n                        max_connection_time: config.maxConnectionTime,\n                        // **important**: must match your AudioContext & ScriptProcessor\n                        sample_rate: sampleRateRef.current,\n                        chunk_size: 4096\n                    }));\n                    startTranscription();\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: true\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            // inside your connect()\n            ws.onmessage = ({\n                \"useWhisperLive.useCallback[connect]\": (e)=>{\n                    console.log('Raw WS Message:', e.data);\n                    if (typeof e.data !== 'string') return;\n                    const msg = JSON.parse(e.data);\n                    // ignore handshake\n                    if (msg.message === 'SERVER_READY') return;\n                    // errors\n                    if (msg.type === 'error') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    error: msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // oldâ€style partial/final (if you ever toggle that back on)\n                    if (msg.type === 'partial' || msg.type === 'transcript') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + msg.text\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    if (msg.type === 'final') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: false,\n                                    transcript: s.transcript + msg.text + '\\n'\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // â† NEW: handle the `segments` array\n                    if (Array.isArray(msg.segments)) {\n                        // just grab the very last segment and append it\n                        const last = msg.segments[msg.segments.length - 1];\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + last.text\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // fallback to any stray `msg.message`\n                    if (msg.message && msg.message !== 'SERVER_READY') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                    }\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onclose = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: false,\n                                isTranscribing: false\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onerror = ({\n                \"useWhisperLive.useCallback[connect]\": (err)=>{\n                    console.warn('[useWhisperLive] WebSocket error (nonâ€‘fatal)', err);\n                // donâ€™t setState or toast here\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n        }\n    }[\"useWhisperLive.useCallback[connect]\"], [\n        config,\n        toast\n    ]);\n    const micRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const systemRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ctxRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const processorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const startTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[startTranscription]\": async ()=>{\n            if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: 'Not connected'\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                return;\n            }\n            try {\n                var _config_audioSources;\n                // 1) Screen + system audio (if enabled)\n                let systemStream = null;\n                if ((_config_audioSources = config.audioSources) === null || _config_audioSources === void 0 ? void 0 : _config_audioSources.systemAudio) {\n                    systemStream = await navigator.mediaDevices.getDisplayMedia({\n                        video: true,\n                        audio: true\n                    });\n                    systemRef.current = systemStream;\n                }\n                // 2) Microphone\n                const micStream = await navigator.mediaDevices.getUserMedia({\n                    audio: {\n                        sampleRate: 16000,\n                        channelCount: 1\n                    }\n                });\n                micRef.current = micStream;\n                const ctx = ctxRef.current;\n                const dest = ctx.createMediaStreamDestination();\n                // 4) Wire mic â†’ dest\n                const micSrc = ctx.createMediaStreamSource(micStream);\n                micSrc.connect(dest);\n                // 5) Wire system audio â†’ dest\n                if (systemStream) {\n                    const sysSrc = ctx.createMediaStreamSource(systemStream);\n                    sysSrc.connect(dest);\n                }\n                // 6) Instead of wiring mic+sys directly to the processor, we\n                //    take the mixed dest.stream and hook that up:\n                const mixedSrc = ctx.createMediaStreamSource(dest.stream);\n                // 7) Create your ScriptProcessor (bufferSize=4096, mono in/out)\n                const processor = ctx.createScriptProcessor(4096, 1, 1);\n                // 8) Wire the mixed audio into the processor\n                mixedSrc.connect(processor);\n                // 9) On each onaudioprocess, build exactly one packet\n                processor.onaudioprocess = ({\n                    \"useWhisperLive.useCallback[startTranscription]\": (e)=>{\n                        const float32 = e.inputBuffer.getChannelData(0);\n                        const float32Buffer = new Float32Array(float32);\n                        if (config.saveRecording) {\n                            recordingBuffers.current.push(float32Buffer);\n                        }\n                        // â†’ convert to Uint8Array [0..255]\n                        const ui8 = new Uint8Array(float32Buffer.length);\n                        for(let i = 0; i < float32Buffer.length; i++){\n                            ui8[i] = Math.min(255, Math.max(0, Math.floor((float32Buffer[i] + 1) * 127.5)));\n                        }\n                        // send raw float32 PCM to server\n                        if (wsRef.current.readyState === WebSocket.OPEN) {\n                            wsRef.current.send(float32Buffer.buffer);\n                        }\n                        // update visualizer\n                        setAudioData(ui8);\n                        setDataUpdateTrigger({\n                            \"useWhisperLive.useCallback[startTranscription]\": (t)=>t + 1\n                        }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                    }\n                })[\"useWhisperLive.useCallback[startTranscription]\"];\n                // 10) Start it\n                processor.connect(ctx.destination);\n                processorRef.current = processor;\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            isTranscribing: true\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n            } catch (err) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: \"Failed to start transcription: \".concat(err.message)\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                toast({\n                    title: 'Transcription Error',\n                    description: err.message,\n                    variant: 'destructive'\n                });\n            }\n        }\n    }[\"useWhisperLive.useCallback[startTranscription]\"], [\n        config,\n        toast\n    ]);\n    const stopTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[stopTranscription]\": ()=>{\n            var _wsRef_current;\n            if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                // zeroâ€‘length ArrayBuffer signals â€œplease flush & finishâ€\n                wsRef.current.send(new TextEncoder().encode(\"END_OF_AUDIO\"));\n            }\n            // tear down audio graph immediately\n            if (processorRef.current) {\n                processorRef.current.disconnect();\n                processorRef.current = null;\n            }\n            if (micRef.current) {\n                micRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                micRef.current = null;\n            }\n            if (systemRef.current) {\n                systemRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                systemRef.current = null;\n            }\n            if (ctxRef.current) {\n                ctxRef.current.close();\n                ctxRef.current = null;\n            }\n            if (config.saveRecording && recordingBuffers.current.length) {\n                // 1) capture rate before closing\n                const sampleRate = ctxRef.current.sampleRate;\n                // 2) flatten all your Float32Array chunks into one\n                const totalLength = recordingBuffers.current.reduce({\n                    \"useWhisperLive.useCallback[stopTranscription].totalLength\": (sum, buf)=>sum + buf.length\n                }[\"useWhisperLive.useCallback[stopTranscription].totalLength\"], 0);\n                const interleaved = new Float32Array(totalLength);\n                let off = 0;\n                for (const buf of recordingBuffers.current){\n                    interleaved.set(buf, off);\n                    off += buf.length;\n                }\n                // 3) encode + upload\n                const wavView = encodeWAV(interleaved, sampleRate);\n                const blob = new Blob([\n                    wavView.buffer\n                ], {\n                    type: 'audio/wav'\n                });\n                const form = new FormData();\n                form.append('file', blob, config.outputFilename || 'recording.wav');\n                fetch('/api/upload', {\n                    method: 'POST',\n                    body: form\n                }).then({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (r)=>r.ok || Promise.reject('upload failed')\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]).catch({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (err)=>toast({\n                            title: 'Upload Error',\n                            description: String(err),\n                            variant: 'destructive'\n                        })\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                recordingBuffers.current = [];\n            }\n            // finally tear down your AudioContext\n            if (ctxRef.current) {\n                ctxRef.current.close();\n                ctxRef.current = null;\n            }\n            setState({\n                \"useWhisperLive.useCallback[stopTranscription]\": (s)=>({\n                        ...s,\n                        isTranscribing: false\n                    })\n            }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n        }\n    }[\"useWhisperLive.useCallback[stopTranscription]\"], [\n        config,\n        toast\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[disconnect]\": ()=>{\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            stopTranscription();\n            setState({\n                isConnected: false,\n                isTranscribing: false,\n                transcript: '',\n                error: null\n            });\n        }\n    }[\"useWhisperLive.useCallback[disconnect]\"], [\n        stopTranscription\n    ]);\n    const clearTranscript = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[clearTranscript]\": ()=>{\n            setState({\n                \"useWhisperLive.useCallback[clearTranscript]\": (s)=>({\n                        ...s,\n                        transcript: ''\n                    })\n            }[\"useWhisperLive.useCallback[clearTranscript]\"]);\n        }\n    }[\"useWhisperLive.useCallback[clearTranscript]\"], []);\n    return {\n        state,\n        connect,\n        startTranscription,\n        stopTranscription,\n        disconnect,\n        clearTranscript,\n        wsRef,\n        audioData,\n        dataUpdateTrigger\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utd2hpc3Blci1saXZlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7b0VBRXFEO0FBQ1Q7QUFzQjVDLFNBQVNJLFVBQVVDLE9BQXFCLEVBQUVDLFVBQWtCO0lBQ3hELE1BQU1DLGdCQUFnQjtJQUN0QixNQUFNQyxpQkFBaUJELGdCQUFnQjtJQUN2QyxNQUFNRSxhQUFhRCxlQUFlLE9BQU87O0lBQ3pDLE1BQU1FLFdBQVdKLGFBQWFHO0lBQzlCLE1BQU1FLFdBQVdOLFFBQVFPLE1BQU0sR0FBR0o7SUFDbEMsTUFBTUssU0FBUyxJQUFJQyxZQUFZLEtBQUtIO0lBQ3BDLE1BQU1JLE9BQU8sSUFBSUMsU0FBU0g7SUFFMUIsbUJBQW1CLEdBQ25CSSxZQUFZRixNQUFNLEdBQUc7SUFDckIsbUNBQW1DLEdBQ25DQSxLQUFLRyxTQUFTLENBQUMsR0FBRyxLQUFLUCxVQUFVO0lBQ2pDLGFBQWEsR0FDYk0sWUFBWUYsTUFBTSxHQUFHO0lBQ3JCLGNBQWMsR0FDZEUsWUFBWUYsTUFBTSxJQUFJO0lBQ3RCQSxLQUFLRyxTQUFTLENBQUMsSUFBSSxJQUFJLE1BQXFCLGVBQWU7O0lBQzNESCxLQUFLSSxTQUFTLENBQUMsSUFBSSxHQUFHLE1BQXNCLE1BQU07O0lBQ2xESixLQUFLSSxTQUFTLENBQUMsSUFBSSxHQUFHLE1BQXNCLE9BQU87O0lBQ25ESixLQUFLRyxTQUFTLENBQUMsSUFBSVosWUFBWSxNQUFhLGFBQWE7O0lBQ3pEUyxLQUFLRyxTQUFTLENBQUMsSUFBSVIsVUFBVSxNQUFlLFdBQVc7O0lBQ3ZESyxLQUFLSSxTQUFTLENBQUMsSUFBSVYsWUFBWSxNQUFhLGFBQWE7O0lBQ3pETSxLQUFLSSxTQUFTLENBQUMsSUFBSVosZUFBZSxNQUFVLGdCQUFnQjs7SUFDNUQsY0FBYyxHQUNkVSxZQUFZRixNQUFNLElBQUk7SUFDdEJBLEtBQUtHLFNBQVMsQ0FBQyxJQUFJUCxVQUFVO0lBRTdCLG9CQUFvQjtJQUNwQixJQUFJ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Q0MsS0FBSztnQkFDcEJHLE9BQU9KLE9BQU8sR0FBRztZQUNyQjtZQUNBdEI7aUVBQVNWLENBQUFBLElBQU07d0JBQUUsR0FBR0EsQ0FBQzt3QkFBRVksZ0JBQWdCO29CQUFNOztRQUVqRDt3REFBRztRQUFDSjtRQUFRb0I7S0FBTTtJQUlsQixNQUFNb0csYUFBYXBKLGtEQUFXQTtrREFBQztZQUMzQixJQUFJdUMsTUFBTWEsT0FBTyxFQUFFO2dCQUNmYixNQUFNYSxPQUFPLENBQUNDLEtBQUs7Z0JBQ25CZCxNQUFNYSxPQUFPLEdBQUc7WUFDcEI7WUFDQTZGO1lBQ0FuSCxTQUFTO2dCQUFFQyxhQUFhO2dCQUFPQyxnQkFBZ0I7Z0JBQU9DLFlBQVk7Z0JBQUlDLE9BQU87WUFBSztRQUN0RjtpREFBRztRQUFDK0c7S0FBa0I7SUFFdEIsTUFBTThCLGtCQUFrQi9LLGtEQUFXQTt1REFBQztZQUNoQzhCOytEQUFTVixDQUFBQSxJQUFNO3dCQUFFLEdBQUdBLENBQUM7d0JBQUVhLFlBQVk7b0JBQUc7O1FBQzFDO3NEQUFHLEVBQUU7SUFFTCxPQUFPO1FBQ0hKO1FBQ0FvQjtRQUNBdUM7UUFDQXlEO1FBQ0FHO1FBQ0EyQjtRQUNBeEk7UUFDQUo7UUFDQUU7SUFDSjtBQUNKIiwic291cmNlcyI6WyJFOlxcQWl2b2ljZXRvdGV4dFxcc3JjXFxob29rc1xcdXNlLXdoaXNwZXItbGl2ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IHVzZVRvYXN0IH0gZnJvbSAnQC9ob29rcy91c2UtdG9hc3QnXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFdoaXNwZXJMaXZlQ29uZmlnIHtcclxuICAgIHNlcnZlclVybDogc3RyaW5nXHJcbiAgICBwb3J0OiBudW1iZXJcclxuICAgIGxhbmd1YWdlOiBzdHJpbmdcclxuICAgIHRyYW5zbGF0ZTogYm9vbGVhblxyXG4gICAgbW9kZWw6IHN0cmluZ1xyXG4gICAgdmFkOiBib29sZWFuXHJcbiAgICBzYXZlUmVjb3JkaW5nOiBib29sZWFuXHJcbiAgICBvdXRwdXRGaWxlbmFtZTogc3RyaW5nXHJcbiAgICBtYXhDbGllbnRzOiBudW1iZXJcclxuICAgIG1heENvbm5lY3Rpb25UaW1lOiBudW1iZXJcclxuICAgIGF1ZGlvU291cmNlcz86IHsgbWljcm9waG9uZTogYm9vbGVhbjsgc3lzdGVtQXVkaW86IGJvb2xlYW4gfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgV2hpc3BlckxpdmVTdGF0ZSB7XHJcbiAgICBpc0Nvbm5lY3RlZDogYm9vbGVhblxyXG4gICAgaXNUcmFuc2NyaWJpbmc6IGJvb2xlYW5cclxuICAgIHRyYW5zY3JpcHQ6IHN0cmluZ1xyXG4gICAgZXJyb3I6IHN0cmluZyB8IG51bGxcclxufVxyXG5mdW5jdGlvbiBlbmNvZGVXQVYoc2FtcGxlczogRmxvYXQzMkFycmF5LCBzYW1wbGVSYXRlOiBudW1iZXIpOiBEYXRhVmlldyB7XHJcbiAgICBjb25zdCBiaXRzUGVyU2FtcGxlID0gMTZcclxuICAgIGNvbnN0IGJ5dGVzUGVyU2FtcGxlID0gYml0c1BlclNhbXBsZSAvIDhcclxuICAgIGNvbnN0IGJsb2NrQWxpZ24gPSBieXRlc1BlclNhbXBsZSAvLyBtb25vXHJcbiAgICBjb25zdCBieXRlUmF0ZSA9IHNhbXBsZVJhdGUgKiBibG9ja0FsaWduXHJcbiAgICBjb25zdCBkYXRhU2l6ZSA9IHNhbXBsZXMubGVuZ3RoICogYnl0ZXNQZXJTYW1wbGVcclxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0NCArIGRhdGFTaXplKVxyXG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpXHJcblxyXG4gICAgLyogUklGRiBpZGVudGlmaWVyICovXHJcbiAgICB3cml0ZVN0cmluZyh2aWV3LCAwLCAnUklGRicpXHJcbiAgICAvKiBmaWxlIGxlbmd0aCBtaW51cyBmaXJzdCA4IGJ5dGVzICovXHJcbiAgICB2aWV3LnNldFVpbnQzMig0LCAzNiArIGRhdGFTaXplLCB0cnVlKVxyXG4gICAgLyogV0FWRSB0eXBlICovXHJcbiAgICB3cml0ZVN0cmluZyh2aWV3LCA4LCAnV0FWRScpXHJcbiAgICAvKiBmbXQgIGNodW5rICovXHJcbiAgICB3cml0ZVN0cmluZyh2aWV3LCAxMiwgJ2ZtdCAnKVxyXG4gICAgdmlldy5zZXRVaW50MzIoMTYsIDE2LCB0cnVlKSAgICAgICAgICAgICAgICAvLyBjaHVuayBsZW5ndGhcclxuICAgIHZpZXcuc2V0VWludDE2KDIwLCAxLCB0cnVlKSAgICAgICAgICAgICAgICAgLy8gUENNXHJcbiAgICB2aWV3LnNldFVpbnQxNigyMiwgMSwgdHJ1ZSkgICAgICAgICAgICAgICAgIC8vIG1vbm9cclxuICAgIHZpZXcuc2V0VWludDMyKDI0LCBzYW1wbGVSYXRlLCB0cnVlKSAgICAgICAgLy8gc2FtcGxlUmF0ZVxyXG4gICAgdmlldy5zZXRVaW50MzIoMjgsIGJ5dGVSYXRlLCB0cnVlKSAgICAgICAgICAvLyBieXRlUmF0ZVxyXG4gICAgdmlldy5zZXRVaW50MTYoMzIsIGJsb2NrQWxpZ24sIHRydWUpICAgICAgICAvLyBibG9ja0FsaWduXHJcbiAgICB2aWV3LnNldFVpbnQxNigzNCwgYml0c1BlclNhbXBsZSwgdHJ1ZSkgICAgIC8vIGJpdHNQZXJTYW1wbGVcclxuICAgIC8qIGRhdGEgY2h1bmsgKi9cclxuICAgIHdyaXRlU3RyaW5nKHZpZXcsIDM2LCAnZGF0YScpXHJcbiAgICB2aWV3LnNldFVpbnQzMig0MCwgZGF0YVNpemUsIHRydWUpXHJcblxyXG4gICAgLy8gd3JpdGUgUENNIHNhbXBsZXNcclxuICAgIGxldCBvZmZzZXQgPSA0NFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gY2xhbXBcclxuICAgICAgICBjb25zdCBzID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIHNhbXBsZXNbaV0pKVxyXG4gICAgICAgIC8vIHNjYWxlIHRvIDE24oCRYml0IGludFxyXG4gICAgICAgIHZpZXcuc2V0SW50MTYoXHJcbiAgICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICAgICAgcyA8IDAgPyBzICogMHg4MDAwIDogcyAqIDB4N0ZGRixcclxuICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgIClcclxuICAgICAgICBvZmZzZXQgKz0gMlxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2aWV3XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlU3RyaW5nKHZpZXc6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlciwgczogc3RyaW5nKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIGksIHMuY2hhckNvZGVBdChpKSlcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdXNlV2hpc3BlckxpdmUoY29uZmlnOiBXaGlzcGVyTGl2ZUNvbmZpZykge1xyXG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxXaGlzcGVyTGl2ZVN0YXRlPih7XHJcbiAgICAgICAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzVHJhbnNjcmliaW5nOiBmYWxzZSxcclxuICAgICAgICB0cmFuc2NyaXB0OiAnJyxcclxuICAgICAgICBlcnJvcjogbnVsbCxcclxuICAgIH0pXHJcbiAgICBjb25zdCBbYXVkaW9EYXRhLCBzZXRBdWRpb0RhdGFdID0gdXNlU3RhdGU8VWludDhBcnJheSB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCBbZGF0YVVwZGF0ZVRyaWdnZXIsIHNldERhdGFVcGRhdGVUcmlnZ2VyXSA9IHVzZVN0YXRlKDApXHJcbiAgICBjb25zdCB3c1JlZiA9IHVzZVJlZjxXZWJTb2NrZXQgfCBudWxsPihudWxsKVxyXG4gICAgY29uc3QgcmVjb3JkaW5nQnVmZmVycyA9IHVzZVJlZjxGbG9hdDMyQXJyYXlbXT4oW10pXHJcbiAgICBjb25zdCBzYW1wbGVSYXRlUmVmID0gdXNlUmVmPG51bWJlcj4oMClcclxuXHJcblxyXG4gICAgY29uc3QgdWlkUmVmID0gdXNlUmVmKFxyXG4gICAgICAgIHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEXHJcbiAgICAgICAgICAgID8gY3J5cHRvLnJhbmRvbVVVSUQoKVxyXG4gICAgICAgICAgICA6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLFxyXG4gICAgKVxyXG4gICAgY29uc3QgeyB0b2FzdCB9ID0gdXNlVG9hc3QoKVxyXG5cclxuICAgIGNvbnN0IGNvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1t1c2VXaGlzcGVyTGl2ZV0gIGNvbm5lY3QoKScsIGNvbmZpZyk7XHJcbiAgICAgICAgaWYgKHdzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudC5jbG9zZSgpXHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDEpIGNyZWF0ZSBBdWRpb0NvbnRleHQgbm93IHNvIHdlIGNhbiBoYW5kIGl0cyByZWFsIHNhbXBsZVJhdGUgdG8gdGhlIHNlcnZlclxyXG4gICAgICAgIGNvbnN0IGN0eCA9IG5ldyBBdWRpb0NvbnRleHQoeyBzYW1wbGVSYXRlOiAxNjAwMCB9KVxyXG4gICAgICAgIGN0eFJlZi5jdXJyZW50ID0gY3R4XHJcblxyXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHNhdmUgb3V0IHRoZSBzYW1wbGVSYXRlIGZvciBsYXRlciBXQVYgZW5jb2RpbmdcclxuICAgICAgICBzYW1wbGVSYXRlUmVmLmN1cnJlbnQgPSBjdHguc2FtcGxlUmF0ZVxyXG5cclxuICAgICAgICAvLyBjbGVhciBvdXQgYW55IG9sZCBmbG9hdHMgZnJvbSBhIHByZXZpb3VzIHNlc3Npb25cclxuICAgICAgICByZWNvcmRpbmdCdWZmZXJzLmN1cnJlbnQgPSBbXVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZygnW3VzZVdoaXNwZXJMaXZlXSBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSA9Jywgc2FtcGxlUmF0ZVJlZi5jdXJyZW50KVxyXG4gICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgZXJyb3I6IG51bGwgfSkpXHJcblxyXG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyA/ICd3c3MnIDogJ3dzJztcclxuICAgICAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQoYCR7cHJvdG9jb2x9Oi8vJHtjb25maWcuc2VydmVyVXJsfToke2NvbmZpZy5wb3J0fWApO1xyXG4gICAgICAgIHdzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXHJcbiAgICAgICAgd3NSZWYuY3VycmVudCA9IHdzXHJcblxyXG4gICAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1t1c2VXaGlzcGVyTGl2ZV0g8J+foiBXZWJTb2NrZXQgT1BFTicpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXNrTmFtZSA9IGNvbmZpZy50cmFuc2xhdGUgPyAndHJhbnNsYXRlJyA6ICd0cmFuc2NyaWJlJ1xyXG4gICAgICAgICAgICB3cy5zZW5kKFxyXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2s6IHRhc2tOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHVpZDogdWlkUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IGNvbmZpZy5sYW5ndWFnZSxcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbDogY29uZmlnLm1vZGVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZV92YWQ6IGNvbmZpZy52YWQsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBzZW5kIHVzIHRoZSBuZXdlc3Qgc2VnbWVudCBlYWNoIHRpbWU6XHJcbiAgICAgICAgICAgICAgICAgICAgc2VuZF9sYXN0X25fc2VnbWVudHM6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZV9yZWNvcmRpbmc6IGNvbmZpZy5zYXZlUmVjb3JkaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dF9maWxlbmFtZTogY29uZmlnLm91dHB1dEZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heF9jbGllbnRzOiBjb25maWcubWF4Q2xpZW50cyxcclxuICAgICAgICAgICAgICAgICAgICBtYXhfY29ubmVjdGlvbl90aW1lOiBjb25maWcubWF4Q29ubmVjdGlvblRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKippbXBvcnRhbnQqKjogbXVzdCBtYXRjaCB5b3VyIEF1ZGlvQ29udGV4dCAmIFNjcmlwdFByb2Nlc3NvclxyXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZV9yYXRlOiBzYW1wbGVSYXRlUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtfc2l6ZTogNDA5NixcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIHN0YXJ0VHJhbnNjcmlwdGlvbigpO1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGlzQ29ubmVjdGVkOiB0cnVlIH0pKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaW5zaWRlIHlvdXIgY29ubmVjdCgpXHJcbiAgICAgICAgd3Mub25tZXNzYWdlID0gZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSYXcgV1MgTWVzc2FnZTonLCBlLmRhdGEpXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZS5kYXRhICE9PSAnc3RyaW5nJykgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBtc2cgPSBKU09OLnBhcnNlKGUuZGF0YSk7XHJcblxyXG4gICAgICAgICAgICAvLyBpZ25vcmUgaGFuZHNoYWtlXHJcbiAgICAgICAgICAgIGlmIChtc2cubWVzc2FnZSA9PT0gJ1NFUlZFUl9SRUFEWScpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIGVycm9yc1xyXG4gICAgICAgICAgICBpZiAobXNnLnR5cGUgPT09ICdlcnJvcicpIHtcclxuICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgZXJyb3I6IG1zZy5tZXNzYWdlIH0pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gb2xk4oCQc3R5bGUgcGFydGlhbC9maW5hbCAoaWYgeW91IGV2ZXIgdG9nZ2xlIHRoYXQgYmFjayBvbilcclxuICAgICAgICAgICAgaWYgKG1zZy50eXBlID09PSAncGFydGlhbCcgfHwgbXNnLnR5cGUgPT09ICd0cmFuc2NyaXB0Jykge1xyXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUcmFuc2NyaWJpbmc6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjcmlwdDogcy50cmFuc2NyaXB0ICsgbXNnLnRleHRcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobXNnLnR5cGUgPT09ICdmaW5hbCcpIHtcclxuICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVHJhbnNjcmliaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NyaXB0OiBzLnRyYW5zY3JpcHQgKyBtc2cudGV4dCArICdcXG4nXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOKGkCBORVc6IGhhbmRsZSB0aGUgYHNlZ21lbnRzYCBhcnJheVxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtc2cuc2VnbWVudHMpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBqdXN0IGdyYWIgdGhlIHZlcnkgbGFzdCBzZWdtZW50IGFuZCBhcHBlbmQgaXRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBtc2cuc2VnbWVudHNbbXNnLnNlZ21lbnRzLmxlbmd0aCAtIDFdXHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucyxcclxuICAgICAgICAgICAgICAgICAgICBpc1RyYW5zY3JpYmluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NyaXB0OiBzLnRyYW5zY3JpcHQgKyBsYXN0LnRleHRcclxuICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBhbnkgc3RyYXkgYG1zZy5tZXNzYWdlYFxyXG4gICAgICAgICAgICBpZiAobXNnLm1lc3NhZ2UgJiYgbXNnLm1lc3NhZ2UgIT09ICdTRVJWRVJfUkVBRFknKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucyxcclxuICAgICAgICAgICAgICAgICAgICBpc1RyYW5zY3JpYmluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NyaXB0OiBzLnRyYW5zY3JpcHQgKyBtc2cubWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIHdzLm9uY2xvc2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNDb25uZWN0ZWQ6IGZhbHNlLCBpc1RyYW5zY3JpYmluZzogZmFsc2UgfSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3cy5vbmVycm9yID0gKGVycikgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t1c2VXaGlzcGVyTGl2ZV0gV2ViU29ja2V0IGVycm9yIChub27igJFmYXRhbCknLCBlcnIpO1xyXG4gICAgICAgICAgICAvLyBkb27igJl0IHNldFN0YXRlIG9yIHRvYXN0IGhlcmVcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2NvbmZpZywgdG9hc3RdKVxyXG5cclxuICAgIGNvbnN0IG1pY1JlZiA9IHVzZVJlZjxNZWRpYVN0cmVhbSB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCBzeXN0ZW1SZWYgPSB1c2VSZWY8TWVkaWFTdHJlYW0gfCBudWxsPihudWxsKVxyXG4gICAgY29uc3QgY3R4UmVmID0gdXNlUmVmPEF1ZGlvQ29udGV4dCB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCBwcm9jZXNzb3JSZWYgPSB1c2VSZWY8U2NyaXB0UHJvY2Vzc29yTm9kZSB8IG51bGw+KG51bGwpXHJcblxyXG4gICAgY29uc3Qgc3RhcnRUcmFuc2NyaXB0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGlmICghd3NSZWYuY3VycmVudCB8fCB3c1JlZi5jdXJyZW50LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgZXJyb3I6ICdOb3QgY29ubmVjdGVkJyB9KSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIDEpIFNjcmVlbiArIHN5c3RlbSBhdWRpbyAoaWYgZW5hYmxlZClcclxuICAgICAgICAgICAgbGV0IHN5c3RlbVN0cmVhbTogTWVkaWFTdHJlYW0gfCBudWxsID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5hdWRpb1NvdXJjZXM/LnN5c3RlbUF1ZGlvKSB7XHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1TdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlkZW86IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHN5c3RlbVJlZi5jdXJyZW50ID0gc3lzdGVtU3RyZWFtO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAyKSBNaWNyb3Bob25lXHJcbiAgICAgICAgICAgIGNvbnN0IG1pY1N0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcclxuICAgICAgICAgICAgICAgIGF1ZGlvOiB7IHNhbXBsZVJhdGU6IDE2MDAwLCBjaGFubmVsQ291bnQ6IDEgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1pY1JlZi5jdXJyZW50ID0gbWljU3RyZWFtO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGN0eFJlZi5jdXJyZW50IVxyXG4gICAgICAgICAgICBjb25zdCBkZXN0ID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKVxyXG5cclxuICAgICAgICAgICAgLy8gNCkgV2lyZSBtaWMg4oaSIGRlc3RcclxuICAgICAgICAgICAgY29uc3QgbWljU3JjID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG1pY1N0cmVhbSk7XHJcbiAgICAgICAgICAgIG1pY1NyYy5jb25uZWN0KGRlc3QpO1xyXG5cclxuICAgICAgICAgICAgLy8gNSkgV2lyZSBzeXN0ZW0gYXVkaW8g4oaSIGRlc3RcclxuICAgICAgICAgICAgaWYgKHN5c3RlbVN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3lzU3JjID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN5c3RlbVN0cmVhbSk7XHJcbiAgICAgICAgICAgICAgICBzeXNTcmMuY29ubmVjdChkZXN0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gNikgSW5zdGVhZCBvZiB3aXJpbmcgbWljK3N5cyBkaXJlY3RseSB0byB0aGUgcHJvY2Vzc29yLCB3ZVxyXG4gICAgICAgICAgICAvLyAgICB0YWtlIHRoZSBtaXhlZCBkZXN0LnN0cmVhbSBhbmQgaG9vayB0aGF0IHVwOlxyXG4gICAgICAgICAgICBjb25zdCBtaXhlZFNyYyA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShkZXN0LnN0cmVhbSk7XHJcblxyXG4gICAgICAgICAgICAvLyA3KSBDcmVhdGUgeW91ciBTY3JpcHRQcm9jZXNzb3IgKGJ1ZmZlclNpemU9NDA5NiwgbW9ubyBpbi9vdXQpXHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NvciA9IGN0eC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoNDA5NiwgMSwgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyA4KSBXaXJlIHRoZSBtaXhlZCBhdWRpbyBpbnRvIHRoZSBwcm9jZXNzb3JcclxuICAgICAgICAgICAgbWl4ZWRTcmMuY29ubmVjdChwcm9jZXNzb3IpO1xyXG5cclxuICAgICAgICAgICAgLy8gOSkgT24gZWFjaCBvbmF1ZGlvcHJvY2VzcywgYnVpbGQgZXhhY3RseSBvbmUgcGFja2V0XHJcbiAgICAgICAgICAgIHByb2Nlc3Nvci5vbmF1ZGlvcHJvY2VzcyA9IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmxvYXQzMiA9IGUuaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMClcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZsb2F0MzJCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGZsb2F0MzIpXHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnNhdmVSZWNvcmRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmRpbmdCdWZmZXJzLmN1cnJlbnQucHVzaChmbG9hdDMyQnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8g4oaSIGNvbnZlcnQgdG8gVWludDhBcnJheSBbMC4uMjU1XVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdWk4ID0gbmV3IFVpbnQ4QXJyYXkoZmxvYXQzMkJ1ZmZlci5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZsb2F0MzJCdWZmZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB1aThbaV0gPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgMjU1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgwLCBNYXRoLmZsb29yKChmbG9hdDMyQnVmZmVyW2ldICsgMSkgKiAxMjcuNSkpXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNlbmQgcmF3IGZsb2F0MzIgUENNIHRvIHNlcnZlclxyXG4gICAgICAgICAgICAgICAgaWYgKHdzUmVmLmN1cnJlbnQhLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd3NSZWYuY3VycmVudCEuc2VuZChmbG9hdDMyQnVmZmVyLmJ1ZmZlcilcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdmlzdWFsaXplclxyXG4gICAgICAgICAgICAgICAgc2V0QXVkaW9EYXRhKHVpOClcclxuICAgICAgICAgICAgICAgIHNldERhdGFVcGRhdGVUcmlnZ2VyKHQgPT4gdCArIDEpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDEwKSBTdGFydCBpdFxyXG4gICAgICAgICAgICBwcm9jZXNzb3IuY29ubmVjdChjdHguZGVzdGluYXRpb24pO1xyXG4gICAgICAgICAgICBwcm9jZXNzb3JSZWYuY3VycmVudCA9IHByb2Nlc3NvcjtcclxuXHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNUcmFuc2NyaWJpbmc6IHRydWUgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogYEZhaWxlZCB0byBzdGFydCB0cmFuc2NyaXB0aW9uOiAke2Vyci5tZXNzYWdlfWAgfSkpO1xyXG4gICAgICAgICAgICB0b2FzdCh7IHRpdGxlOiAnVHJhbnNjcmlwdGlvbiBFcnJvcicsIGRlc2NyaXB0aW9uOiBlcnIubWVzc2FnZSwgdmFyaWFudDogJ2Rlc3RydWN0aXZlJyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbY29uZmlnLCB0b2FzdF0pO1xyXG5cclxuXHJcbiAgICBjb25zdCBzdG9wVHJhbnNjcmlwdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAod3NSZWYuY3VycmVudD8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgLy8gemVyb+KAkWxlbmd0aCBBcnJheUJ1ZmZlciBzaWduYWxzIOKAnHBsZWFzZSBmbHVzaCAmIGZpbmlzaOKAnVxyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50LnNlbmQobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFwiRU5EX09GX0FVRElPXCIpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRlYXIgZG93biBhdWRpbyBncmFwaCBpbW1lZGlhdGVseVxyXG4gICAgICAgIGlmIChwcm9jZXNzb3JSZWYuY3VycmVudCkgeyBwcm9jZXNzb3JSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7IHByb2Nlc3NvclJlZi5jdXJyZW50ID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChtaWNSZWYuY3VycmVudCkgeyBtaWNSZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKHQgPT4gdC5zdG9wKCkpOyBtaWNSZWYuY3VycmVudCA9IG51bGw7IH1cclxuICAgICAgICBpZiAoc3lzdGVtUmVmLmN1cnJlbnQpIHsgc3lzdGVtUmVmLmN1cnJlbnQuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTsgc3lzdGVtUmVmLmN1cnJlbnQgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGN0eFJlZi5jdXJyZW50KSB7IGN0eFJlZi5jdXJyZW50LmNsb3NlKCk7IGN0eFJlZi5jdXJyZW50ID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChjb25maWcuc2F2ZVJlY29yZGluZyAmJiByZWNvcmRpbmdCdWZmZXJzLmN1cnJlbnQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIDEpIGNhcHR1cmUgcmF0ZSBiZWZvcmUgY2xvc2luZ1xyXG4gICAgICAgICAgICBjb25zdCBzYW1wbGVSYXRlID0gY3R4UmVmLmN1cnJlbnQhLnNhbXBsZVJhdGVcclxuXHJcbiAgICAgICAgICAgIC8vIDIpIGZsYXR0ZW4gYWxsIHlvdXIgRmxvYXQzMkFycmF5IGNodW5rcyBpbnRvIG9uZVxyXG4gICAgICAgICAgICBjb25zdCB0b3RhbExlbmd0aCA9IHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudC5yZWR1Y2UoKHN1bSwgYnVmKSA9PiBzdW0gKyBidWYubGVuZ3RoLCAwKVxyXG4gICAgICAgICAgICBjb25zdCBpbnRlcmxlYXZlZCA9IG5ldyBGbG9hdDMyQXJyYXkodG90YWxMZW5ndGgpXHJcbiAgICAgICAgICAgIGxldCBvZmYgPSAwXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYnVmIG9mIHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJsZWF2ZWQuc2V0KGJ1Ziwgb2ZmKVxyXG4gICAgICAgICAgICAgICAgb2ZmICs9IGJ1Zi5sZW5ndGhcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMykgZW5jb2RlICsgdXBsb2FkXHJcbiAgICAgICAgICAgIGNvbnN0IHdhdlZpZXcgPSBlbmNvZGVXQVYoaW50ZXJsZWF2ZWQsIHNhbXBsZVJhdGUpXHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbd2F2Vmlldy5idWZmZXJdLCB7IHR5cGU6ICdhdWRpby93YXYnIH0pXHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKVxyXG4gICAgICAgICAgICBmb3JtLmFwcGVuZCgnZmlsZScsIGJsb2IsIGNvbmZpZy5vdXRwdXRGaWxlbmFtZSB8fCAncmVjb3JkaW5nLndhdicpXHJcbiAgICAgICAgICAgIGZldGNoKCcvYXBpL3VwbG9hZCcsIHsgbWV0aG9kOiAnUE9TVCcsIGJvZHk6IGZvcm0gfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKHIgPT4gci5vayB8fCBQcm9taXNlLnJlamVjdCgndXBsb2FkIGZhaWxlZCcpKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB0b2FzdCh7IHRpdGxlOiAnVXBsb2FkIEVycm9yJywgZGVzY3JpcHRpb246IFN0cmluZyhlcnIpLCB2YXJpYW50OiAnZGVzdHJ1Y3RpdmUnIH0pKVxyXG5cclxuICAgICAgICAgICAgcmVjb3JkaW5nQnVmZmVycy5jdXJyZW50ID0gW11cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZmluYWxseSB0ZWFyIGRvd24geW91ciBBdWRpb0NvbnRleHRcclxuICAgICAgICBpZiAoY3R4UmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgY3R4UmVmLmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICAgICAgICBjdHhSZWYuY3VycmVudCA9IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBpc1RyYW5zY3JpYmluZzogZmFsc2UgfSkpO1xyXG5cclxuICAgIH0sIFtjb25maWcsIHRvYXN0XSlcclxuXHJcblxyXG5cclxuICAgIGNvbnN0IGRpc2Nvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKHdzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudC5jbG9zZSgpXHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3BUcmFuc2NyaXB0aW9uKClcclxuICAgICAgICBzZXRTdGF0ZSh7IGlzQ29ubmVjdGVkOiBmYWxzZSwgaXNUcmFuc2NyaWJpbmc6IGZhbHNlLCB0cmFuc2NyaXB0OiAnJywgZXJyb3I6IG51bGwgfSlcclxuICAgIH0sIFtzdG9wVHJhbnNjcmlwdGlvbl0pXHJcblxyXG4gICAgY29uc3QgY2xlYXJUcmFuc2NyaXB0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgdHJhbnNjcmlwdDogJycgfSkpXHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXRlLFxyXG4gICAgICAgIGNvbm5lY3QsXHJcbiAgICAgICAgc3RhcnRUcmFuc2NyaXB0aW9uLFxyXG4gICAgICAgIHN0b3BUcmFuc2NyaXB0aW9uLFxyXG4gICAgICAgIGRpc2Nvbm5lY3QsXHJcbiAgICAgICAgY2xlYXJUcmFuc2NyaXB0LFxyXG4gICAgICAgIHdzUmVmLFxyXG4gICAgICAgIGF1ZGlvRGF0YSxcclxuICAgICAgICBkYXRhVXBkYXRlVHJpZ2dlcixcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZVRvYXN0IiwiZW5jb2RlV0FWIiwic2FtcGxlcyIsInNhbXBsZVJhdGUiLCJiaXRzUGVyU2FtcGxlIiwiYnl0ZXNQZXJTYW1wbGUiLCJibG9ja0FsaWduIiwiYnl0ZVJhdGUiLCJkYXRhU2l6ZSIsImxlbmd0aCIsImJ1ZmZlciIsIkFycmF5QnVmZmVyIiwidmlldyIsIkRhdGFWaWV3Iiwid3JpdGVTdHJpbmciLCJzZXRVaW50MzIiLCJzZXRVaW50MTYiLCJvZmZzZXQiLCJpIiwicyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJzZXRJbnQxNiIsInNldFVpbnQ4IiwiY2hhckNvZGVBdCIsInVzZVdoaXNwZXJMaXZlIiwiY29uZmlnIiwic3RhdGUiLCJzZXRTdGF0ZSIsImlzQ29ubmVjdGVkIiwiaXNUcmFuc2NyaWJpbmciLCJ0cmFuc2NyaXB0IiwiZXJyb3IiLCJhdWRpb0RhdGEiLCJzZXRBdWRpb0RhdGEiLCJkYXRhVXBkYXRlVHJpZ2dlciIsInNldERhdGFVcGRhdGVUcmlnZ2VyIiwid3NSZWYiLCJyZWNvcmRpbmdCdWZmZXJzIiwic2FtcGxlUmF0ZVJlZiIsInVpZFJlZiIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwidG9hc3QiLCJjb25uZWN0IiwiY29uc29sZSIsImxvZyIsImN1cnJlbnQiLCJjbG9zZSIsImN0eCIsIkF1ZGlvQ29udGV4dCIsImN0eFJlZiIsInByb3RvY29sIiwid2luZG93IiwibG9jYXRpb24iLCJ3cyIsIldlYlNvY2tldCIsInNlcnZlclVybCIsInBvcnQiLCJiaW5hcnlUeXBlIiwib25vcGVuIiwidGFza05hbWUiLCJ0cmFuc2xhdGUiLCJzZW5kIiwiSlNPTiIsInN0cmluZ2lmeSIsInRhc2siLCJ1aWQiLCJsYW5ndWFnZSIsIm1vZGVsIiwidXNlX3ZhZCIsInZhZCIsInNlbmRfbGFzdF9uX3NlZ21lbnRzIiwic2F2ZV9yZWNvcmRpbmciLCJzYXZlUmVjb3JkaW5nIiwib3V0cHV0X2ZpbGVuYW1lIiwib3V0cHV0RmlsZW5hbWUiLCJtYXhfY2xpZW50cyIsIm1heENsaWVudHMiLCJtYXhfY29ubmVjdGlvbl90aW1lIiwibWF4Q29ubmVjdGlvblRpbWUiLCJzYW1wbGVfcmF0ZSIsImNodW5rX3NpemUiLCJzdGFydFRyYW5zY3JpcHRpb24iLCJvbm1lc3NhZ2UiLCJlIiwiZGF0YSIsIm1zZyIsInBhcnNlIiwibWVzc2FnZSIsInR5cGUiLCJ0ZXh0IiwiQXJyYXkiLCJpc0FycmF5Iiwic2VnbWVudHMiLCJsYXN0Iiwib25jbG9zZSIsIm9uZXJyb3IiLCJlcnIiLCJ3YXJuIiwibWljUmVmIiwic3lzdGVtUmVmIiwicHJvY2Vzc29yUmVmIiwicmVhZHlTdGF0ZSIsIk9QRU4iLCJzeXN0ZW1TdHJlYW0iLCJhdWRpb1NvdXJjZXMiLCJzeXN0ZW1BdWRpbyIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldERpc3BsYXlNZWRpYSIsInZpZGVvIiwiYXVkaW8iLCJtaWNTdHJlYW0iLCJnZXRVc2VyTWVkaWEiLCJjaGFubmVsQ291bnQiLCJkZXN0IiwiY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbiIsIm1pY1NyYyIsImNyZWF0ZU1lZGlhU3RyZWFtU291cmNlIiwic3lzU3JjIiwibWl4ZWRTcmMiLCJzdHJlYW0iLCJwcm9jZXNzb3IiLCJjcmVhdGVTY3JpcHRQcm9jZXNzb3IiLCJvbmF1ZGlvcHJvY2VzcyIsImZsb2F0MzIiLCJpbnB1dEJ1ZmZlciIsImdldENoYW5uZWxEYXRhIiwiZmxvYXQzMkJ1ZmZlciIsIkZsb2F0MzJBcnJheSIsInB1c2giLCJ1aTgiLCJVaW50OEFycmF5IiwiZmxvb3IiLCJ0IiwiZGVzdGluYXRpb24iLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwidmFyaWFudCIsInN0b3BUcmFuc2NyaXB0aW9uIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJkaXNjb25uZWN0IiwiZ2V0VHJhY2tzIiwiZm9yRWFjaCIsInN0b3AiLCJ0b3RhbExlbmd0aCIsInJlZHVjZSIsInN1bSIsImJ1ZiIsImludGVybGVhdmVkIiwib2ZmIiwic2V0Iiwid2F2VmlldyIsImJsb2IiLCJCbG9iIiwiZm9ybSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5IiwidGhlbiIsInIiLCJvayIsIlByb21pc2UiLCJyZWplY3QiLCJjYXRjaCIsIlN0cmluZyIsImNsZWFyVHJhbnNjcmlwdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-whisper-live.ts\n"));

/***/ })

});