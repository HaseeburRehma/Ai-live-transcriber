"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/notes/page",{

/***/ "(app-pages-browser)/./src/hooks/use-whisper-live.ts":
/*!***************************************!*\
  !*** ./src/hooks/use-whisper-live.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWhisperLive: () => (/* binding */ useWhisperLive)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/hooks/use-toast */ \"(app-pages-browser)/./src/hooks/use-toast.ts\");\n/* __next_internal_client_entry_do_not_use__ useWhisperLive auto */ \n\nfunction encodeWAV(samples, sampleRate) {\n    const bitsPerSample = 16;\n    const bytesPerSample = bitsPerSample / 8;\n    const blockAlign = bytesPerSample // mono\n    ;\n    const byteRate = sampleRate * blockAlign;\n    const dataSize = samples.length * bytesPerSample;\n    const buffer = new ArrayBuffer(44 + dataSize);\n    const view = new DataView(buffer);\n    /* RIFF identifier */ writeString(view, 0, 'RIFF');\n    /* file length minus first 8 bytes */ view.setUint32(4, 36 + dataSize, true);\n    /* WAVE type */ writeString(view, 8, 'WAVE');\n    /* fmt  chunk */ writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true) // chunk length\n    ;\n    view.setUint16(20, 1, true) // PCM\n    ;\n    view.setUint16(22, 1, true) // mono\n    ;\n    view.setUint32(24, sampleRate, true) // sampleRate\n    ;\n    view.setUint32(28, byteRate, true) // byteRate\n    ;\n    view.setUint16(32, blockAlign, true) // blockAlign\n    ;\n    view.setUint16(34, bitsPerSample, true) // bitsPerSample\n    ;\n    /* data chunk */ writeString(view, 36, 'data');\n    view.setUint32(40, dataSize, true);\n    // write PCM samples\n    let offset = 44;\n    for(let i = 0; i < samples.length; i++){\n        // clamp\n        const s = Math.max(-1, Math.min(1, samples[i]));\n        // scale to 16â€‘bit int\n        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n        offset += 2;\n    }\n    return view;\n}\nfunction writeString(view, offset, s) {\n    for(let i = 0; i < s.length; i++){\n        view.setUint8(offset + i, s.charCodeAt(i));\n    }\n}\nfunction useWhisperLive(config) {\n    let initialRecordings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    const [recordings, setRecordings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialRecordings);\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        isTranscribing: false,\n        transcript: '',\n        error: null,\n        segments: []\n    });\n    const [audioData, setAudioData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [dataUpdateTrigger, setDataUpdateTrigger] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const recordingBuffers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const sampleRateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const lastSegmentIndexRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const audioDataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const resetSegments = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[resetSegments]\": ()=>{\n            setState({\n                \"useWhisperLive.useCallback[resetSegments]\": (s)=>({\n                        ...s,\n                        segments: [],\n                        transcript: ''\n                    })\n            }[\"useWhisperLive.useCallback[resetSegments]\"]);\n        }\n    }[\"useWhisperLive.useCallback[resetSegments]\"], []);\n    const resetRecordings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[resetRecordings]\": ()=>{\n            setRecordings([]);\n        }\n    }[\"useWhisperLive.useCallback[resetRecordings]\"], []);\n    const uidRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));\n    const { toast } = (0,_hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__.useToast)();\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[connect]\": ()=>{\n            console.log('[useWhisperLive]  connect()', config);\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            // 1) create AudioContext now so we can hand its real sampleRate to the server\n            const ctx = new AudioContext({\n                sampleRate: 16000\n            });\n            ctxRef.current = ctx;\n            // immediately save out the sampleRate for later WAV encoding\n            sampleRateRef.current = ctx.sampleRate;\n            // clear out any old floats from a previous session\n            recordingBuffers.current = [];\n            console.log('[useWhisperLive] audioContext.sampleRate =', sampleRateRef.current);\n            setState({\n                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                        ...s,\n                        error: null\n                    })\n            }[\"useWhisperLive.useCallback[connect]\"]);\n            const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\n            // if the user typed â€œlocalhostâ€, swap to 127.0.0.1\n            const host = config.serverUrl === 'localhost' || config.serverUrl === '::1' ? '127.0.0.1' : config.serverUrl;\n            const ws = new WebSocket(\"\".concat(protocol, \"://\").concat(host, \":\").concat(config.port));\n            ws.binaryType = 'arraybuffer';\n            wsRef.current = ws;\n            lastSegmentIndexRef.current = 0;\n            ws.onopen = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    console.log('[useWhisperLive] ðŸŸ¢ WebSocket OPEN');\n                    const taskName = config.translate ? 'translate' : 'transcribe';\n                    ws.send(JSON.stringify({\n                        task: taskName,\n                        uid: uidRef.current,\n                        language: config.language,\n                        model: config.model,\n                        use_vad: false,\n                        stream: true,\n                        // only send us the newest segment each time:\n                        save_recording: config.saveRecording,\n                        output_filename: config.outputFilename,\n                        max_clients: config.maxClients,\n                        max_connection_time: config.maxConnectionTime,\n                        // **important**: must match your AudioContext & ScriptProcessor\n                        sample_rate: sampleRateRef.current,\n                        chunk_size: 4096\n                    }));\n                    startTranscription();\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: true\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            const clearAll = {\n                \"useWhisperLive.useCallback[connect].clearAll\": ()=>{\n                    recordingBuffers.current = [];\n                    setState({\n                        \"useWhisperLive.useCallback[connect].clearAll\": (s)=>({\n                                ...s,\n                                transcript: '',\n                                segments: []\n                            })\n                    }[\"useWhisperLive.useCallback[connect].clearAll\"]);\n                }\n            }[\"useWhisperLive.useCallback[connect].clearAll\"];\n            // inside your connect()\n            ws.onmessage = ({\n                \"useWhisperLive.useCallback[connect]\": (e)=>{\n                    console.log('Raw WS Message:', e.data);\n                    if (typeof e.data !== 'string') return;\n                    const msg = JSON.parse(e.data);\n                    // ignore handshake\n                    if (msg.message === 'SERVER_READY') return;\n                    // errors\n                    if (msg.type === 'error') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    error: msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // oldâ€style partial/final (if you ever toggle that back on)\n                    if (msg.type === 'partial' || msg.type === 'transcript') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + msg.text\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    if (msg.type === 'final') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: false,\n                                    transcript: s.transcript + msg.text + '\\n'\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // â† NEW: handle the `segments` array\n                    if (Array.isArray(msg.segments)) {\n                        // compute RMS over your latest audioData as before\n                        let rms = 0;\n                        if (audioDataRef.current) {\n                            const data = audioDataRef.current;\n                            let sum = 0;\n                            for (const x of data)sum += (x - 128) ** 2;\n                            rms = Math.sqrt(sum / data.length) / 128;\n                        }\n                        // *Always* map *all* segments the server just sent:\n                        const segments = msg.segments.map({\n                            \"useWhisperLive.useCallback[connect].segments\": (wsSeg)=>({\n                                    speaker: wsSeg.speaker === 0 ? 'mic' : 'speaker',\n                                    content: wsSeg.text,\n                                    volume: rms\n                                })\n                        }[\"useWhisperLive.useCallback[connect].segments\"]);\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    segments,\n                                    isTranscribing: true\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // fallback to any stray `msg.message`\n                    if (msg.message && msg.message !== 'SERVER_READY') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                    }\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onclose = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    // stopTranscription()\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: false,\n                                isTranscribing: false\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onerror = ({\n                \"useWhisperLive.useCallback[connect]\": (err)=>{\n                    console.warn('[useWhisperLive] WebSocket error (nonâ€‘fatal)', err);\n                // donâ€™t setState or toast here\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n        }\n    }[\"useWhisperLive.useCallback[connect]\"], [\n        config,\n        toast\n    ]);\n    const micRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const systemRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ctxRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const processorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const startTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[startTranscription]\": async ()=>{\n            if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: 'Not connected'\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                return;\n            }\n            try {\n                var _config_audioSources;\n                // 1) Screen + system audio (if enabled)\n                let systemStream = null;\n                if ((_config_audioSources = config.audioSources) === null || _config_audioSources === void 0 ? void 0 : _config_audioSources.systemAudio) {\n                    systemStream = await navigator.mediaDevices.getDisplayMedia({\n                        video: true,\n                        audio: true\n                    });\n                    systemRef.current = systemStream;\n                }\n                // 2) Microphone\n                const micStream = await navigator.mediaDevices.getUserMedia({\n                    audio: {\n                        sampleRate: 16000,\n                        channelCount: 1\n                    }\n                });\n                micRef.current = micStream;\n                const ctx = ctxRef.current;\n                const dest = ctx.createMediaStreamDestination();\n                // 4) Wire mic â†’ dest\n                const micSrc = ctx.createMediaStreamSource(micStream);\n                micSrc.connect(dest);\n                // 5) Wire system audio â†’ dest\n                if (systemStream) {\n                    const sysSrc = ctx.createMediaStreamSource(systemStream);\n                    sysSrc.connect(dest);\n                }\n                // 6) Instead of wiring mic+sys directly to the processor, we\n                //    take the mixed dest.stream and hook that up:\n                const mixedSrc = ctx.createMediaStreamSource(dest.stream);\n                // 7) Create your ScriptProcessor (bufferSize=4096, mono in/out)\n                const processor = ctx.createScriptProcessor(4096, 1, 1);\n                // 8) Wire the mixed audio into the processor\n                mixedSrc.connect(processor);\n                // 9) On each onaudioprocess, build exactly one packet\n                processor.onaudioprocess = ({\n                    \"useWhisperLive.useCallback[startTranscription]\": (e)=>{\n                        const float32 = e.inputBuffer.getChannelData(0);\n                        const float32Buffer = new Float32Array(float32);\n                        if (config.saveRecording) {\n                            recordingBuffers.current.push(float32Buffer);\n                        }\n                        // â†’ convert to Uint8Array [0..255]\n                        const ui8 = new Uint8Array(float32Buffer.length);\n                        for(let i = 0; i < float32Buffer.length; i++){\n                            ui8[i] = Math.min(255, Math.max(0, Math.floor((float32Buffer[i] + 1) * 127.5)));\n                        }\n                        // send raw float32 PCM to server\n                        if (wsRef.current.readyState === WebSocket.OPEN) {\n                            wsRef.current.send(float32Buffer.buffer);\n                        }\n                        // update visualizer\n                        setAudioData(ui8);\n                        setDataUpdateTrigger({\n                            \"useWhisperLive.useCallback[startTranscription]\": (t)=>t + 1\n                        }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                    }\n                })[\"useWhisperLive.useCallback[startTranscription]\"];\n                // 10) Start it\n                processor.connect(ctx.destination);\n                processorRef.current = processor;\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            isTranscribing: true\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n            } catch (err) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: \"Failed to start transcription: \".concat(err.message)\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                toast({\n                    title: 'Transcription Error',\n                    description: err.message,\n                    variant: 'destructive'\n                });\n            }\n        }\n    }[\"useWhisperLive.useCallback[startTranscription]\"], [\n        config,\n        toast\n    ]);\n    const stopTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[stopTranscription]\": async ()=>{\n            var _wsRef_current;\n            // 1) tell the server â€œEND_OF_AUDIOâ€\n            if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                wsRef.current.send(new TextEncoder().encode(\"END_OF_AUDIO\"));\n            }\n            // 2) immediately tear down the ScriptProcessor & tracks\n            if (processorRef.current) {\n                processorRef.current.disconnect();\n                processorRef.current = null;\n            }\n            if (micRef.current) {\n                micRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                micRef.current = null;\n            }\n            if (systemRef.current) {\n                systemRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                systemRef.current = null;\n            }\n            // 3) if weâ€™ve been saving, flatten + encode + upload while ctx is still open\n            if (config.saveRecording && recordingBuffers.current.length) {\n                console.log('[useWhisperLive] uploading WAV, buffers:', recordingBuffers.current.length);\n                // â—‰ use the saved sampleRate\n                const sampleRate = sampleRateRef.current;\n                // â—‰ flatten into one Float32Array\n                const totalLength = recordingBuffers.current.reduce({\n                    \"useWhisperLive.useCallback[stopTranscription].totalLength\": (sum, buf)=>sum + buf.length\n                }[\"useWhisperLive.useCallback[stopTranscription].totalLength\"], 0);\n                const interleaved = new Float32Array(totalLength);\n                let offset = 0;\n                for (const buf of recordingBuffers.current){\n                    interleaved.set(buf, offset);\n                    offset += buf.length;\n                }\n                // â—‰ encode + upload\n                const wavView = encodeWAV(interleaved, sampleRate);\n                const blob = new Blob([\n                    wavView.buffer\n                ], {\n                    type: 'audio/wav'\n                });\n                const form = new FormData();\n                form.append('file', blob, config.outputFilename || 'recording.wav');\n                try {\n                    const res = await fetch('/api/upload', {\n                        method: 'POST',\n                        body: form\n                    });\n                    if (!res.ok) throw new Error('upload failed');\n                    const { url } = await res.json();\n                    const rec = {\n                        id: Date.now().toString(),\n                        url,\n                        blob\n                    };\n                    setRecordings({\n                        \"useWhisperLive.useCallback[stopTranscription]\": (rs)=>[\n                                ...rs,\n                                rec\n                            ]\n                    }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                } catch (err) {\n                    toast({\n                        title: 'Upload Error',\n                        description: String(err),\n                        variant: 'destructive'\n                    });\n                }\n                recordingBuffers.current = [];\n            }\n            // 4) **now** tear down your AudioContext\n            if (ctxRef.current) {\n                ctxRef.current.close();\n                ctxRef.current = null;\n            }\n            // 5) finally, update state\n            setState({\n                \"useWhisperLive.useCallback[stopTranscription]\": (s)=>({\n                        ...s,\n                        isTranscribing: false\n                    })\n            }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n        }\n    }[\"useWhisperLive.useCallback[stopTranscription]\"], [\n        config,\n        toast\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[disconnect]\": ()=>{\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            stopTranscription();\n            setState({\n                \"useWhisperLive.useCallback[disconnect]\": (s)=>({\n                        ...s,\n                        isConnected: false,\n                        isTranscribing: false,\n                        transcript: '',\n                        error: null,\n                        segments: []\n                    })\n            }[\"useWhisperLive.useCallback[disconnect]\"]);\n        }\n    }[\"useWhisperLive.useCallback[disconnect]\"], [\n        stopTranscription\n    ]);\n    const clearTranscript = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[clearTranscript]\": ()=>{\n            setState({\n                \"useWhisperLive.useCallback[clearTranscript]\": (s)=>({\n                        ...s,\n                        transcript: ''\n                    })\n            }[\"useWhisperLive.useCallback[clearTranscript]\"]);\n        }\n    }[\"useWhisperLive.useCallback[clearTranscript]\"], []);\n    return {\n        state,\n        connect,\n        startTranscription,\n        stopTranscription,\n        disconnect,\n        clearTranscript,\n        wsRef,\n        audioData,\n        dataUpdateTrigger,\n        recordings,\n        resetSegments,\n        deleteRecording: (r)=>setRecordings((rs)=>rs.filter((x)=>x.id !== r.id)),\n        resetRecordings\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utd2hpc3Blci1saXZlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7b0VBRXFEO0FBQ1Q7QUE0QjVDLFNBQVNJLFVBQVVDLE9BQXFCLEVBQUVDLFVBQWtCO0lBQ3hELE1BQU1DLGdCQUFnQjtJQUN0QixNQUFNQyxpQkFBaUJELGdCQUFnQjtJQUN2QyxNQUFNRSxhQUFhRCxlQUFlLE9BQU87O0lBQ3pDLE1BQU1FLFdBQVdKLGFBQWFHO0lBQzlCLE1BQU1FLFdBQVdOLFFBQVFPLE1BQU0sR0FBR0o7SUFDbEMsTUFBTUssU0FBUyxJQUFJQyxZQUFZLEtBQUtIO0lBQ3BDLE1BQU1JLE9BQU8sSUFBSUMsU0FBU0g7SUFFMUIsbUJBQW1CLEdBQ25CSSxZQUFZRixNQUFNLEdBQUc7SUFDckIsbUNBQW1DLEdBQ25DQSxLQUFLRyxTQUFTLENBQUMsR0FBRyxLQUFLUCxVQUFVO0lBQ2pDLGFBQWEsR0FDYk0sWUFBWUYsTUFBTSxHQUFHO0lBQ3JCLGNBQWMsR0FDZEUsWUFBWUYsTUFBTSxJQUFJO0lBQ3RCQSxLQUFLRyxTQUFTLENBQUMsSUFBSSxJQUFJLE1BQXFCLGVBQWU7O0lBQzNESCxLQUFLSSxTQUFTLENBQUMsSUFBSSxHQUFHLE1BQXNCLE1BQU07O0lBQ2xESixLQUFLSSxTQUFTLENBQUMsSUFBSSxHQUFHLE1BQXNCLE9BQU87O0lBQ25ESixLQUFLRyxTQUFTLENBQUMsSUFBSVosWUFBWSxNQUFhLGFBQWE7O0lBQ3pEUyxLQUFLRyxTQUFTLENBQUMsSUFBSVIsVUFBVSxNQUFlLFdBQVc7O0lBQ3ZESyxLQUFLSSxTQUFTLENBQUMsSUFBSVYsWUFBWSxNQUFhLGFBQWE7O0lBQ3pETSxLQUFLSSxTQUFTLENBQUMsSUFBSVosZUFBZSxNQUFVLGdCQUFnQjs7SUFDNUQsY0FBYyxHQUNkVSxZQUFZRixNQUFNLElBQUk7SUFDdEJBLEtBQUtHLFNBQVMsQ0FBQyxJQUFJUCxVQUFVO0lBRTdCLG9CQUFvQjtJQUNwQixJQUFJ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QUFLTyxFQUFFUCxFQUFFO1FBQ25GMUk7SUFDSjtBQUNKIiwic291cmNlcyI6WyJFOlxcQWl2b2ljZXRvdGV4dFxcc3JjXFxob29rc1xcdXNlLXdoaXNwZXItbGl2ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IHVzZVRvYXN0IH0gZnJvbSAnQC9ob29rcy91c2UtdG9hc3QnXHJcbmltcG9ydCB0eXBlIHsgU2VnbWVudCB9IGZyb20gJ0AvdHlwZXMvdHJhbnNjcmlwdGlvbic7XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSZWNvcmRpbmcgeyBpZDogc3RyaW5nOyB1cmw6IHN0cmluZzsgYmxvYj86IEJsb2IgfVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2hpc3BlckxpdmVDb25maWcge1xyXG4gICAgc2VydmVyVXJsOiBzdHJpbmdcclxuICAgIHBvcnQ6IG51bWJlclxyXG4gICAgbGFuZ3VhZ2U6IHN0cmluZ1xyXG4gICAgdHJhbnNsYXRlOiBib29sZWFuXHJcbiAgICBtb2RlbDogc3RyaW5nXHJcbiAgICB2YWQ6IGJvb2xlYW5cclxuICAgIHNhdmVSZWNvcmRpbmc6IGJvb2xlYW5cclxuICAgIG91dHB1dEZpbGVuYW1lOiBzdHJpbmdcclxuICAgIG1heENsaWVudHM6IG51bWJlclxyXG4gICAgbWF4Q29ubmVjdGlvblRpbWU6IG51bWJlclxyXG4gICAgYXVkaW9Tb3VyY2VzPzogeyBtaWNyb3Bob25lOiBib29sZWFuOyBzeXN0ZW1BdWRpbzogYm9vbGVhbiB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBXaGlzcGVyTGl2ZVN0YXRlIHtcclxuICAgIGlzQ29ubmVjdGVkOiBib29sZWFuXHJcbiAgICBpc1RyYW5zY3JpYmluZzogYm9vbGVhblxyXG4gICAgdHJhbnNjcmlwdDogc3RyaW5nXHJcbiAgICBlcnJvcjogc3RyaW5nIHwgbnVsbFxyXG4gICAgc2VnbWVudHM6IFNlZ21lbnRbXTtcclxufVxyXG5mdW5jdGlvbiBlbmNvZGVXQVYoc2FtcGxlczogRmxvYXQzMkFycmF5LCBzYW1wbGVSYXRlOiBudW1iZXIpOiBEYXRhVmlldyB7XHJcbiAgICBjb25zdCBiaXRzUGVyU2FtcGxlID0gMTZcclxuICAgIGNvbnN0IGJ5dGVzUGVyU2FtcGxlID0gYml0c1BlclNhbXBsZSAvIDhcclxuICAgIGNvbnN0IGJsb2NrQWxpZ24gPSBieXRlc1BlclNhbXBsZSAvLyBtb25vXHJcbiAgICBjb25zdCBieXRlUmF0ZSA9IHNhbXBsZVJhdGUgKiBibG9ja0FsaWduXHJcbiAgICBjb25zdCBkYXRhU2l6ZSA9IHNhbXBsZXMubGVuZ3RoICogYnl0ZXNQZXJTYW1wbGVcclxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0NCArIGRhdGFTaXplKVxyXG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpXHJcblxyXG4gICAgLyogUklGRiBpZGVudGlmaWVyICovXHJcbiAgICB3cml0ZVN0cmluZyh2aWV3LCAwLCAnUklGRicpXHJcbiAgICAvKiBmaWxlIGxlbmd0aCBtaW51cyBmaXJzdCA4IGJ5dGVzICovXHJcbiAgICB2aWV3LnNldFVpbnQzMig0LCAzNiArIGRhdGFTaXplLCB0cnVlKVxyXG4gICAgLyogV0FWRSB0eXBlICovXHJcbiAgICB3cml0ZVN0cmluZyh2aWV3LCA4LCAnV0FWRScpXHJcbiAgICAvKiBmbXQgIGNodW5rICovXHJcbiAgICB3cml0ZVN0cmluZyh2aWV3LCAxMiwgJ2ZtdCAnKVxyXG4gICAgdmlldy5zZXRVaW50MzIoMTYsIDE2LCB0cnVlKSAgICAgICAgICAgICAgICAvLyBjaHVuayBsZW5ndGhcclxuICAgIHZpZXcuc2V0VWludDE2KDIwLCAxLCB0cnVlKSAgICAgICAgICAgICAgICAgLy8gUENNXHJcbiAgICB2aWV3LnNldFVpbnQxNigyMiwgMSwgdHJ1ZSkgICAgICAgICAgICAgICAgIC8vIG1vbm9cclxuICAgIHZpZXcuc2V0VWludDMyKDI0LCBzYW1wbGVSYXRlLCB0cnVlKSAgICAgICAgLy8gc2FtcGxlUmF0ZVxyXG4gICAgdmlldy5zZXRVaW50MzIoMjgsIGJ5dGVSYXRlLCB0cnVlKSAgICAgICAgICAvLyBieXRlUmF0ZVxyXG4gICAgdmlldy5zZXRVaW50MTYoMzIsIGJsb2NrQWxpZ24sIHRydWUpICAgICAgICAvLyBibG9ja0FsaWduXHJcbiAgICB2aWV3LnNldFVpbnQxNigzNCwgYml0c1BlclNhbXBsZSwgdHJ1ZSkgICAgIC8vIGJpdHNQZXJTYW1wbGVcclxuICAgIC8qIGRhdGEgY2h1bmsgKi9cclxuICAgIHdyaXRlU3RyaW5nKHZpZXcsIDM2LCAnZGF0YScpXHJcbiAgICB2aWV3LnNldFVpbnQzMig0MCwgZGF0YVNpemUsIHRydWUpXHJcblxyXG4gICAgLy8gd3JpdGUgUENNIHNhbXBsZXNcclxuICAgIGxldCBvZmZzZXQgPSA0NFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gY2xhbXBcclxuICAgICAgICBjb25zdCBzID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIHNhbXBsZXNbaV0pKVxyXG4gICAgICAgIC8vIHNjYWxlIHRvIDE24oCRYml0IGludFxyXG4gICAgICAgIHZpZXcuc2V0SW50MTYoXHJcbiAgICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICAgICAgcyA8IDAgPyBzICogMHg4MDAwIDogcyAqIDB4N0ZGRixcclxuICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgIClcclxuICAgICAgICBvZmZzZXQgKz0gMlxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2aWV3XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlU3RyaW5nKHZpZXc6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlciwgczogc3RyaW5nKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIGksIHMuY2hhckNvZGVBdChpKSlcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdXNlV2hpc3BlckxpdmUoY29uZmlnOiBXaGlzcGVyTGl2ZUNvbmZpZywgaW5pdGlhbFJlY29yZGluZ3M6IFJlY29yZGluZ1tdID0gW10pIHtcclxuICBjb25zdCBbcmVjb3JkaW5ncywgc2V0UmVjb3JkaW5nc10gPSB1c2VTdGF0ZTxSZWNvcmRpbmdbXT4oaW5pdGlhbFJlY29yZGluZ3MpXHJcblxyXG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxXaGlzcGVyTGl2ZVN0YXRlPih7XHJcbiAgICAgICAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzVHJhbnNjcmliaW5nOiBmYWxzZSxcclxuICAgICAgICB0cmFuc2NyaXB0OiAnJyxcclxuICAgICAgICBlcnJvcjogbnVsbCxcclxuICAgICAgICBzZWdtZW50czogW10sXHJcbiAgICB9KVxyXG4gICAgY29uc3QgW2F1ZGlvRGF0YSwgc2V0QXVkaW9EYXRhXSA9IHVzZVN0YXRlPFVpbnQ4QXJyYXkgfCBudWxsPihudWxsKVxyXG4gICAgY29uc3QgW2RhdGFVcGRhdGVUcmlnZ2VyLCBzZXREYXRhVXBkYXRlVHJpZ2dlcl0gPSB1c2VTdGF0ZSgwKVxyXG4gICAgY29uc3Qgd3NSZWYgPSB1c2VSZWY8V2ViU29ja2V0IHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IHJlY29yZGluZ0J1ZmZlcnMgPSB1c2VSZWY8RmxvYXQzMkFycmF5W10+KFtdKVxyXG4gICAgY29uc3Qgc2FtcGxlUmF0ZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApXHJcbiAgICBjb25zdCBsYXN0U2VnbWVudEluZGV4UmVmID0gdXNlUmVmKDApXHJcbiAgICBjb25zdCBhdWRpb0RhdGFSZWYgPSB1c2VSZWY8VWludDhBcnJheSB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgIGNvbnN0IHJlc2V0U2VnbWVudHMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBzZWdtZW50czogW10sIHRyYW5zY3JpcHQ6ICcnIH0pKTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHJlc2V0UmVjb3JkaW5ncyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRSZWNvcmRpbmdzKFtdKTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHVpZFJlZiA9IHVzZVJlZihcclxuICAgICAgICB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRFxyXG4gICAgICAgICAgICA/IGNyeXB0by5yYW5kb21VVUlEKClcclxuICAgICAgICAgICAgOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxcclxuICAgIClcclxuICAgIGNvbnN0IHsgdG9hc3QgfSA9IHVzZVRvYXN0KClcclxuXHJcbiAgICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbdXNlV2hpc3BlckxpdmVdICBjb25uZWN0KCknLCBjb25maWcpO1xyXG4gICAgICAgIGlmICh3c1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAxKSBjcmVhdGUgQXVkaW9Db250ZXh0IG5vdyBzbyB3ZSBjYW4gaGFuZCBpdHMgcmVhbCBzYW1wbGVSYXRlIHRvIHRoZSBzZXJ2ZXJcclxuICAgICAgICBjb25zdCBjdHggPSBuZXcgQXVkaW9Db250ZXh0KHsgc2FtcGxlUmF0ZTogMTYwMDAgfSlcclxuICAgICAgICBjdHhSZWYuY3VycmVudCA9IGN0eFxyXG5cclxuICAgICAgICAvLyBpbW1lZGlhdGVseSBzYXZlIG91dCB0aGUgc2FtcGxlUmF0ZSBmb3IgbGF0ZXIgV0FWIGVuY29kaW5nXHJcbiAgICAgICAgc2FtcGxlUmF0ZVJlZi5jdXJyZW50ID0gY3R4LnNhbXBsZVJhdGVcclxuXHJcbiAgICAgICAgLy8gY2xlYXIgb3V0IGFueSBvbGQgZmxvYXRzIGZyb20gYSBwcmV2aW91cyBzZXNzaW9uXHJcbiAgICAgICAgcmVjb3JkaW5nQnVmZmVycy5jdXJyZW50ID0gW11cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1t1c2VXaGlzcGVyTGl2ZV0gYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgPScsIHNhbXBsZVJhdGVSZWYuY3VycmVudClcclxuICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiBudWxsIH0pKVxyXG5cclxuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnd3NzJyA6ICd3cyc7XHJcblxyXG4vLyBpZiB0aGUgdXNlciB0eXBlZCDigJxsb2NhbGhvc3TigJ0sIHN3YXAgdG8gMTI3LjAuMC4xXHJcbmNvbnN0IGhvc3QgPVxyXG4gIGNvbmZpZy5zZXJ2ZXJVcmwgPT09ICdsb2NhbGhvc3QnIHx8IGNvbmZpZy5zZXJ2ZXJVcmwgPT09ICc6OjEnXHJcbiAgICA/ICcxMjcuMC4wLjEnXHJcbiAgICA6IGNvbmZpZy5zZXJ2ZXJVcmw7XHJcblxyXG5jb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQoYCR7cHJvdG9jb2x9Oi8vJHtob3N0fToke2NvbmZpZy5wb3J0fWApO1xyXG53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcclxud3NSZWYuY3VycmVudCA9IHdzO1xyXG5sYXN0U2VnbWVudEluZGV4UmVmLmN1cnJlbnQgPSAwO1xyXG5cclxuXHJcbiAgICAgICAgd3Mub25vcGVuID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZVdoaXNwZXJMaXZlXSDwn5+iIFdlYlNvY2tldCBPUEVOJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhc2tOYW1lID0gY29uZmlnLnRyYW5zbGF0ZSA/ICd0cmFuc2xhdGUnIDogJ3RyYW5zY3JpYmUnXHJcbiAgICAgICAgICAgIHdzLnNlbmQoXHJcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzazogdGFza05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWRSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZTogY29uZmlnLmxhbmd1YWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBjb25maWcubW9kZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlX3ZhZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgc2VuZCB1cyB0aGUgbmV3ZXN0IHNlZ21lbnQgZWFjaCB0aW1lOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzYXZlX3JlY29yZGluZzogY29uZmlnLnNhdmVSZWNvcmRpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0X2ZpbGVuYW1lOiBjb25maWcub3V0cHV0RmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4X2NsaWVudHM6IGNvbmZpZy5tYXhDbGllbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heF9jb25uZWN0aW9uX3RpbWU6IGNvbmZpZy5tYXhDb25uZWN0aW9uVGltZSxcclxuICAgICAgICAgICAgICAgICAgICAvLyAqKmltcG9ydGFudCoqOiBtdXN0IG1hdGNoIHlvdXIgQXVkaW9Db250ZXh0ICYgU2NyaXB0UHJvY2Vzc29yXHJcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlX3JhdGU6IHNhbXBsZVJhdGVSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgICAgICAgICBjaHVua19zaXplOiA0MDk2LFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgc3RhcnRUcmFuc2NyaXB0aW9uKCk7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNDb25uZWN0ZWQ6IHRydWUgfSkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNsZWFyQWxsID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZWNvcmRpbmdCdWZmZXJzLmN1cnJlbnQgPSBbXVxyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIHRyYW5zY3JpcHQ6ICcnLCBzZWdtZW50czogW10gfSkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluc2lkZSB5b3VyIGNvbm5lY3QoKVxyXG4gICAgICAgIHdzLm9ubWVzc2FnZSA9IGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmF3IFdTIE1lc3NhZ2U6JywgZS5kYXRhKVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGUuZGF0YSAhPT0gJ3N0cmluZycpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgbXNnID0gSlNPTi5wYXJzZShlLmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgLy8gaWdub3JlIGhhbmRzaGFrZVxyXG4gICAgICAgICAgICBpZiAobXNnLm1lc3NhZ2UgPT09ICdTRVJWRVJfUkVBRFknKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBlcnJvcnNcclxuICAgICAgICAgICAgaWYgKG1zZy50eXBlID09PSAnZXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiBtc2cubWVzc2FnZSB9KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIG9sZOKAkHN0eWxlIHBhcnRpYWwvZmluYWwgKGlmIHlvdSBldmVyIHRvZ2dsZSB0aGF0IGJhY2sgb24pXHJcbiAgICAgICAgICAgIGlmIChtc2cudHlwZSA9PT0gJ3BhcnRpYWwnIHx8IG1zZy50eXBlID09PSAndHJhbnNjcmlwdCcpIHtcclxuICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVHJhbnNjcmliaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY3JpcHQ6IHMudHJhbnNjcmlwdCArIG1zZy50ZXh0XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1zZy50eXBlID09PSAnZmluYWwnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucyxcclxuICAgICAgICAgICAgICAgICAgICBpc1RyYW5zY3JpYmluZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjcmlwdDogcy50cmFuc2NyaXB0ICsgbXNnLnRleHQgKyAnXFxuJ1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyDihpAgTkVXOiBoYW5kbGUgdGhlIGBzZWdtZW50c2AgYXJyYXlcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobXNnLnNlZ21lbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBSTVMgb3ZlciB5b3VyIGxhdGVzdCBhdWRpb0RhdGEgYXMgYmVmb3JlXHJcbiAgICAgICAgICAgICAgICBsZXQgcm1zID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChhdWRpb0RhdGFSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhdWRpb0RhdGFSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHggb2YgZGF0YSkgc3VtICs9ICh4IC0gMTI4KSAqKiAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJtcyA9IE1hdGguc3FydChzdW0gLyBkYXRhLmxlbmd0aCkgLyAxMjg7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gKkFsd2F5cyogbWFwICphbGwqIHNlZ21lbnRzIHRoZSBzZXJ2ZXIganVzdCBzZW50OlxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VnbWVudHM6IFNlZ21lbnRbXSA9IG1zZy5zZWdtZW50cy5tYXAod3NTZWcgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICBzcGVha2VyOiB3c1NlZy5zcGVha2VyID09PSAwID8gJ21pYycgOiAnc3BlYWtlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogd3NTZWcudGV4dCxcclxuICAgICAgICAgICAgICAgICAgICB2b2x1bWU6IHJtcyxcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucyxcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICBpc1RyYW5zY3JpYmluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIGFueSBzdHJheSBgbXNnLm1lc3NhZ2VgXHJcbiAgICAgICAgICAgIGlmIChtc2cubWVzc2FnZSAmJiBtc2cubWVzc2FnZSAhPT0gJ1NFUlZFUl9SRUFEWScpIHtcclxuICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVHJhbnNjcmliaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY3JpcHQ6IHMudHJhbnNjcmlwdCArIG1zZy5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgd3Mub25jbG9zZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gc3RvcFRyYW5zY3JpcHRpb24oKVxyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGlzQ29ubmVjdGVkOiBmYWxzZSwgaXNUcmFuc2NyaWJpbmc6IGZhbHNlIH0pKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd3Mub25lcnJvciA9IChlcnIpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbdXNlV2hpc3BlckxpdmVdIFdlYlNvY2tldCBlcnJvciAobm9u4oCRZmF0YWwpJywgZXJyKTtcclxuICAgICAgICAgICAgLy8gZG9u4oCZdCBzZXRTdGF0ZSBvciB0b2FzdCBoZXJlXHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtjb25maWcsIHRvYXN0XSlcclxuXHJcbiAgICBjb25zdCBtaWNSZWYgPSB1c2VSZWY8TWVkaWFTdHJlYW0gfCBudWxsPihudWxsKVxyXG4gICAgY29uc3Qgc3lzdGVtUmVmID0gdXNlUmVmPE1lZGlhU3RyZWFtIHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IGN0eFJlZiA9IHVzZVJlZjxBdWRpb0NvbnRleHQgfCBudWxsPihudWxsKVxyXG4gICAgY29uc3QgcHJvY2Vzc29yUmVmID0gdXNlUmVmPFNjcmlwdFByb2Nlc3Nvck5vZGUgfCBudWxsPihudWxsKVxyXG5cclxuICAgIGNvbnN0IHN0YXJ0VHJhbnNjcmlwdGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICBpZiAoIXdzUmVmLmN1cnJlbnQgfHwgd3NSZWYuY3VycmVudC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiAnTm90IGNvbm5lY3RlZCcgfSkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyAxKSBTY3JlZW4gKyBzeXN0ZW0gYXVkaW8gKGlmIGVuYWJsZWQpXHJcbiAgICAgICAgICAgIGxldCBzeXN0ZW1TdHJlYW06IE1lZGlhU3RyZWFtIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChjb25maWcuYXVkaW9Tb3VyY2VzPy5zeXN0ZW1BdWRpbykge1xyXG4gICAgICAgICAgICAgICAgc3lzdGVtU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoe1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1SZWYuY3VycmVudCA9IHN5c3RlbVN0cmVhbTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMikgTWljcm9waG9uZVxyXG4gICAgICAgICAgICBjb25zdCBtaWNTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XHJcbiAgICAgICAgICAgICAgICBhdWRpbzogeyBzYW1wbGVSYXRlOiAxNjAwMCwgY2hhbm5lbENvdW50OiAxIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtaWNSZWYuY3VycmVudCA9IG1pY1N0cmVhbTtcclxuXHJcblxyXG4gICAgICAgICAgICBjb25zdCBjdHggPSBjdHhSZWYuY3VycmVudCFcclxuICAgICAgICAgICAgY29uc3QgZGVzdCA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKClcclxuXHJcbiAgICAgICAgICAgIC8vIDQpIFdpcmUgbWljIOKGkiBkZXN0XHJcbiAgICAgICAgICAgIGNvbnN0IG1pY1NyYyA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShtaWNTdHJlYW0pO1xyXG4gICAgICAgICAgICBtaWNTcmMuY29ubmVjdChkZXN0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIDUpIFdpcmUgc3lzdGVtIGF1ZGlvIOKGkiBkZXN0XHJcbiAgICAgICAgICAgIGlmIChzeXN0ZW1TdHJlYW0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN5c1NyYyA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzeXN0ZW1TdHJlYW0pO1xyXG4gICAgICAgICAgICAgICAgc3lzU3JjLmNvbm5lY3QoZGVzdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDYpIEluc3RlYWQgb2Ygd2lyaW5nIG1pYytzeXMgZGlyZWN0bHkgdG8gdGhlIHByb2Nlc3Nvciwgd2VcclxuICAgICAgICAgICAgLy8gICAgdGFrZSB0aGUgbWl4ZWQgZGVzdC5zdHJlYW0gYW5kIGhvb2sgdGhhdCB1cDpcclxuICAgICAgICAgICAgY29uc3QgbWl4ZWRTcmMgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UoZGVzdC5zdHJlYW0pO1xyXG5cclxuICAgICAgICAgICAgLy8gNykgQ3JlYXRlIHlvdXIgU2NyaXB0UHJvY2Vzc29yIChidWZmZXJTaXplPTQwOTYsIG1vbm8gaW4vb3V0KVxyXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzb3IgPSBjdHguY3JlYXRlU2NyaXB0UHJvY2Vzc29yKDQwOTYsIDEsIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gOCkgV2lyZSB0aGUgbWl4ZWQgYXVkaW8gaW50byB0aGUgcHJvY2Vzc29yXHJcbiAgICAgICAgICAgIG1peGVkU3JjLmNvbm5lY3QocHJvY2Vzc29yKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDkpIE9uIGVhY2ggb25hdWRpb3Byb2Nlc3MsIGJ1aWxkIGV4YWN0bHkgb25lIHBhY2tldFxyXG4gICAgICAgICAgICBwcm9jZXNzb3Iub25hdWRpb3Byb2Nlc3MgPSBlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZsb2F0MzIgPSBlLmlucHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKDApXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmbG9hdDMyQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShmbG9hdDMyKVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5zYXZlUmVjb3JkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkaW5nQnVmZmVycy5jdXJyZW50LnB1c2goZmxvYXQzMkJ1ZmZlcilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIOKGkiBjb252ZXJ0IHRvIFVpbnQ4QXJyYXkgWzAuLjI1NV1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHVpOCA9IG5ldyBVaW50OEFycmF5KGZsb2F0MzJCdWZmZXIubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbG9hdDMyQnVmZmVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdWk4W2ldID0gTWF0aC5taW4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDI1NSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgTWF0aC5mbG9vcigoZmxvYXQzMkJ1ZmZlcltpXSArIDEpICogMTI3LjUpKVxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzZW5kIHJhdyBmbG9hdDMyIFBDTSB0byBzZXJ2ZXJcclxuICAgICAgICAgICAgICAgIGlmICh3c1JlZi5jdXJyZW50IS5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQhLnNlbmQoZmxvYXQzMkJ1ZmZlci5idWZmZXIpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHZpc3VhbGl6ZXJcclxuICAgICAgICAgICAgICAgIHNldEF1ZGlvRGF0YSh1aTgpXHJcbiAgICAgICAgICAgICAgICBzZXREYXRhVXBkYXRlVHJpZ2dlcih0ID0+IHQgKyAxKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAxMCkgU3RhcnQgaXRcclxuICAgICAgICAgICAgcHJvY2Vzc29yLmNvbm5lY3QoY3R4LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICAgICAgcHJvY2Vzc29yUmVmLmN1cnJlbnQgPSBwcm9jZXNzb3I7XHJcblxyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGlzVHJhbnNjcmliaW5nOiB0cnVlIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgZXJyb3I6IGBGYWlsZWQgdG8gc3RhcnQgdHJhbnNjcmlwdGlvbjogJHtlcnIubWVzc2FnZX1gIH0pKTtcclxuICAgICAgICAgICAgdG9hc3QoeyB0aXRsZTogJ1RyYW5zY3JpcHRpb24gRXJyb3InLCBkZXNjcmlwdGlvbjogZXJyLm1lc3NhZ2UsIHZhcmlhbnQ6ICdkZXN0cnVjdGl2ZScgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2NvbmZpZywgdG9hc3RdKTtcclxuXHJcblxyXG4gICAgY29uc3Qgc3RvcFRyYW5zY3JpcHRpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgLy8gMSkgdGVsbCB0aGUgc2VydmVyIOKAnEVORF9PRl9BVURJT+KAnVxyXG4gICAgICAgIGlmICh3c1JlZi5jdXJyZW50Py5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50LnNlbmQobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFwiRU5EX09GX0FVRElPXCIpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDIpIGltbWVkaWF0ZWx5IHRlYXIgZG93biB0aGUgU2NyaXB0UHJvY2Vzc29yICYgdHJhY2tzXHJcbiAgICAgICAgaWYgKHByb2Nlc3NvclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NvclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgcHJvY2Vzc29yUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWljUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgbWljUmVmLmN1cnJlbnQuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTtcclxuICAgICAgICAgICAgbWljUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3lzdGVtUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgc3lzdGVtUmVmLmN1cnJlbnQuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTtcclxuICAgICAgICAgICAgc3lzdGVtUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMykgaWYgd2XigJl2ZSBiZWVuIHNhdmluZywgZmxhdHRlbiArIGVuY29kZSArIHVwbG9hZCB3aGlsZSBjdHggaXMgc3RpbGwgb3BlblxyXG4gICAgICAgIGlmIChjb25maWcuc2F2ZVJlY29yZGluZyAmJiByZWNvcmRpbmdCdWZmZXJzLmN1cnJlbnQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbdXNlV2hpc3BlckxpdmVdIHVwbG9hZGluZyBXQVYsIGJ1ZmZlcnM6JywgcmVjb3JkaW5nQnVmZmVycy5jdXJyZW50Lmxlbmd0aClcclxuICAgICAgICAgICAgLy8g4peJIHVzZSB0aGUgc2F2ZWQgc2FtcGxlUmF0ZVxyXG4gICAgICAgICAgICBjb25zdCBzYW1wbGVSYXRlID0gc2FtcGxlUmF0ZVJlZi5jdXJyZW50O1xyXG5cclxuICAgICAgICAgICAgLy8g4peJIGZsYXR0ZW4gaW50byBvbmUgRmxvYXQzMkFycmF5XHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gcmVjb3JkaW5nQnVmZmVycy5jdXJyZW50LnJlZHVjZSgoc3VtLCBidWYpID0+IHN1bSArIGJ1Zi5sZW5ndGgsIDApO1xyXG4gICAgICAgICAgICBjb25zdCBpbnRlcmxlYXZlZCA9IG5ldyBGbG9hdDMyQXJyYXkodG90YWxMZW5ndGgpO1xyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBidWYgb2YgcmVjb3JkaW5nQnVmZmVycy5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlcmxlYXZlZC5zZXQoYnVmLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGJ1Zi5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOKXiSBlbmNvZGUgKyB1cGxvYWRcclxuICAgICAgICAgICAgY29uc3Qgd2F2VmlldyA9IGVuY29kZVdBVihpbnRlcmxlYXZlZCwgc2FtcGxlUmF0ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbd2F2Vmlldy5idWZmZXJdLCB7IHR5cGU6ICdhdWRpby93YXYnIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XHJcbiAgICAgICAgICAgIGZvcm0uYXBwZW5kKCdmaWxlJywgYmxvYiwgY29uZmlnLm91dHB1dEZpbGVuYW1lIHx8ICdyZWNvcmRpbmcud2F2Jyk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS91cGxvYWQnLCB7IG1ldGhvZDogJ1BPU1QnLCBib2R5OiBmb3JtIH0pXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCd1cGxvYWQgZmFpbGVkJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsIH0gPSBhd2FpdCByZXMuanNvbigpXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWM6IFJlY29yZGluZyA9IHsgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSwgdXJsLCBibG9iIH1cclxuICAgICAgICAgICAgICAgIHNldFJlY29yZGluZ3MocnMgPT4gWy4uLnJzLCByZWNdKVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICAgICAgICAgICAgdG9hc3QoeyB0aXRsZTogJ1VwbG9hZCBFcnJvcicsIGRlc2NyaXB0aW9uOiBTdHJpbmcoZXJyKSwgdmFyaWFudDogJ2Rlc3RydWN0aXZlJyB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudCA9IFtdXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA0KSAqKm5vdyoqIHRlYXIgZG93biB5b3VyIEF1ZGlvQ29udGV4dFxyXG4gICAgICAgIGlmIChjdHhSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBjdHhSZWYuY3VycmVudC5jbG9zZSgpO1xyXG4gICAgICAgICAgICBjdHhSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA1KSBmaW5hbGx5LCB1cGRhdGUgc3RhdGVcclxuICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGlzVHJhbnNjcmliaW5nOiBmYWxzZSB9KSk7XHJcbiAgICB9LCBbY29uZmlnLCB0b2FzdF0pO1xyXG5cclxuXHJcblxyXG5cclxuICAgIGNvbnN0IGRpc2Nvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKHdzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudC5jbG9zZSgpXHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3BUcmFuc2NyaXB0aW9uKClcclxuICAgICAgICBzZXRTdGF0ZShzID0+ICh7XHJcbiAgICAgICAgICAgIC4uLnMsXHJcbiAgICAgICAgICAgIGlzQ29ubmVjdGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNUcmFuc2NyaWJpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICB0cmFuc2NyaXB0OiAnJyxcclxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICAgICAgICAgIHNlZ21lbnRzOiBbXSwgICAgLy8gY2xlYXIgb3V0IGFueSBvbGQgZGlhcml6ZWQgc2VnbWVudHMgdG9vXHJcbiAgICAgICAgfSkpXHJcbiAgICB9LCBbc3RvcFRyYW5zY3JpcHRpb25dKVxyXG5cclxuICAgIGNvbnN0IGNsZWFyVHJhbnNjcmlwdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIHRyYW5zY3JpcHQ6ICcnIH0pKVxyXG4gICAgfSwgW10pXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0ZSxcclxuICAgICAgICBjb25uZWN0LFxyXG4gICAgICAgIHN0YXJ0VHJhbnNjcmlwdGlvbixcclxuICAgICAgICBzdG9wVHJhbnNjcmlwdGlvbixcclxuICAgICAgICBkaXNjb25uZWN0LFxyXG4gICAgICAgIGNsZWFyVHJhbnNjcmlwdCxcclxuICAgICAgICB3c1JlZixcclxuICAgICAgICBhdWRpb0RhdGEsXHJcbiAgICAgICAgZGF0YVVwZGF0ZVRyaWdnZXIsXHJcbiAgICAgICAgcmVjb3JkaW5ncyxcclxuICAgICAgICByZXNldFNlZ21lbnRzLFxyXG4gICAgICAgIGRlbGV0ZVJlY29yZGluZzogKHI6IFJlY29yZGluZykgPT4gc2V0UmVjb3JkaW5ncyhycyA9PiBycy5maWx0ZXIoeCA9PiB4LmlkICE9PSByLmlkKSksXHJcbiAgICAgICAgcmVzZXRSZWNvcmRpbmdzLFxyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwidXNlVG9hc3QiLCJlbmNvZGVXQVYiLCJzYW1wbGVzIiwic2FtcGxlUmF0ZSIsImJpdHNQZXJTYW1wbGUiLCJieXRlc1BlclNhbXBsZSIsImJsb2NrQWxpZ24iLCJieXRlUmF0ZSIsImRhdGFTaXplIiwibGVuZ3RoIiwiYnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJ2aWV3IiwiRGF0YVZpZXciLCJ3cml0ZVN0cmluZyIsInNldFVpbnQzMiIsInNldFVpbnQxNiIsIm9mZnNldCIsImkiLCJzIiwiTWF0aCIsIm1heCIsIm1pbiIsInNldEludDE2Iiwic2V0VWludDgiLCJjaGFyQ29kZUF0IiwidXNlV2hpc3BlckxpdmUiLCJjb25maWciLCJpbml0aWFsUmVjb3JkaW5ncyIsInJlY29yZGluZ3MiLCJzZXRSZWNvcmRpbmdzIiwic3RhdGUiLCJzZXRTdGF0ZSIsImlzQ29ubmVjdGVkIiwiaXNUcmFuc2NyaWJpbmciLCJ0cmFuc2NyaXB0IiwiZXJyb3IiLCJzZWdtZW50cyIsImF1ZGlvRGF0YSIsInNldEF1ZGlvRGF0YSIsImRhdGFVcGRhdGVUcmlnZ2VyIiwic2V0RGF0YVVwZGF0ZVRyaWdnZXIiLCJ3c1JlZiIsInJlY29yZGluZ0J1ZmZlcnMiLCJzYW1wbGVSYXRlUmVmIiwibGFzdFNlZ21lbnRJbmRleFJlZiIsImF1ZGlvRGF0YVJlZiIsInJlc2V0U2VnbWVudHMiLCJyZXNldFJlY29yZGluZ3MiLCJ1aWRSZWYiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsInRvYXN0IiwiY29ubmVjdCIsImNvbnNvbGUiLCJsb2ciLCJjdXJyZW50IiwiY2xvc2UiLCJjdHgiLCJBdWRpb0NvbnRleHQiLCJjdHhSZWYiLCJwcm90b2NvbCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaG9zdCIsInNlcnZlclVybCIsIndzIiwiV2ViU29ja2V0IiwicG9ydCIsImJpbmFyeVR5cGUiLCJvbm9wZW4iLCJ0YXNrTmFtZSIsInRyYW5zbGF0ZSIsInNlbmQiLCJKU09OIiwic3RyaW5naWZ5IiwidGFzayIsInVpZCIsImxhbmd1YWdlIiwibW9kZWwiLCJ1c2VfdmFkIiwic3RyZWFtIiwic2F2ZV9yZWNvcmRpbmciLCJzYXZlUmVjb3JkaW5nIiwib3V0cHV0X2ZpbGVuYW1lIiwib3V0cHV0RmlsZW5hbWUiLCJtYXhfY2xpZW50cyIsIm1heENsaWVudHMiLCJtYXhfY29ubmVjdGlvbl90aW1lIiwibWF4Q29ubmVjdGlvblRpbWUiLCJzYW1wbGVfcmF0ZSIsImNodW5rX3NpemUiLCJzdGFydFRyYW5zY3JpcHRpb24iLCJjbGVhckFsbCIsIm9ubWVzc2FnZSIsImUiLCJkYXRhIiwibXNnIiwicGFyc2UiLCJtZXNzYWdlIiwidHlwZSIsInRleHQiLCJBcnJheSIsImlzQXJyYXkiLCJybXMiLCJzdW0iLCJ4Iiwic3FydCIsIm1hcCIsIndzU2VnIiwic3BlYWtlciIsImNvbnRlbnQiLCJ2b2x1bWUiLCJvbmNsb3NlIiwib25lcnJvciIsImVyciIsIndhcm4iLCJtaWNSZWYiLCJzeXN0ZW1SZWYiLCJwcm9jZXNzb3JSZWYiLCJyZWFkeVN0YXRlIiwiT1BFTiIsInN5c3RlbVN0cmVhbSIsImF1ZGlvU291cmNlcyIsInN5c3RlbUF1ZGlvIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0RGlzcGxheU1lZGlhIiwidmlkZW8iLCJhdWRpbyIsIm1pY1N0cmVhbSIsImdldFVzZXJNZWRpYSIsImNoYW5uZWxDb3VudCIsImRlc3QiLCJjcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uIiwibWljU3JjIiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJzeXNTcmMiLCJtaXhlZFNyYyIsInByb2Nlc3NvciIsImNyZWF0ZVNjcmlwdFByb2Nlc3NvciIsIm9uYXVkaW9wcm9jZXNzIiwiZmxvYXQzMiIsImlucHV0QnVmZmVyIiwiZ2V0Q2hhbm5lbERhdGEiLCJmbG9hdDMyQnVmZmVyIiwiRmxvYXQzMkFycmF5IiwicHVzaCIsInVpOCIsIlVpbnQ4QXJyYXkiLCJmbG9vciIsInQiLCJkZXN0aW5hdGlvbiIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJ2YXJpYW50Iiwic3RvcFRyYW5zY3JpcHRpb24iLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImRpc2Nvbm5lY3QiLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwic3RvcCIsInRvdGFsTGVuZ3RoIiwicmVkdWNlIiwiYnVmIiwiaW50ZXJsZWF2ZWQiLCJzZXQiLCJ3YXZWaWV3IiwiYmxvYiIsIkJsb2IiLCJmb3JtIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJyZXMiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJvayIsIkVycm9yIiwidXJsIiwianNvbiIsInJlYyIsImlkIiwiRGF0ZSIsIm5vdyIsInJzIiwiU3RyaW5nIiwiY2xlYXJUcmFuc2NyaXB0IiwiZGVsZXRlUmVjb3JkaW5nIiwiciIsImZpbHRlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-whisper-live.ts\n"));

/***/ })

});