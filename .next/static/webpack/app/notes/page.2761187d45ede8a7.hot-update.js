"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/notes/page",{

/***/ "(app-pages-browser)/./src/hooks/use-whisper-live.ts":
/*!***************************************!*\
  !*** ./src/hooks/use-whisper-live.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWhisperLive: () => (/* binding */ useWhisperLive)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/hooks/use-toast */ \"(app-pages-browser)/./src/hooks/use-toast.ts\");\n/* __next_internal_client_entry_do_not_use__ useWhisperLive auto */ \n\nfunction encodeWAV(samples, sampleRate) {\n    const bitsPerSample = 16;\n    const bytesPerSample = bitsPerSample / 8;\n    const blockAlign = bytesPerSample // mono\n    ;\n    const byteRate = sampleRate * blockAlign;\n    const dataSize = samples.length * bytesPerSample;\n    const buffer = new ArrayBuffer(44 + dataSize);\n    const view = new DataView(buffer);\n    /* RIFF identifier */ writeString(view, 0, 'RIFF');\n    /* file length minus first 8 bytes */ view.setUint32(4, 36 + dataSize, true);\n    /* WAVE type */ writeString(view, 8, 'WAVE');\n    /* fmt  chunk */ writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true) // chunk length\n    ;\n    view.setUint16(20, 1, true) // PCM\n    ;\n    view.setUint16(22, 1, true) // mono\n    ;\n    view.setUint32(24, sampleRate, true) // sampleRate\n    ;\n    view.setUint32(28, byteRate, true) // byteRate\n    ;\n    view.setUint16(32, blockAlign, true) // blockAlign\n    ;\n    view.setUint16(34, bitsPerSample, true) // bitsPerSample\n    ;\n    /* data chunk */ writeString(view, 36, 'data');\n    view.setUint32(40, dataSize, true);\n    // write PCM samples\n    let offset = 44;\n    for(let i = 0; i < samples.length; i++){\n        // clamp\n        const s = Math.max(-1, Math.min(1, samples[i]));\n        // scale to 16‑bit int\n        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n        offset += 2;\n    }\n    return view;\n}\nfunction writeString(view, offset, s) {\n    for(let i = 0; i < s.length; i++){\n        view.setUint8(offset + i, s.charCodeAt(i));\n    }\n}\nfunction useWhisperLive(config) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        isTranscribing: false,\n        transcript: '',\n        error: null\n    });\n    const [audioData, setAudioData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [dataUpdateTrigger, setDataUpdateTrigger] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const recordingBuffers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const uidRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));\n    const { toast } = (0,_hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__.useToast)();\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[connect]\": ()=>{\n            console.log('[useWhisperLive]  connect()', config);\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            // 1) create AudioContext now so we can hand its real sampleRate to the server\n            const ctx = new AudioContext({\n                sampleRate: 16000\n            });\n            ctxRef.current = ctx;\n            const actualSampleRate = ctx.sampleRate;\n            console.log('[useWhisperLive] audioContext.sampleRate =', actualSampleRate);\n            setState({\n                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                        ...s,\n                        error: null\n                    })\n            }[\"useWhisperLive.useCallback[connect]\"]);\n            const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\n            const ws = new WebSocket(\"\".concat(protocol, \"://\").concat(config.serverUrl, \":\").concat(config.port));\n            ws.binaryType = 'arraybuffer';\n            wsRef.current = ws;\n            ws.onopen = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    console.log('[useWhisperLive] 🟢 WebSocket OPEN');\n                    const taskName = config.translate ? 'translate' : 'transcribe';\n                    ws.send(JSON.stringify({\n                        task: taskName,\n                        uid: uidRef.current,\n                        language: config.language,\n                        model: config.model,\n                        use_vad: config.vad,\n                        // only send us the newest segment each time:\n                        send_last_n_segments: 1,\n                        save_recording: config.saveRecording,\n                        output_filename: config.outputFilename,\n                        max_clients: config.maxClients,\n                        max_connection_time: config.maxConnectionTime,\n                        // **important**: must match your AudioContext & ScriptProcessor\n                        sample_rate: actualSampleRate,\n                        chunk_size: 4096\n                    }));\n                    startTranscription();\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: true\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            // inside your connect()\n            ws.onmessage = ({\n                \"useWhisperLive.useCallback[connect]\": (e)=>{\n                    console.log('Raw WS Message:', e.data);\n                    if (typeof e.data !== 'string') return;\n                    const msg = JSON.parse(e.data);\n                    // ignore handshake\n                    if (msg.message === 'SERVER_READY') return;\n                    // errors\n                    if (msg.type === 'error') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    error: msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // old‐style partial/final (if you ever toggle that back on)\n                    if (msg.type === 'partial' || msg.type === 'transcript') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + msg.text\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    if (msg.type === 'final') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: false,\n                                    transcript: s.transcript + msg.text + '\\n'\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // ← NEW: handle the `segments` array\n                    if (Array.isArray(msg.segments)) {\n                        // just grab the very last segment and append it\n                        const last = msg.segments[msg.segments.length - 1];\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + last.text\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // fallback to any stray `msg.message`\n                    if (msg.message && msg.message !== 'SERVER_READY') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                    }\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onclose = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: false,\n                                isTranscribing: false\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onerror = ({\n                \"useWhisperLive.useCallback[connect]\": (err)=>{\n                    console.warn('[useWhisperLive] WebSocket error (non‑fatal)', err);\n                // don’t setState or toast here\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n        }\n    }[\"useWhisperLive.useCallback[connect]\"], [\n        config,\n        toast\n    ]);\n    const micRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const systemRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ctxRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const processorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const startTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[startTranscription]\": async ()=>{\n            if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: 'Not connected'\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                return;\n            }\n            try {\n                var _config_audioSources;\n                // 1) Screen + system audio (if enabled)\n                let systemStream = null;\n                if ((_config_audioSources = config.audioSources) === null || _config_audioSources === void 0 ? void 0 : _config_audioSources.systemAudio) {\n                    systemStream = await navigator.mediaDevices.getDisplayMedia({\n                        video: true,\n                        audio: true\n                    });\n                    systemRef.current = systemStream;\n                }\n                // 2) Microphone\n                const micStream = await navigator.mediaDevices.getUserMedia({\n                    audio: {\n                        sampleRate: 16000,\n                        channelCount: 1\n                    }\n                });\n                micRef.current = micStream;\n                const ctx = ctxRef.current;\n                const dest = ctx.createMediaStreamDestination();\n                // 4) Wire mic → dest\n                const micSrc = ctx.createMediaStreamSource(micStream);\n                micSrc.connect(dest);\n                // 5) Wire system audio → dest\n                if (systemStream) {\n                    const sysSrc = ctx.createMediaStreamSource(systemStream);\n                    sysSrc.connect(dest);\n                }\n                // 6) Instead of wiring mic+sys directly to the processor, we\n                //    take the mixed dest.stream and hook that up:\n                const mixedSrc = ctx.createMediaStreamSource(dest.stream);\n                // 7) Create your ScriptProcessor (bufferSize=4096, mono in/out)\n                const processor = ctx.createScriptProcessor(4096, 1, 1);\n                // 8) Wire the mixed audio into the processor\n                mixedSrc.connect(processor);\n                // 9) On each onaudioprocess, build exactly one packet\n                processor.onaudioprocess = ({\n                    \"useWhisperLive.useCallback[startTranscription]\": (e)=>{\n                        const float32 = e.inputBuffer.getChannelData(0);\n                        const float32Buffer = new Float32Array(float32);\n                        if (config.saveRecording) {\n                            recordingBuffers.current.push(float32Buffer);\n                        }\n                        // → convert to Uint8Array [0..255]\n                        const ui8 = new Uint8Array(float32Buffer.length);\n                        for(let i = 0; i < float32Buffer.length; i++){\n                            ui8[i] = Math.min(255, Math.max(0, Math.floor((float32Buffer[i] + 1) * 127.5)));\n                        }\n                        // send raw float32 PCM to server\n                        if (wsRef.current.readyState === WebSocket.OPEN) {\n                            wsRef.current.send(float32Buffer.buffer);\n                        }\n                        // update visualizer\n                        setAudioData(ui8);\n                        setDataUpdateTrigger({\n                            \"useWhisperLive.useCallback[startTranscription]\": (t)=>t + 1\n                        }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                    }\n                })[\"useWhisperLive.useCallback[startTranscription]\"];\n                // 10) Start it\n                processor.connect(ctx.destination);\n                processorRef.current = processor;\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            isTranscribing: true\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n            } catch (err) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: \"Failed to start transcription: \".concat(err.message)\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                toast({\n                    title: 'Transcription Error',\n                    description: err.message,\n                    variant: 'destructive'\n                });\n            }\n        }\n    }[\"useWhisperLive.useCallback[startTranscription]\"], [\n        config,\n        toast\n    ]);\n    const stopTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[stopTranscription]\": ()=>{\n            var _wsRef_current;\n            if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                // zero‑length ArrayBuffer signals “please flush & finish”\n                wsRef.current.send(new TextEncoder().encode(\"END_OF_AUDIO\"));\n            }\n            // tear down audio graph immediately\n            if (processorRef.current) {\n                processorRef.current.disconnect();\n                processorRef.current = null;\n            }\n            if (micRef.current) {\n                micRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                micRef.current = null;\n            }\n            if (systemRef.current) {\n                systemRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                systemRef.current = null;\n            }\n            if (ctxRef.current) {\n                ctxRef.current.close();\n                ctxRef.current = null;\n            }\n            if (config.saveRecording && recordingBuffers.current.length) {\n                const totalLength = recordingBuffers.current.reduce({\n                    \"useWhisperLive.useCallback[stopTranscription].totalLength\": (sum, buf)=>sum + buf.length\n                }[\"useWhisperLive.useCallback[stopTranscription].totalLength\"], 0);\n                const interleaved = new Float32Array(totalLength);\n                let offset = 0;\n                for (const buf of recordingBuffers.current){\n                    interleaved.set(buf, offset);\n                    offset += buf.length;\n                }\n                // build a WAV header + data view (44‑byte PCM16 WAV)\n                const wavBuffer = encodeWAV(interleaved, ctxRef.current.sampleRate);\n                const blob = new Blob([\n                    wavBuffer\n                ], {\n                    type: 'audio/wav'\n                });\n                const form = new FormData();\n                form.append('file', blob, config.outputFilename || 'recording.wav');\n                fetch('/api/upload', {\n                    method: 'POST',\n                    body: form\n                }).then({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (r)=>r.ok || Promise.reject('upload failed')\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]).catch({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (err)=>toast({\n                            title: 'Upload Error',\n                            description: String(err),\n                            variant: 'destructive'\n                        })\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                recordingBuffers.current = [];\n            }\n            setState({\n                \"useWhisperLive.useCallback[stopTranscription]\": (s)=>({\n                        ...s,\n                        isTranscribing: false\n                    })\n            }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n        }\n    }[\"useWhisperLive.useCallback[stopTranscription]\"], [\n        config,\n        toast\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[disconnect]\": ()=>{\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            stopTranscription();\n            setState({\n                isConnected: false,\n                isTranscribing: false,\n                transcript: '',\n                error: null\n            });\n        }\n    }[\"useWhisperLive.useCallback[disconnect]\"], [\n        stopTranscription\n    ]);\n    const clearTranscript = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[clearTranscript]\": ()=>{\n            setState({\n                \"useWhisperLive.useCallback[clearTranscript]\": (s)=>({\n                        ...s,\n                        transcript: ''\n                    })\n            }[\"useWhisperLive.useCallback[clearTranscript]\"]);\n        }\n    }[\"useWhisperLive.useCallback[clearTranscript]\"], []);\n    return {\n        state,\n        connect,\n        startTranscription,\n        stopTranscription,\n        disconnect,\n        clearTranscript,\n        wsRef,\n        audioData,\n        dataUpdateTrigger\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utd2hpc3Blci1saXZlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7b0VBRXFEO0FBQ1Q7QUFzQjVDLFNBQVNJLFVBQVVDLE9BQXFCLEVBQUVDLFVBQWtCO0lBQzFELE1BQU1DLGdCQUFnQjtJQUN0QixNQUFNQyxpQkFBaUJELGdCQUFnQjtJQUN2QyxNQUFNRSxhQUFhRCxlQUFlLE9BQU87O0lBQ3pDLE1BQU1FLFdBQVdKLGFBQWFHO0lBQzlCLE1BQU1FLFdBQVdOLFFBQVFPLE1BQU0sR0FBR0o7SUFDbEMsTUFBTUssU0FBUyxJQUFJQyxZQUFZLEtBQUtIO0lBQ3BDLE1BQU1JLE9BQU8sSUFBSUMsU0FBU0g7SUFFMUIsbUJBQW1CLEdBQ25CSSxZQUFZRixNQUFNLEdBQUc7SUFDckIsbUNBQW1DLEdBQ25DQSxLQUFLRyxTQUFTLENBQUMsR0FBRyxLQUFLUCxVQUFVO0lBQ2pDLGFBQWEsR0FDYk0sWUFBWUYsTUFBTSxHQUFHO0lBQ3JCLGNBQWMsR0FDZEUsWUFBWUYsTUFBTSxJQUFJO0lBQ3RCQSxLQUFLRyxTQUFTLENBQUMsSUFBSSxJQUFJLE1BQXFCLGVBQWU7O0lBQzNESCxLQUFLSSxTQUFTLENBQUMsSUFBSSxHQUFHLE1BQXNCLE1BQU07O0lBQ2xESixLQUFLSSxTQUFTLENBQUMsSUFBSSxHQUFHLE1BQXNCLE9BQU87O0lBQ25ESixLQUFLRyxTQUFTLENBQUMsSUFBSVosWUFBWSxNQUFhLGFBQWE7O0lBQ3pEUyxLQUFLRyxTQUFTLENBQUMsSUFBSVIsVUFBVSxNQUFlLFdBQVc7O0lBQ3ZESyxLQUFLSSxTQUFTLENBQUMsSUFBSVYsWUFBWSxNQUFhLGFBQWE7O0lBQ3pETSxLQUFLSSxTQUFTLENBQUMsSUFBSVosZUFBZSxNQUFVLGdCQUFnQjs7SUFDNUQsY0FBYyxHQUNkVSxZQUFZRixNQUFNLElBQUk7SUFDdEJBLEtBQUtHLFNBQVMsQ0FBQyxJQUFJUCxVQUFVO0lBRTdCLG9CQUFvQjtJQUNwQixJQUFJ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Z0JBQUVDLGFBQWE7Z0JBQU9DLGdCQUFnQjtnQkFBT0MsWUFBWTtnQkFBSUMsT0FBTztZQUFLO1FBQ3RGO2lEQUFHO1FBQUMrRztLQUFrQjtJQUV0QixNQUFNNkIsa0JBQWtCOUssa0RBQVdBO3VEQUFDO1lBQ2hDOEI7K0RBQVNWLENBQUFBLElBQU07d0JBQUUsR0FBR0EsQ0FBQzt3QkFBRWEsWUFBWTtvQkFBRzs7UUFDMUM7c0RBQUcsRUFBRTtJQUVMLE9BQU87UUFDSEo7UUFDQW1CO1FBQ0F3QztRQUNBeUQ7UUFDQUc7UUFDQTBCO1FBQ0F2STtRQUNBSjtRQUNBRTtJQUNKO0FBQ0EiLCJzb3VyY2VzIjpbIkU6XFxBaXZvaWNldG90ZXh0XFxzcmNcXGhvb2tzXFx1c2Utd2hpc3Blci1saXZlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgdXNlVG9hc3QgfSBmcm9tICdAL2hvb2tzL3VzZS10b2FzdCdcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2hpc3BlckxpdmVDb25maWcge1xyXG4gICAgc2VydmVyVXJsOiBzdHJpbmdcclxuICAgIHBvcnQ6IG51bWJlclxyXG4gICAgbGFuZ3VhZ2U6IHN0cmluZ1xyXG4gICAgdHJhbnNsYXRlOiBib29sZWFuXHJcbiAgICBtb2RlbDogc3RyaW5nXHJcbiAgICB2YWQ6IGJvb2xlYW5cclxuICAgIHNhdmVSZWNvcmRpbmc6IGJvb2xlYW5cclxuICAgIG91dHB1dEZpbGVuYW1lOiBzdHJpbmdcclxuICAgIG1heENsaWVudHM6IG51bWJlclxyXG4gICAgbWF4Q29ubmVjdGlvblRpbWU6IG51bWJlclxyXG4gICAgYXVkaW9Tb3VyY2VzPzogeyBtaWNyb3Bob25lOiBib29sZWFuOyBzeXN0ZW1BdWRpbzogYm9vbGVhbiB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBXaGlzcGVyTGl2ZVN0YXRlIHtcclxuICAgIGlzQ29ubmVjdGVkOiBib29sZWFuXHJcbiAgICBpc1RyYW5zY3JpYmluZzogYm9vbGVhblxyXG4gICAgdHJhbnNjcmlwdDogc3RyaW5nXHJcbiAgICBlcnJvcjogc3RyaW5nIHwgbnVsbFxyXG59XHJcbmZ1bmN0aW9uIGVuY29kZVdBVihzYW1wbGVzOiBGbG9hdDMyQXJyYXksIHNhbXBsZVJhdGU6IG51bWJlcik6IERhdGFWaWV3IHtcclxuICBjb25zdCBiaXRzUGVyU2FtcGxlID0gMTZcclxuICBjb25zdCBieXRlc1BlclNhbXBsZSA9IGJpdHNQZXJTYW1wbGUgLyA4XHJcbiAgY29uc3QgYmxvY2tBbGlnbiA9IGJ5dGVzUGVyU2FtcGxlIC8vIG1vbm9cclxuICBjb25zdCBieXRlUmF0ZSA9IHNhbXBsZVJhdGUgKiBibG9ja0FsaWduXHJcbiAgY29uc3QgZGF0YVNpemUgPSBzYW1wbGVzLmxlbmd0aCAqIGJ5dGVzUGVyU2FtcGxlXHJcbiAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQ0ICsgZGF0YVNpemUpXHJcbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpXHJcblxyXG4gIC8qIFJJRkYgaWRlbnRpZmllciAqL1xyXG4gIHdyaXRlU3RyaW5nKHZpZXcsIDAsICdSSUZGJylcclxuICAvKiBmaWxlIGxlbmd0aCBtaW51cyBmaXJzdCA4IGJ5dGVzICovXHJcbiAgdmlldy5zZXRVaW50MzIoNCwgMzYgKyBkYXRhU2l6ZSwgdHJ1ZSlcclxuICAvKiBXQVZFIHR5cGUgKi9cclxuICB3cml0ZVN0cmluZyh2aWV3LCA4LCAnV0FWRScpXHJcbiAgLyogZm10ICBjaHVuayAqL1xyXG4gIHdyaXRlU3RyaW5nKHZpZXcsIDEyLCAnZm10ICcpXHJcbiAgdmlldy5zZXRVaW50MzIoMTYsIDE2LCB0cnVlKSAgICAgICAgICAgICAgICAvLyBjaHVuayBsZW5ndGhcclxuICB2aWV3LnNldFVpbnQxNigyMCwgMSwgdHJ1ZSkgICAgICAgICAgICAgICAgIC8vIFBDTVxyXG4gIHZpZXcuc2V0VWludDE2KDIyLCAxLCB0cnVlKSAgICAgICAgICAgICAgICAgLy8gbW9ub1xyXG4gIHZpZXcuc2V0VWludDMyKDI0LCBzYW1wbGVSYXRlLCB0cnVlKSAgICAgICAgLy8gc2FtcGxlUmF0ZVxyXG4gIHZpZXcuc2V0VWludDMyKDI4LCBieXRlUmF0ZSwgdHJ1ZSkgICAgICAgICAgLy8gYnl0ZVJhdGVcclxuICB2aWV3LnNldFVpbnQxNigzMiwgYmxvY2tBbGlnbiwgdHJ1ZSkgICAgICAgIC8vIGJsb2NrQWxpZ25cclxuICB2aWV3LnNldFVpbnQxNigzNCwgYml0c1BlclNhbXBsZSwgdHJ1ZSkgICAgIC8vIGJpdHNQZXJTYW1wbGVcclxuICAvKiBkYXRhIGNodW5rICovXHJcbiAgd3JpdGVTdHJpbmcodmlldywgMzYsICdkYXRhJylcclxuICB2aWV3LnNldFVpbnQzMig0MCwgZGF0YVNpemUsIHRydWUpXHJcblxyXG4gIC8vIHdyaXRlIFBDTSBzYW1wbGVzXHJcbiAgbGV0IG9mZnNldCA9IDQ0XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAvLyBjbGFtcFxyXG4gICAgY29uc3QgcyA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBzYW1wbGVzW2ldKSlcclxuICAgIC8vIHNjYWxlIHRvIDE24oCRYml0IGludFxyXG4gICAgdmlldy5zZXRJbnQxNihcclxuICAgICAgb2Zmc2V0LFxyXG4gICAgICBzIDwgMCA/IHMgKiAweDgwMDAgOiBzICogMHg3RkZGLFxyXG4gICAgICB0cnVlXHJcbiAgICApXHJcbiAgICBvZmZzZXQgKz0gMlxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHZpZXdcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVTdHJpbmcodmlldzogRGF0YVZpZXcsIG9mZnNldDogbnVtYmVyLCBzOiBzdHJpbmcpIHtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0ICsgaSwgcy5jaGFyQ29kZUF0KGkpKVxyXG4gIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdXNlV2hpc3BlckxpdmUoY29uZmlnOiBXaGlzcGVyTGl2ZUNvbmZpZykge1xyXG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxXaGlzcGVyTGl2ZVN0YXRlPih7XHJcbiAgICAgICAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzVHJhbnNjcmliaW5nOiBmYWxzZSxcclxuICAgICAgICB0cmFuc2NyaXB0OiAnJyxcclxuICAgICAgICBlcnJvcjogbnVsbCxcclxuICAgIH0pXHJcbiAgICBjb25zdCBbYXVkaW9EYXRhLCBzZXRBdWRpb0RhdGFdID0gdXNlU3RhdGU8VWludDhBcnJheSB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCBbZGF0YVVwZGF0ZVRyaWdnZXIsIHNldERhdGFVcGRhdGVUcmlnZ2VyXSA9IHVzZVN0YXRlKDApXHJcbiAgICBjb25zdCB3c1JlZiA9IHVzZVJlZjxXZWJTb2NrZXQgfCBudWxsPihudWxsKVxyXG4gICAgY29uc3QgcmVjb3JkaW5nQnVmZmVycyA9IHVzZVJlZjxGbG9hdDMyQXJyYXlbXT4oW10pXHJcblxyXG5cclxuICAgIGNvbnN0IHVpZFJlZiA9IHVzZVJlZihcclxuICAgICAgICB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRFxyXG4gICAgICAgICAgICA/IGNyeXB0by5yYW5kb21VVUlEKClcclxuICAgICAgICAgICAgOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxcclxuICAgIClcclxuICAgIGNvbnN0IHsgdG9hc3QgfSA9IHVzZVRvYXN0KClcclxuXHJcbiAgICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbdXNlV2hpc3BlckxpdmVdICBjb25uZWN0KCknLCBjb25maWcpO1xyXG4gICAgICAgIGlmICh3c1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAxKSBjcmVhdGUgQXVkaW9Db250ZXh0IG5vdyBzbyB3ZSBjYW4gaGFuZCBpdHMgcmVhbCBzYW1wbGVSYXRlIHRvIHRoZSBzZXJ2ZXJcclxuICAgICAgICBjb25zdCBjdHggPSBuZXcgQXVkaW9Db250ZXh0KHsgc2FtcGxlUmF0ZTogMTYwMDAgfSk7XHJcbiAgICAgICAgY3R4UmVmLmN1cnJlbnQgPSBjdHhcclxuICAgICAgICBjb25zdCBhY3R1YWxTYW1wbGVSYXRlID0gY3R4LnNhbXBsZVJhdGVcclxuICAgICAgICBjb25zb2xlLmxvZygnW3VzZVdoaXNwZXJMaXZlXSBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSA9JywgYWN0dWFsU2FtcGxlUmF0ZSlcclxuICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiBudWxsIH0pKVxyXG5cclxuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnd3NzJyA6ICd3cyc7XHJcbiAgICAgICAgY29uc3Qgd3MgPSBuZXcgV2ViU29ja2V0KGAke3Byb3RvY29sfTovLyR7Y29uZmlnLnNlcnZlclVybH06JHtjb25maWcucG9ydH1gKTtcclxuICAgICAgICB3cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xyXG4gICAgICAgIHdzUmVmLmN1cnJlbnQgPSB3c1xyXG5cclxuICAgICAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbdXNlV2hpc3BlckxpdmVdIPCfn6IgV2ViU29ja2V0IE9QRU4nKTtcclxuICAgICAgICAgICAgY29uc3QgdGFza05hbWUgPSBjb25maWcudHJhbnNsYXRlID8gJ3RyYW5zbGF0ZScgOiAndHJhbnNjcmliZSdcclxuICAgICAgICAgICAgd3Muc2VuZChcclxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrOiB0YXNrTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZFJlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBjb25maWcubGFuZ3VhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IGNvbmZpZy5tb2RlbCxcclxuICAgICAgICAgICAgICAgICAgICB1c2VfdmFkOiBjb25maWcudmFkLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgc2VuZCB1cyB0aGUgbmV3ZXN0IHNlZ21lbnQgZWFjaCB0aW1lOlxyXG4gICAgICAgICAgICAgICAgICAgIHNlbmRfbGFzdF9uX3NlZ21lbnRzOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVfcmVjb3JkaW5nOiBjb25maWcuc2F2ZVJlY29yZGluZyxcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRfZmlsZW5hbWU6IGNvbmZpZy5vdXRwdXRGaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhfY2xpZW50czogY29uZmlnLm1heENsaWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4X2Nvbm5lY3Rpb25fdGltZTogY29uZmlnLm1heENvbm5lY3Rpb25UaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICoqaW1wb3J0YW50Kio6IG11c3QgbWF0Y2ggeW91ciBBdWRpb0NvbnRleHQgJiBTY3JpcHRQcm9jZXNzb3JcclxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVfcmF0ZTogYWN0dWFsU2FtcGxlUmF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBjaHVua19zaXplOiA0MDk2LFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgc3RhcnRUcmFuc2NyaXB0aW9uKCk7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNDb25uZWN0ZWQ6IHRydWUgfSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpbnNpZGUgeW91ciBjb25uZWN0KClcclxuICAgICAgICB3cy5vbm1lc3NhZ2UgPSBlID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JhdyBXUyBNZXNzYWdlOicsIGUuZGF0YSlcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRhdGEgIT09ICdzdHJpbmcnKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSBoYW5kc2hha2VcclxuICAgICAgICAgICAgaWYgKG1zZy5tZXNzYWdlID09PSAnU0VSVkVSX1JFQURZJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gZXJyb3JzXHJcbiAgICAgICAgICAgIGlmIChtc2cudHlwZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogbXNnLm1lc3NhZ2UgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBvbGTigJBzdHlsZSBwYXJ0aWFsL2ZpbmFsIChpZiB5b3UgZXZlciB0b2dnbGUgdGhhdCBiYWNrIG9uKVxyXG4gICAgICAgICAgICBpZiAobXNnLnR5cGUgPT09ICdwYXJ0aWFsJyB8fCBtc2cudHlwZSA9PT0gJ3RyYW5zY3JpcHQnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucyxcclxuICAgICAgICAgICAgICAgICAgICBpc1RyYW5zY3JpYmluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NyaXB0OiBzLnRyYW5zY3JpcHQgKyBtc2cudGV4dFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtc2cudHlwZSA9PT0gJ2ZpbmFsJykge1xyXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUcmFuc2NyaWJpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY3JpcHQ6IHMudHJhbnNjcmlwdCArIG1zZy50ZXh0ICsgJ1xcbidcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g4oaQIE5FVzogaGFuZGxlIHRoZSBgc2VnbWVudHNgIGFycmF5XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1zZy5zZWdtZW50cykpIHtcclxuICAgICAgICAgICAgICAgIC8vIGp1c3QgZ3JhYiB0aGUgdmVyeSBsYXN0IHNlZ21lbnQgYW5kIGFwcGVuZCBpdFxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IG1zZy5zZWdtZW50c1ttc2cuc2VnbWVudHMubGVuZ3RoIC0gMV1cclxuICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVHJhbnNjcmliaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY3JpcHQ6IHMudHJhbnNjcmlwdCArIGxhc3QudGV4dFxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIGFueSBzdHJheSBgbXNnLm1lc3NhZ2VgXHJcbiAgICAgICAgICAgIGlmIChtc2cubWVzc2FnZSAmJiBtc2cubWVzc2FnZSAhPT0gJ1NFUlZFUl9SRUFEWScpIHtcclxuICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVHJhbnNjcmliaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY3JpcHQ6IHMudHJhbnNjcmlwdCArIG1zZy5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgd3Mub25jbG9zZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBpc0Nvbm5lY3RlZDogZmFsc2UsIGlzVHJhbnNjcmliaW5nOiBmYWxzZSB9KSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdzLm9uZXJyb3IgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW3VzZVdoaXNwZXJMaXZlXSBXZWJTb2NrZXQgZXJyb3IgKG5vbuKAkWZhdGFsKScsIGVycik7XHJcbiAgICAgICAgICAgIC8vIGRvbuKAmXQgc2V0U3RhdGUgb3IgdG9hc3QgaGVyZVxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbY29uZmlnLCB0b2FzdF0pXHJcblxyXG4gICAgY29uc3QgbWljUmVmID0gdXNlUmVmPE1lZGlhU3RyZWFtIHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IHN5c3RlbVJlZiA9IHVzZVJlZjxNZWRpYVN0cmVhbSB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCBjdHhSZWYgPSB1c2VSZWY8QXVkaW9Db250ZXh0IHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IHByb2Nlc3NvclJlZiA9IHVzZVJlZjxTY3JpcHRQcm9jZXNzb3JOb2RlIHwgbnVsbD4obnVsbClcclxuXHJcbiAgICBjb25zdCBzdGFydFRyYW5zY3JpcHRpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCF3c1JlZi5jdXJyZW50IHx8IHdzUmVmLmN1cnJlbnQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogJ05vdCBjb25uZWN0ZWQnIH0pKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gMSkgU2NyZWVuICsgc3lzdGVtIGF1ZGlvIChpZiBlbmFibGVkKVxyXG4gICAgICAgICAgICBsZXQgc3lzdGVtU3RyZWFtOiBNZWRpYVN0cmVhbSB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmF1ZGlvU291cmNlcz8uc3lzdGVtQXVkaW8pIHtcclxuICAgICAgICAgICAgICAgIHN5c3RlbVN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKHtcclxuICAgICAgICAgICAgICAgICAgICB2aWRlbzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBhdWRpbzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3lzdGVtUmVmLmN1cnJlbnQgPSBzeXN0ZW1TdHJlYW07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDIpIE1pY3JvcGhvbmVcclxuICAgICAgICAgICAgY29uc3QgbWljU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xyXG4gICAgICAgICAgICAgICAgYXVkaW86IHsgc2FtcGxlUmF0ZTogMTYwMDAsIGNoYW5uZWxDb3VudDogMSB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbWljUmVmLmN1cnJlbnQgPSBtaWNTdHJlYW07XHJcblxyXG5cclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gY3R4UmVmLmN1cnJlbnQhXHJcbiAgICAgICAgICAgIGNvbnN0IGRlc3QgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpXHJcblxyXG4gICAgICAgICAgICAvLyA0KSBXaXJlIG1pYyDihpIgZGVzdFxyXG4gICAgICAgICAgICBjb25zdCBtaWNTcmMgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobWljU3RyZWFtKTtcclxuICAgICAgICAgICAgbWljU3JjLmNvbm5lY3QoZGVzdCk7XHJcblxyXG4gICAgICAgICAgICAvLyA1KSBXaXJlIHN5c3RlbSBhdWRpbyDihpIgZGVzdFxyXG4gICAgICAgICAgICBpZiAoc3lzdGVtU3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzeXNTcmMgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3lzdGVtU3RyZWFtKTtcclxuICAgICAgICAgICAgICAgIHN5c1NyYy5jb25uZWN0KGRlc3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyA2KSBJbnN0ZWFkIG9mIHdpcmluZyBtaWMrc3lzIGRpcmVjdGx5IHRvIHRoZSBwcm9jZXNzb3IsIHdlXHJcbiAgICAgICAgICAgIC8vICAgIHRha2UgdGhlIG1peGVkIGRlc3Quc3RyZWFtIGFuZCBob29rIHRoYXQgdXA6XHJcbiAgICAgICAgICAgIGNvbnN0IG1peGVkU3JjID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKGRlc3Quc3RyZWFtKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDcpIENyZWF0ZSB5b3VyIFNjcmlwdFByb2Nlc3NvciAoYnVmZmVyU2l6ZT00MDk2LCBtb25vIGluL291dClcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gY3R4LmNyZWF0ZVNjcmlwdFByb2Nlc3Nvcig0MDk2LCAxLCAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDgpIFdpcmUgdGhlIG1peGVkIGF1ZGlvIGludG8gdGhlIHByb2Nlc3NvclxyXG4gICAgICAgICAgICBtaXhlZFNyYy5jb25uZWN0KHByb2Nlc3Nvcik7XHJcblxyXG4gICAgICAgICAgICAvLyA5KSBPbiBlYWNoIG9uYXVkaW9wcm9jZXNzLCBidWlsZCBleGFjdGx5IG9uZSBwYWNrZXRcclxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uYXVkaW9wcm9jZXNzID0gZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmbG9hdDMyID0gZS5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmxvYXQzMkJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoZmxvYXQzMilcclxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuc2F2ZVJlY29yZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudC5wdXNoKGZsb2F0MzJCdWZmZXIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDihpIgY29udmVydCB0byBVaW50OEFycmF5IFswLi4yNTVdXHJcbiAgICAgICAgICAgICAgICBjb25zdCB1aTggPSBuZXcgVWludDhBcnJheShmbG9hdDMyQnVmZmVyLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmxvYXQzMkJ1ZmZlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHVpOFtpXSA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAyNTUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAsIE1hdGguZmxvb3IoKGZsb2F0MzJCdWZmZXJbaV0gKyAxKSAqIDEyNy41KSlcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc2VuZCByYXcgZmxvYXQzMiBQQ00gdG8gc2VydmVyXHJcbiAgICAgICAgICAgICAgICBpZiAod3NSZWYuY3VycmVudCEucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgICAgICAgICB3c1JlZi5jdXJyZW50IS5zZW5kKGZsb2F0MzJCdWZmZXIuYnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB2aXN1YWxpemVyXHJcbiAgICAgICAgICAgICAgICBzZXRBdWRpb0RhdGEodWk4KVxyXG4gICAgICAgICAgICAgICAgc2V0RGF0YVVwZGF0ZVRyaWdnZXIodCA9PiB0ICsgMSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMTApIFN0YXJ0IGl0XHJcbiAgICAgICAgICAgIHByb2Nlc3Nvci5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgICAgIHByb2Nlc3NvclJlZi5jdXJyZW50ID0gcHJvY2Vzc29yO1xyXG5cclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBpc1RyYW5zY3JpYmluZzogdHJ1ZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiBgRmFpbGVkIHRvIHN0YXJ0IHRyYW5zY3JpcHRpb246ICR7ZXJyLm1lc3NhZ2V9YCB9KSk7XHJcbiAgICAgICAgICAgIHRvYXN0KHsgdGl0bGU6ICdUcmFuc2NyaXB0aW9uIEVycm9yJywgZGVzY3JpcHRpb246IGVyci5tZXNzYWdlLCB2YXJpYW50OiAnZGVzdHJ1Y3RpdmUnIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtjb25maWcsIHRvYXN0XSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHN0b3BUcmFuc2NyaXB0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGlmICh3c1JlZi5jdXJyZW50Py5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICAvLyB6ZXJv4oCRbGVuZ3RoIEFycmF5QnVmZmVyIHNpZ25hbHMg4oCccGxlYXNlIGZsdXNoICYgZmluaXNo4oCdXHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQuc2VuZChuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoXCJFTkRfT0ZfQVVESU9cIikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGVhciBkb3duIGF1ZGlvIGdyYXBoIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgaWYgKHByb2Nlc3NvclJlZi5jdXJyZW50KSB7IHByb2Nlc3NvclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTsgcHJvY2Vzc29yUmVmLmN1cnJlbnQgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKG1pY1JlZi5jdXJyZW50KSB7IG1pY1JlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSk7IG1pY1JlZi5jdXJyZW50ID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChzeXN0ZW1SZWYuY3VycmVudCkgeyBzeXN0ZW1SZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKHQgPT4gdC5zdG9wKCkpOyBzeXN0ZW1SZWYuY3VycmVudCA9IG51bGw7IH1cclxuICAgICAgICBpZiAoY3R4UmVmLmN1cnJlbnQpIHsgY3R4UmVmLmN1cnJlbnQuY2xvc2UoKTsgY3R4UmVmLmN1cnJlbnQgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGNvbmZpZy5zYXZlUmVjb3JkaW5nICYmIHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgdG90YWxMZW5ndGggPSByZWNvcmRpbmdCdWZmZXJzLmN1cnJlbnQucmVkdWNlKChzdW0sIGJ1ZikgPT4gc3VtICsgYnVmLmxlbmd0aCwgMClcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJsZWF2ZWQgPSBuZXcgRmxvYXQzMkFycmF5KHRvdGFsTGVuZ3RoKVxyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMFxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJ1ZiBvZiByZWNvcmRpbmdCdWZmZXJzLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGludGVybGVhdmVkLnNldChidWYsIG9mZnNldClcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBidWYubGVuZ3RoXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYnVpbGQgYSBXQVYgaGVhZGVyICsgZGF0YSB2aWV3ICg0NOKAkWJ5dGUgUENNMTYgV0FWKVxyXG4gICAgICAgICAgICBjb25zdCB3YXZCdWZmZXIgPSBlbmNvZGVXQVYoaW50ZXJsZWF2ZWQsIGN0eFJlZi5jdXJyZW50IS5zYW1wbGVSYXRlKVxyXG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3dhdkJ1ZmZlcl0sIHsgdHlwZTogJ2F1ZGlvL3dhdicgfSlcclxuICAgICAgICAgICAgY29uc3QgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXHJcbiAgICAgICAgICAgIGZvcm0uYXBwZW5kKCdmaWxlJywgYmxvYiwgY29uZmlnLm91dHB1dEZpbGVuYW1lIHx8ICdyZWNvcmRpbmcud2F2JylcclxuICAgICAgICAgICAgZmV0Y2goJy9hcGkvdXBsb2FkJywgeyBtZXRob2Q6ICdQT1NUJywgYm9keTogZm9ybSB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4ociA9PiByLm9rIHx8IFByb21pc2UucmVqZWN0KCd1cGxvYWQgZmFpbGVkJykpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHRvYXN0KHsgdGl0bGU6ICdVcGxvYWQgRXJyb3InLCBkZXNjcmlwdGlvbjogU3RyaW5nKGVyciksIHZhcmlhbnQ6ICdkZXN0cnVjdGl2ZScgfSkpXHJcbiAgICAgICAgICAgIHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudCA9IFtdXHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGlzVHJhbnNjcmliaW5nOiBmYWxzZSB9KSk7XHJcblxyXG4gICAgfSwgW2NvbmZpZywgdG9hc3RdKVxyXG4gIFxyXG5cclxuXHJcbmNvbnN0IGRpc2Nvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAod3NSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHdzUmVmLmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICAgIHdzUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICB9XHJcbiAgICBzdG9wVHJhbnNjcmlwdGlvbigpXHJcbiAgICBzZXRTdGF0ZSh7IGlzQ29ubmVjdGVkOiBmYWxzZSwgaXNUcmFuc2NyaWJpbmc6IGZhbHNlLCB0cmFuc2NyaXB0OiAnJywgZXJyb3I6IG51bGwgfSlcclxufSwgW3N0b3BUcmFuc2NyaXB0aW9uXSlcclxuXHJcbmNvbnN0IGNsZWFyVHJhbnNjcmlwdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgdHJhbnNjcmlwdDogJycgfSkpXHJcbn0sIFtdKVxyXG5cclxucmV0dXJuIHtcclxuICAgIHN0YXRlLFxyXG4gICAgY29ubmVjdCxcclxuICAgIHN0YXJ0VHJhbnNjcmlwdGlvbixcclxuICAgIHN0b3BUcmFuc2NyaXB0aW9uLFxyXG4gICAgZGlzY29ubmVjdCxcclxuICAgIGNsZWFyVHJhbnNjcmlwdCxcclxuICAgIHdzUmVmLFxyXG4gICAgYXVkaW9EYXRhLFxyXG4gICAgZGF0YVVwZGF0ZVRyaWdnZXIsXHJcbn1cclxufVxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZVRvYXN0IiwiZW5jb2RlV0FWIiwic2FtcGxlcyIsInNhbXBsZVJhdGUiLCJiaXRzUGVyU2FtcGxlIiwiYnl0ZXNQZXJTYW1wbGUiLCJibG9ja0FsaWduIiwiYnl0ZVJhdGUiLCJkYXRhU2l6ZSIsImxlbmd0aCIsImJ1ZmZlciIsIkFycmF5QnVmZmVyIiwidmlldyIsIkRhdGFWaWV3Iiwid3JpdGVTdHJpbmciLCJzZXRVaW50MzIiLCJzZXRVaW50MTYiLCJvZmZzZXQiLCJpIiwicyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJzZXRJbnQxNiIsInNldFVpbnQ4IiwiY2hhckNvZGVBdCIsInVzZVdoaXNwZXJMaXZlIiwiY29uZmlnIiwic3RhdGUiLCJzZXRTdGF0ZSIsImlzQ29ubmVjdGVkIiwiaXNUcmFuc2NyaWJpbmciLCJ0cmFuc2NyaXB0IiwiZXJyb3IiLCJhdWRpb0RhdGEiLCJzZXRBdWRpb0RhdGEiLCJkYXRhVXBkYXRlVHJpZ2dlciIsInNldERhdGFVcGRhdGVUcmlnZ2VyIiwid3NSZWYiLCJyZWNvcmRpbmdCdWZmZXJzIiwidWlkUmVmIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJ0b2FzdCIsImNvbm5lY3QiLCJjb25zb2xlIiwibG9nIiwiY3VycmVudCIsImNsb3NlIiwiY3R4IiwiQXVkaW9Db250ZXh0IiwiY3R4UmVmIiwiYWN0dWFsU2FtcGxlUmF0ZSIsInByb3RvY29sIiwid2luZG93IiwibG9jYXRpb24iLCJ3cyIsIldlYlNvY2tldCIsInNlcnZlclVybCIsInBvcnQiLCJiaW5hcnlUeXBlIiwib25vcGVuIiwidGFza05hbWUiLCJ0cmFuc2xhdGUiLCJzZW5kIiwiSlNPTiIsInN0cmluZ2lmeSIsInRhc2siLCJ1aWQiLCJsYW5ndWFnZSIsIm1vZGVsIiwidXNlX3ZhZCIsInZhZCIsInNlbmRfbGFzdF9uX3NlZ21lbnRzIiwic2F2ZV9yZWNvcmRpbmciLCJzYXZlUmVjb3JkaW5nIiwib3V0cHV0X2ZpbGVuYW1lIiwib3V0cHV0RmlsZW5hbWUiLCJtYXhfY2xpZW50cyIsIm1heENsaWVudHMiLCJtYXhfY29ubmVjdGlvbl90aW1lIiwibWF4Q29ubmVjdGlvblRpbWUiLCJzYW1wbGVfcmF0ZSIsImNodW5rX3NpemUiLCJzdGFydFRyYW5zY3JpcHRpb24iLCJvbm1lc3NhZ2UiLCJlIiwiZGF0YSIsIm1zZyIsInBhcnNlIiwibWVzc2FnZSIsInR5cGUiLCJ0ZXh0IiwiQXJyYXkiLCJpc0FycmF5Iiwic2VnbWVudHMiLCJsYXN0Iiwib25jbG9zZSIsIm9uZXJyb3IiLCJlcnIiLCJ3YXJuIiwibWljUmVmIiwic3lzdGVtUmVmIiwicHJvY2Vzc29yUmVmIiwicmVhZHlTdGF0ZSIsIk9QRU4iLCJzeXN0ZW1TdHJlYW0iLCJhdWRpb1NvdXJjZXMiLCJzeXN0ZW1BdWRpbyIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldERpc3BsYXlNZWRpYSIsInZpZGVvIiwiYXVkaW8iLCJtaWNTdHJlYW0iLCJnZXRVc2VyTWVkaWEiLCJjaGFubmVsQ291bnQiLCJkZXN0IiwiY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbiIsIm1pY1NyYyIsImNyZWF0ZU1lZGlhU3RyZWFtU291cmNlIiwic3lzU3JjIiwibWl4ZWRTcmMiLCJzdHJlYW0iLCJwcm9jZXNzb3IiLCJjcmVhdGVTY3JpcHRQcm9jZXNzb3IiLCJvbmF1ZGlvcHJvY2VzcyIsImZsb2F0MzIiLCJpbnB1dEJ1ZmZlciIsImdldENoYW5uZWxEYXRhIiwiZmxvYXQzMkJ1ZmZlciIsIkZsb2F0MzJBcnJheSIsInB1c2giLCJ1aTgiLCJVaW50OEFycmF5IiwiZmxvb3IiLCJ0IiwiZGVzdGluYXRpb24iLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwidmFyaWFudCIsInN0b3BUcmFuc2NyaXB0aW9uIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJkaXNjb25uZWN0IiwiZ2V0VHJhY2tzIiwiZm9yRWFjaCIsInN0b3AiLCJ0b3RhbExlbmd0aCIsInJlZHVjZSIsInN1bSIsImJ1ZiIsImludGVybGVhdmVkIiwic2V0Iiwid2F2QnVmZmVyIiwiYmxvYiIsIkJsb2IiLCJmb3JtIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJ0aGVuIiwiciIsIm9rIiwiUHJvbWlzZSIsInJlamVjdCIsImNhdGNoIiwiU3RyaW5nIiwiY2xlYXJUcmFuc2NyaXB0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-whisper-live.ts\n"));

/***/ })

});