"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/notes/page",{

/***/ "(app-pages-browser)/./src/hooks/use-whisper-live.ts":
/*!***************************************!*\
  !*** ./src/hooks/use-whisper-live.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWhisperLive: () => (/* binding */ useWhisperLive)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/hooks/use-toast */ \"(app-pages-browser)/./src/hooks/use-toast.ts\");\n/* __next_internal_client_entry_do_not_use__ useWhisperLive auto */ \n\nfunction useWhisperLive(config) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        isTranscribing: false,\n        transcript: '',\n        error: null\n    });\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const uidRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));\n    const { toast } = (0,_hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__.useToast)();\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[connect]\": ()=>{\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            setState({\n                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                        ...s,\n                        error: null\n                    })\n            }[\"useWhisperLive.useCallback[connect]\"]);\n            const ws = new WebSocket(\"ws://\".concat(config.serverUrl, \":\").concat(config.port));\n            ws.binaryType = 'arraybuffer';\n            wsRef.current = ws;\n            ws.onopen = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    const taskName = config.translate ? 'translate' : 'transcribe';\n                    ws.send(JSON.stringify({\n                        task: taskName,\n                        uid: uidRef.current,\n                        language: config.language,\n                        model: config.model,\n                        vad: config.vad,\n                        save_recording: config.saveRecording,\n                        output_filename: config.outputFilename,\n                        max_clients: config.maxClients,\n                        max_connection_time: config.maxConnectionTime,\n                        // **important**: must match your AudioContext & ScriptProcessor\n                        sample_rate: 16000,\n                        chunk_size: 4096\n                    }));\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: true\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onmessage = ({\n                \"useWhisperLive.useCallback[connect]\": (e)=>{\n                    if (typeof e.data === 'string') {\n                        const msg = JSON.parse(e.data);\n                        if (msg.type === 'transcript') {\n                            setState({\n                                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                        ...s,\n                                        transcript: s.transcript + msg.text\n                                    })\n                            }[\"useWhisperLive.useCallback[connect]\"]);\n                        } else if (msg.type === 'error') {\n                            setState({\n                                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                        ...s,\n                                        error: msg.message\n                                    })\n                            }[\"useWhisperLive.useCallback[connect]\"]);\n                        }\n                    }\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onclose = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: false,\n                                isTranscribing: false\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onerror = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                error: 'WebSocket connection failed'\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                    toast({\n                        title: 'Connection Error',\n                        description: 'Failed to connect to WhisperLive server',\n                        variant: 'destructive'\n                    });\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n        }\n    }[\"useWhisperLive.useCallback[connect]\"], [\n        config,\n        toast\n    ]);\n    const micRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const systemRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ctxRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const processorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const startTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[startTranscription]\": async ()=>{\n            if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: 'Not connected'\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                return;\n            }\n            try {\n                var _config_audioSources;\n                // 1) prompt for screen+audio\n                let systemStream = null;\n                if ((_config_audioSources = config.audioSources) === null || _config_audioSources === void 0 ? void 0 : _config_audioSources.systemAudio) {\n                    systemStream = await navigator.mediaDevices.getDisplayMedia({\n                        video: false,\n                        audio: true\n                    });\n                    systemRef.current = systemStream;\n                }\n                // 2) prompt for mic\n                const micStream = await navigator.mediaDevices.getUserMedia({\n                    audio: {\n                        sampleRate: 16000,\n                        channelCount: 1\n                    }\n                });\n                micRef.current = micStream;\n                // 3) build audio graph\n                const ctx = new AudioContext({\n                    sampleRate: 16000\n                });\n                ctxRef.current = ctx;\n                const dest = ctx.createMediaStreamDestination();\n                // mic source\n                const micSrc = ctx.createMediaStreamSource(micStream);\n                micSrc.connect(dest);\n                // optional system source\n                let sysSrc = null;\n                if (systemStream) {\n                    sysSrc = ctx.createMediaStreamSource(systemStream);\n                    sysSrc.connect(dest);\n                }\n                // 4) create processor\n                const processor = ctx.createScriptProcessor(4096, 1, 1);\n                // wire sources into processor\n                micSrc.connect(processor);\n                if (sysSrc) sysSrc.connect(processor);\n                // 5) on each audio frame, convert → Int16 → prefix header → send\n                // inside your onaudioprocess:\n                processor.onaudioprocess = ({\n                    \"useWhisperLive.useCallback[startTranscription]\": (e)=>{\n                        var _wsRef_current, _wsRef_current1;\n                        const float32 = e.inputBuffer.getChannelData(0);\n                        const int16 = new Int16Array(float32.length);\n                        for(let i = 0; i < float32.length; i++){\n                            int16[i] = Math.max(-32768, Math.min(32767, float32[i] * 32767));\n                        }\n                        // This buffer is always exactly 4096 samples × 2 bytes = 8192 bytes\n                        if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                            wsRef.current.send(int16.buffer);\n                        }\n                        // Build a packet with a 1‑byte “audio” header (0x01) followed by PCM\n                        const pcm = new Uint8Array(int16.buffer);\n                        const packet = new Uint8Array(1 + pcm.length);\n                        packet[0] = 1; // 1 = “audio chunk”\n                        packet.set(pcm, 1);\n                        if (((_wsRef_current1 = wsRef.current) === null || _wsRef_current1 === void 0 ? void 0 : _wsRef_current1.readyState) === WebSocket.OPEN) {\n                            wsRef.current.send(packet.buffer);\n                        }\n                    }\n                })[\"useWhisperLive.useCallback[startTranscription]\"];\n                // 6) kick it off\n                processor.connect(ctx.destination);\n                processorRef.current = processor;\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            isTranscribing: true\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n            } catch (err) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: \"Failed to start transcription: \".concat(err.message)\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                toast({\n                    title: 'Transcription Error',\n                    description: err.message,\n                    variant: 'destructive'\n                });\n            }\n        }\n    }[\"useWhisperLive.useCallback[startTranscription]\"], [\n        config,\n        toast\n    ]);\n    const stopTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[stopTranscription]\": ()=>{\n            var _wsRef_current;\n            if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                // 0x02 = “end of stream”\n                wsRef.current.send(new Uint8Array([\n                    2\n                ]).buffer);\n            // Now wait for the server to send the final transcript and close\n            }\n            // Locally tear down your audio graph immediately:\n            if (processorRef.current) {\n                processorRef.current.disconnect();\n                processorRef.current = null;\n            }\n            if (micRef.current) {\n                micRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                micRef.current = null;\n            }\n            if (systemRef.current) {\n                systemRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                systemRef.current = null;\n            }\n            if (ctxRef.current) {\n                ctxRef.current.close();\n                ctxRef.current = null;\n            }\n            setState({\n                \"useWhisperLive.useCallback[stopTranscription]\": (s)=>({\n                        ...s,\n                        isTranscribing: false\n                    })\n            }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n        }\n    }[\"useWhisperLive.useCallback[stopTranscription]\"], []);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[disconnect]\": ()=>{\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            stopTranscription();\n            setState({\n                isConnected: false,\n                isTranscribing: false,\n                transcript: '',\n                error: null\n            });\n        }\n    }[\"useWhisperLive.useCallback[disconnect]\"], [\n        stopTranscription\n    ]);\n    const clearTranscript = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[clearTranscript]\": ()=>{\n            setState({\n                \"useWhisperLive.useCallback[clearTranscript]\": (s)=>({\n                        ...s,\n                        transcript: ''\n                    })\n            }[\"useWhisperLive.useCallback[clearTranscript]\"]);\n        }\n    }[\"useWhisperLive.useCallback[clearTranscript]\"], []);\n    return {\n        state,\n        connect,\n        startTranscription,\n        stopTranscription,\n        disconnect,\n        clearTranscript,\n        wsRef\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utd2hpc3Blci1saXZlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7b0VBRXFEO0FBQ1Q7QUF1QnJDLFNBQVNJLGVBQWVDLE1BQXlCO0lBQ3BELE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHUCwrQ0FBUUEsQ0FBbUI7UUFDakRRLGFBQWE7UUFDYkMsZ0JBQWdCO1FBQ2hCQyxZQUFZO1FBQ1pDLE9BQU87SUFDWDtJQUVBLE1BQU1DLFFBQVFYLDZDQUFNQSxDQUFtQjtJQUN2QyxNQUFNWSxTQUFTWiw2Q0FBTUEsQ0FDakIsT0FBT2EsV0FBVyxlQUFlQSxPQUFPQyxVQUFVLEdBQzVDRCxPQUFPQyxVQUFVLEtBQ2pCQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxLQUFLLENBQUM7SUFFM0MsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR2pCLDBEQUFRQTtJQUUxQixNQUFNa0IsVUFBVW5CLGtEQUFXQTsrQ0FBQztZQUN4QixJQUFJVSxNQUFNVSxPQUFPLEVBQUU7Z0JBQ2ZWLE1BQU1VLE9BQU8sQ0FBQ0MsS0FBSztnQkFDbkJYLE1BQU1VLE9BQU8sR0FBRztZQUNwQjtZQUNBZjt1REFBU2lCLENBQUFBLElBQU07d0JBQUUsR0FBR0EsQ0FBQzt3QkFBRWIsT0FBTztvQkFBSzs7WUFFbkMsTUFBTWMsS0FBSyxJQUFJQyxVQUFVLFFBQTRCckIsT0FBcEJBLE9BQU9zQixTQUFTLEVBQUMsS0FBZSxPQUFadEIsT0FBT3VCLElBQUk7WUFDaEVILEdBQUdJLFVBQVUsR0FBRztZQUNoQmpCLE1BQU1VLE9BQU8sR0FBR0c7WUFFaEJBLEdBQUdLLE1BQU07dURBQUc7b0JBQ1IsTUFBTUMsV0FBVzFCLE9BQU8yQixTQUFTLEdBQUcsY0FBYztvQkFDbERQLEdBQUdRLElBQUksQ0FDSEMsS0FBS0MsU0FBUyxDQUFDO3dCQUNYQyxNQUFNTDt3QkFDTk0sS0FBS3hCLE9BQU9TLE9BQU87d0JBQ25CZ0IsVUFBVWpD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XHNyY1xcaG9va3NcXHVzZS13aGlzcGVyLWxpdmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgeyB1c2VUb2FzdCB9IGZyb20gJ0AvaG9va3MvdXNlLXRvYXN0J1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXaGlzcGVyTGl2ZUNvbmZpZyB7XHJcbiAgICBzZXJ2ZXJVcmw6IHN0cmluZ1xyXG4gICAgcG9ydDogbnVtYmVyXHJcbiAgICBsYW5ndWFnZTogc3RyaW5nXHJcbiAgICB0cmFuc2xhdGU6IGJvb2xlYW5cclxuICAgIG1vZGVsOiBzdHJpbmdcclxuICAgIHZhZDogYm9vbGVhblxyXG4gICAgc2F2ZVJlY29yZGluZzogYm9vbGVhblxyXG4gICAgb3V0cHV0RmlsZW5hbWU6IHN0cmluZ1xyXG4gICAgbWF4Q2xpZW50czogbnVtYmVyXHJcbiAgICBtYXhDb25uZWN0aW9uVGltZTogbnVtYmVyXHJcbiAgICBhdWRpb1NvdXJjZXM/OiB7IG1pY3JvcGhvbmU6IGJvb2xlYW47IHN5c3RlbUF1ZGlvOiBib29sZWFuIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIFdoaXNwZXJMaXZlU3RhdGUge1xyXG4gICAgaXNDb25uZWN0ZWQ6IGJvb2xlYW5cclxuICAgIGlzVHJhbnNjcmliaW5nOiBib29sZWFuXHJcbiAgICB0cmFuc2NyaXB0OiBzdHJpbmdcclxuICAgIGVycm9yOiBzdHJpbmcgfCBudWxsXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VXaGlzcGVyTGl2ZShjb25maWc6IFdoaXNwZXJMaXZlQ29uZmlnKSB7XHJcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPFdoaXNwZXJMaXZlU3RhdGU+KHtcclxuICAgICAgICBpc0Nvbm5lY3RlZDogZmFsc2UsXHJcbiAgICAgICAgaXNUcmFuc2NyaWJpbmc6IGZhbHNlLFxyXG4gICAgICAgIHRyYW5zY3JpcHQ6ICcnLFxyXG4gICAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgfSlcclxuXHJcbiAgICBjb25zdCB3c1JlZiA9IHVzZVJlZjxXZWJTb2NrZXQgfCBudWxsPihudWxsKVxyXG4gICAgY29uc3QgdWlkUmVmID0gdXNlUmVmKFxyXG4gICAgICAgIHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEXHJcbiAgICAgICAgICAgID8gY3J5cHRvLnJhbmRvbVVVSUQoKVxyXG4gICAgICAgICAgICA6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLFxyXG4gICAgKVxyXG4gICAgY29uc3QgeyB0b2FzdCB9ID0gdXNlVG9hc3QoKVxyXG5cclxuICAgIGNvbnN0IGNvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKHdzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudC5jbG9zZSgpXHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgZXJyb3I6IG51bGwgfSkpXHJcblxyXG4gICAgICAgIGNvbnN0IHdzID0gbmV3IFdlYlNvY2tldChgd3M6Ly8ke2NvbmZpZy5zZXJ2ZXJVcmx9OiR7Y29uZmlnLnBvcnR9YClcclxuICAgICAgICB3cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xyXG4gICAgICAgIHdzUmVmLmN1cnJlbnQgPSB3c1xyXG5cclxuICAgICAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhc2tOYW1lID0gY29uZmlnLnRyYW5zbGF0ZSA/ICd0cmFuc2xhdGUnIDogJ3RyYW5zY3JpYmUnXHJcbiAgICAgICAgICAgIHdzLnNlbmQoXHJcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzazogdGFza05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWRSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZTogY29uZmlnLmxhbmd1YWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBjb25maWcubW9kZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFkOiBjb25maWcudmFkLFxyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVfcmVjb3JkaW5nOiBjb25maWcuc2F2ZVJlY29yZGluZyxcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRfZmlsZW5hbWU6IGNvbmZpZy5vdXRwdXRGaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhfY2xpZW50czogY29uZmlnLm1heENsaWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4X2Nvbm5lY3Rpb25fdGltZTogY29uZmlnLm1heENvbm5lY3Rpb25UaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICoqaW1wb3J0YW50Kio6IG11c3QgbWF0Y2ggeW91ciBBdWRpb0NvbnRleHQgJiBTY3JpcHRQcm9jZXNzb3JcclxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVfcmF0ZTogMTYwMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtfc2l6ZTogNDA5NixcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNDb25uZWN0ZWQ6IHRydWUgfSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3cy5vbm1lc3NhZ2UgPSBlID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRhdGEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBKU09OLnBhcnNlKGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobXNnLnR5cGUgPT09ICd0cmFuc2NyaXB0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgdHJhbnNjcmlwdDogcy50cmFuc2NyaXB0ICsgbXNnLnRleHQgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtc2cudHlwZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgZXJyb3I6IG1zZy5tZXNzYWdlIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICB3cy5vbmNsb3NlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGlzQ29ubmVjdGVkOiBmYWxzZSwgaXNUcmFuc2NyaWJpbmc6IGZhbHNlIH0pKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd3Mub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogJ1dlYlNvY2tldCBjb25uZWN0aW9uIGZhaWxlZCcgfSkpXHJcbiAgICAgICAgICAgIHRvYXN0KHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnQ29ubmVjdGlvbiBFcnJvcicsXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0ZhaWxlZCB0byBjb25uZWN0IHRvIFdoaXNwZXJMaXZlIHNlcnZlcicsXHJcbiAgICAgICAgICAgICAgICB2YXJpYW50OiAnZGVzdHJ1Y3RpdmUnLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtjb25maWcsIHRvYXN0XSlcclxuXHJcbiAgICBjb25zdCBtaWNSZWYgPSB1c2VSZWY8TWVkaWFTdHJlYW0gfCBudWxsPihudWxsKVxyXG4gICAgY29uc3Qgc3lzdGVtUmVmID0gdXNlUmVmPE1lZGlhU3RyZWFtIHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IGN0eFJlZiA9IHVzZVJlZjxBdWRpb0NvbnRleHQgfCBudWxsPihudWxsKVxyXG4gICAgY29uc3QgcHJvY2Vzc29yUmVmID0gdXNlUmVmPFNjcmlwdFByb2Nlc3Nvck5vZGUgfCBudWxsPihudWxsKVxyXG5cclxuICAgIGNvbnN0IHN0YXJ0VHJhbnNjcmlwdGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICBpZiAoIXdzUmVmLmN1cnJlbnQgfHwgd3NSZWYuY3VycmVudC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiAnTm90IGNvbm5lY3RlZCcgfSkpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gMSkgcHJvbXB0IGZvciBzY3JlZW4rYXVkaW9cclxuICAgICAgICAgICAgbGV0IHN5c3RlbVN0cmVhbTogTWVkaWFTdHJlYW0gfCBudWxsID0gbnVsbFxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmF1ZGlvU291cmNlcz8uc3lzdGVtQXVkaW8pIHtcclxuICAgICAgICAgICAgICAgIHN5c3RlbVN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKHtcclxuICAgICAgICAgICAgICAgICAgICB2aWRlbzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgc3lzdGVtUmVmLmN1cnJlbnQgPSBzeXN0ZW1TdHJlYW1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMikgcHJvbXB0IGZvciBtaWNcclxuICAgICAgICAgICAgY29uc3QgbWljU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xyXG4gICAgICAgICAgICAgICAgYXVkaW86IHsgc2FtcGxlUmF0ZTogMTYwMDAsIGNoYW5uZWxDb3VudDogMSB9LFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBtaWNSZWYuY3VycmVudCA9IG1pY1N0cmVhbVxyXG5cclxuICAgICAgICAgICAgLy8gMykgYnVpbGQgYXVkaW8gZ3JhcGhcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gbmV3IEF1ZGlvQ29udGV4dCh7IHNhbXBsZVJhdGU6IDE2MDAwIH0pXHJcbiAgICAgICAgICAgIGN0eFJlZi5jdXJyZW50ID0gY3R4XHJcbiAgICAgICAgICAgIGNvbnN0IGRlc3QgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpXHJcblxyXG4gICAgICAgICAgICAvLyBtaWMgc291cmNlXHJcbiAgICAgICAgICAgIGNvbnN0IG1pY1NyYyA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShtaWNTdHJlYW0pXHJcbiAgICAgICAgICAgIG1pY1NyYy5jb25uZWN0KGRlc3QpXHJcblxyXG4gICAgICAgICAgICAvLyBvcHRpb25hbCBzeXN0ZW0gc291cmNlXHJcbiAgICAgICAgICAgIGxldCBzeXNTcmM6IE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlIHwgbnVsbCA9IG51bGxcclxuICAgICAgICAgICAgaWYgKHN5c3RlbVN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgc3lzU3JjID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN5c3RlbVN0cmVhbSlcclxuICAgICAgICAgICAgICAgIHN5c1NyYy5jb25uZWN0KGRlc3QpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDQpIGNyZWF0ZSBwcm9jZXNzb3JcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gY3R4LmNyZWF0ZVNjcmlwdFByb2Nlc3Nvcig0MDk2LCAxLCAxKVxyXG5cclxuICAgICAgICAgICAgLy8gd2lyZSBzb3VyY2VzIGludG8gcHJvY2Vzc29yXHJcbiAgICAgICAgICAgIG1pY1NyYy5jb25uZWN0KHByb2Nlc3NvcilcclxuICAgICAgICAgICAgaWYgKHN5c1NyYykgc3lzU3JjLmNvbm5lY3QocHJvY2Vzc29yKVxyXG5cclxuICAgICAgICAgICAgLy8gNSkgb24gZWFjaCBhdWRpbyBmcmFtZSwgY29udmVydCDihpIgSW50MTYg4oaSIHByZWZpeCBoZWFkZXIg4oaSIHNlbmRcclxuICAgICAgICAgICAgLy8gaW5zaWRlIHlvdXIgb25hdWRpb3Byb2Nlc3M6XHJcbiAgICAgICAgICAgIHByb2Nlc3Nvci5vbmF1ZGlvcHJvY2VzcyA9IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmxvYXQzMiA9IGUuaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnQxNiA9IG5ldyBJbnQxNkFycmF5KGZsb2F0MzIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmxvYXQzMi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGludDE2W2ldID0gTWF0aC5tYXgoLTMyNzY4LCBNYXRoLm1pbigzMjc2NywgZmxvYXQzMltpXSAqIDMyNzY3KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGJ1ZmZlciBpcyBhbHdheXMgZXhhY3RseSA0MDk2IHNhbXBsZXMgw5cgMiBieXRlcyA9IDgxOTIgYnl0ZXNcclxuICAgICAgICAgICAgICAgIGlmICh3c1JlZi5jdXJyZW50Py5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQuc2VuZChpbnQxNi5idWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgYSBwYWNrZXQgd2l0aCBhIDHigJFieXRlIOKAnGF1ZGlv4oCdIGhlYWRlciAoMHgwMSkgZm9sbG93ZWQgYnkgUENNXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwY20gPSBuZXcgVWludDhBcnJheShpbnQxNi5idWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gbmV3IFVpbnQ4QXJyYXkoMSArIHBjbS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcGFja2V0WzBdID0gMTsgICAgICAgICAgICAgICAvLyAxID0g4oCcYXVkaW8gY2h1bmvigJ1cclxuICAgICAgICAgICAgICAgIHBhY2tldC5zZXQocGNtLCAxKTtcclxuICAgICAgICAgICAgICAgIGlmICh3c1JlZi5jdXJyZW50Py5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQuc2VuZChwYWNrZXQuYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIDYpIGtpY2sgaXQgb2ZmXHJcbiAgICAgICAgICAgIHByb2Nlc3Nvci5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbilcclxuICAgICAgICAgICAgcHJvY2Vzc29yUmVmLmN1cnJlbnQgPSBwcm9jZXNzb3JcclxuXHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNUcmFuc2NyaWJpbmc6IHRydWUgfSkpXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogYEZhaWxlZCB0byBzdGFydCB0cmFuc2NyaXB0aW9uOiAke2Vyci5tZXNzYWdlfWAgfSkpXHJcbiAgICAgICAgICAgIHRvYXN0KHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnVHJhbnNjcmlwdGlvbiBFcnJvcicsXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZXJyLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICB2YXJpYW50OiAnZGVzdHJ1Y3RpdmUnLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtjb25maWcsIHRvYXN0XSlcclxuXHJcbiAgICBjb25zdCBzdG9wVHJhbnNjcmlwdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAod3NSZWYuY3VycmVudD8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgLy8gMHgwMiA9IOKAnGVuZCBvZiBzdHJlYW3igJ1cclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudC5zZW5kKG5ldyBVaW50OEFycmF5KFsyXSkuYnVmZmVyKTtcclxuICAgICAgICAgICAgLy8gTm93IHdhaXQgZm9yIHRoZSBzZXJ2ZXIgdG8gc2VuZCB0aGUgZmluYWwgdHJhbnNjcmlwdCBhbmQgY2xvc2VcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvY2FsbHkgdGVhciBkb3duIHlvdXIgYXVkaW8gZ3JhcGggaW1tZWRpYXRlbHk6XHJcbiAgICAgICAgaWYgKHByb2Nlc3NvclJlZi5jdXJyZW50KSB7IHByb2Nlc3NvclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTsgcHJvY2Vzc29yUmVmLmN1cnJlbnQgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKG1pY1JlZi5jdXJyZW50KSB7IG1pY1JlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSk7IG1pY1JlZi5jdXJyZW50ID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChzeXN0ZW1SZWYuY3VycmVudCkgeyBzeXN0ZW1SZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKHQgPT4gdC5zdG9wKCkpOyBzeXN0ZW1SZWYuY3VycmVudCA9IG51bGw7IH1cclxuICAgICAgICBpZiAoY3R4UmVmLmN1cnJlbnQpIHsgY3R4UmVmLmN1cnJlbnQuY2xvc2UoKTsgY3R4UmVmLmN1cnJlbnQgPSBudWxsOyB9XHJcblxyXG4gICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNUcmFuc2NyaWJpbmc6IGZhbHNlIH0pKTtcclxuICAgIH0sIFtdKTtcclxuXHJcblxyXG4gICAgY29uc3QgZGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAod3NSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50LmNsb3NlKClcclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudCA9IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RvcFRyYW5zY3JpcHRpb24oKVxyXG4gICAgICAgIHNldFN0YXRlKHsgaXNDb25uZWN0ZWQ6IGZhbHNlLCBpc1RyYW5zY3JpYmluZzogZmFsc2UsIHRyYW5zY3JpcHQ6ICcnLCBlcnJvcjogbnVsbCB9KVxyXG4gICAgfSwgW3N0b3BUcmFuc2NyaXB0aW9uXSlcclxuXHJcbiAgICBjb25zdCBjbGVhclRyYW5zY3JpcHQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCB0cmFuc2NyaXB0OiAnJyB9KSlcclxuICAgIH0sIFtdKVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgY29ubmVjdCxcclxuICAgICAgICBzdGFydFRyYW5zY3JpcHRpb24sXHJcbiAgICAgICAgc3RvcFRyYW5zY3JpcHRpb24sXHJcbiAgICAgICAgZGlzY29ubmVjdCxcclxuICAgICAgICBjbGVhclRyYW5zY3JpcHQsXHJcbiAgICAgICAgd3NSZWYsXHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VUb2FzdCIsInVzZVdoaXNwZXJMaXZlIiwiY29uZmlnIiwic3RhdGUiLCJzZXRTdGF0ZSIsImlzQ29ubmVjdGVkIiwiaXNUcmFuc2NyaWJpbmciLCJ0cmFuc2NyaXB0IiwiZXJyb3IiLCJ3c1JlZiIsInVpZFJlZiIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsInRvYXN0IiwiY29ubmVjdCIsImN1cnJlbnQiLCJjbG9zZSIsInMiLCJ3cyIsIldlYlNvY2tldCIsInNlcnZlclVybCIsInBvcnQiLCJiaW5hcnlUeXBlIiwib25vcGVuIiwidGFza05hbWUiLCJ0cmFuc2xhdGUiLCJzZW5kIiwiSlNPTiIsInN0cmluZ2lmeSIsInRhc2siLCJ1aWQiLCJsYW5ndWFnZSIsIm1vZGVsIiwidmFkIiwic2F2ZV9yZWNvcmRpbmciLCJzYXZlUmVjb3JkaW5nIiwib3V0cHV0X2ZpbGVuYW1lIiwib3V0cHV0RmlsZW5hbWUiLCJtYXhfY2xpZW50cyIsIm1heENsaWVudHMiLCJtYXhfY29ubmVjdGlvbl90aW1lIiwibWF4Q29ubmVjdGlvblRpbWUiLCJzYW1wbGVfcmF0ZSIsImNodW5rX3NpemUiLCJvbm1lc3NhZ2UiLCJlIiwiZGF0YSIsIm1zZyIsInBhcnNlIiwidHlwZSIsInRleHQiLCJtZXNzYWdlIiwib25jbG9zZSIsIm9uZXJyb3IiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwidmFyaWFudCIsIm1pY1JlZiIsInN5c3RlbVJlZiIsImN0eFJlZiIsInByb2Nlc3NvclJlZiIsInN0YXJ0VHJhbnNjcmlwdGlvbiIsInJlYWR5U3RhdGUiLCJPUEVOIiwic3lzdGVtU3RyZWFtIiwiYXVkaW9Tb3VyY2VzIiwic3lzdGVtQXVkaW8iLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXREaXNwbGF5TWVkaWEiLCJ2aWRlbyIsImF1ZGlvIiwibWljU3RyZWFtIiwiZ2V0VXNlck1lZGlhIiwic2FtcGxlUmF0ZSIsImNoYW5uZWxDb3VudCIsImN0eCIsIkF1ZGlvQ29udGV4dCIsImRlc3QiLCJjcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uIiwibWljU3JjIiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJzeXNTcmMiLCJwcm9jZXNzb3IiLCJjcmVhdGVTY3JpcHRQcm9jZXNzb3IiLCJvbmF1ZGlvcHJvY2VzcyIsImZsb2F0MzIiLCJpbnB1dEJ1ZmZlciIsImdldENoYW5uZWxEYXRhIiwiaW50MTYiLCJJbnQxNkFycmF5IiwibGVuZ3RoIiwiaSIsIm1heCIsIm1pbiIsImJ1ZmZlciIsInBjbSIsIlVpbnQ4QXJyYXkiLCJwYWNrZXQiLCJzZXQiLCJkZXN0aW5hdGlvbiIsImVyciIsInN0b3BUcmFuc2NyaXB0aW9uIiwiZGlzY29ubmVjdCIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0Iiwic3RvcCIsImNsZWFyVHJhbnNjcmlwdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-whisper-live.ts\n"));

/***/ })

});