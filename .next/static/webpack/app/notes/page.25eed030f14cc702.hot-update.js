"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/notes/page",{

/***/ "(app-pages-browser)/./src/hooks/use-whisper-live.ts":
/*!***************************************!*\
  !*** ./src/hooks/use-whisper-live.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWhisperLive: () => (/* binding */ useWhisperLive)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/hooks/use-toast */ \"(app-pages-browser)/./src/hooks/use-toast.ts\");\n/* __next_internal_client_entry_do_not_use__ useWhisperLive auto */ \n\nfunction useWhisperLive(config) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        isTranscribing: false,\n        transcript: '',\n        error: null\n    });\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const uidRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));\n    const { toast } = (0,_hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__.useToast)();\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[connect]\": ()=>{\n            console.log('[useWhisperLive]  connect()', config);\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            setState({\n                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                        ...s,\n                        error: null\n                    })\n            }[\"useWhisperLive.useCallback[connect]\"]);\n            const ws = new WebSocket(\"ws://\".concat(config.serverUrl, \":\").concat(config.port));\n            ws.binaryType = 'arraybuffer';\n            wsRef.current = ws;\n            ws.onopen = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    const taskName = config.translate ? 'translate' : 'transcribe';\n                    ws.send(JSON.stringify({\n                        task: taskName,\n                        uid: uidRef.current,\n                        language: config.language,\n                        model: config.model,\n                        vad: config.vad,\n                        save_recording: config.saveRecording,\n                        output_filename: config.outputFilename,\n                        max_clients: config.maxClients,\n                        max_connection_time: config.maxConnectionTime,\n                        // **important**: must match your AudioContext & ScriptProcessor\n                        sample_rate: 16000,\n                        chunk_size: 4096\n                    }));\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: true\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onmessage = ({\n                \"useWhisperLive.useCallback[connect]\": (e)=>{\n                    console.log('[WS message]', e.data);\n                    if (typeof e.data === 'string') {\n                        const msg = JSON.parse(e.data);\n                        if (msg.type === 'transcript') {\n                            setState({\n                                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                        ...s,\n                                        transcript: s.transcript + msg.text\n                                    })\n                            }[\"useWhisperLive.useCallback[connect]\"]);\n                        } else if (msg.type === 'error') {\n                            setState({\n                                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                        ...s,\n                                        error: msg.message\n                                    })\n                            }[\"useWhisperLive.useCallback[connect]\"]);\n                        }\n                    }\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onclose = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: false,\n                                isTranscribing: false\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onerror = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                error: 'WebSocket connection failed'\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                    toast({\n                        title: 'Connection Error',\n                        description: 'Failed to connect to WhisperLive server',\n                        variant: 'destructive'\n                    });\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n        }\n    }[\"useWhisperLive.useCallback[connect]\"], [\n        config,\n        toast\n    ]);\n    const micRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const systemRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ctxRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const processorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const startTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[startTranscription]\": async ()=>{\n            if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: 'Not connected'\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                return;\n            }\n            try {\n                var _config_audioSources;\n                // 1) Screen + system audio (if enabled)\n                let systemStream = null;\n                if ((_config_audioSources = config.audioSources) === null || _config_audioSources === void 0 ? void 0 : _config_audioSources.systemAudio) {\n                    systemStream = await navigator.mediaDevices.getDisplayMedia({\n                        video: true,\n                        audio: true\n                    });\n                    systemRef.current = systemStream;\n                }\n                // 2) Microphone\n                const micStream = await navigator.mediaDevices.getUserMedia({\n                    audio: {\n                        sampleRate: 16000,\n                        channelCount: 1\n                    }\n                });\n                micRef.current = micStream;\n                // 3) Build an AudioContext + a single destination to mix into\n                const ctx = new AudioContext({\n                    sampleRate: 16000\n                });\n                ctxRef.current = ctx;\n                const dest = ctx.createMediaStreamDestination();\n                // 4) Wire mic → dest\n                const micSrc = ctx.createMediaStreamSource(micStream);\n                micSrc.connect(dest);\n                // 5) Wire system audio → dest\n                if (systemStream) {\n                    const sysSrc = ctx.createMediaStreamSource(systemStream);\n                    sysSrc.connect(dest);\n                }\n                // 6) Instead of wiring mic+sys directly to the processor, we\n                //    take the mixed dest.stream and hook that up:\n                const mixedSrc = ctx.createMediaStreamSource(dest.stream);\n                // 7) Create your ScriptProcessor (bufferSize=4096, mono in/out)\n                const processor = ctx.createScriptProcessor(4096, 1, 1);\n                // 8) Wire the mixed audio into the processor\n                mixedSrc.connect(processor);\n                // 9) On each onaudioprocess, build exactly one packet\n                processor.onaudioprocess = ({\n                    \"useWhisperLive.useCallback[startTranscription]\": (e)=>{\n                        var _wsRef_current;\n                        const float32 = e.inputBuffer.getChannelData(0);\n                        const int16 = new Int16Array(float32.length);\n                        for(let i = 0; i < float32.length; i++){\n                            int16[i] = Math.max(-32768, Math.min(32767, float32[i] * 32767));\n                        }\n                        if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                            wsRef.current.send(int16.buffer);\n                        }\n                    }\n                })[\"useWhisperLive.useCallback[startTranscription]\"];\n                // 10) Start it\n                processor.connect(ctx.destination);\n                processorRef.current = processor;\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            isTranscribing: true\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n            } catch (err) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: \"Failed to start transcription: \".concat(err.message)\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                toast({\n                    title: 'Transcription Error',\n                    description: err.message,\n                    variant: 'destructive'\n                });\n            }\n        }\n    }[\"useWhisperLive.useCallback[startTranscription]\"], [\n        config,\n        toast\n    ]);\n    const stopTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[stopTranscription]\": ()=>{\n            var _wsRef_current;\n            if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                // zero‑length ArrayBuffer signals “please flush & finish”\n                wsRef.current.send(new ArrayBuffer(0));\n            }\n            // tear down audio graph immediately\n            if (processorRef.current) {\n                processorRef.current.disconnect();\n                processorRef.current = null;\n            }\n            if (micRef.current) {\n                micRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                micRef.current = null;\n            }\n            if (systemRef.current) {\n                systemRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                systemRef.current = null;\n            }\n            if (ctxRef.current) {\n                ctxRef.current.close();\n                ctxRef.current = null;\n            }\n            setState({\n                \"useWhisperLive.useCallback[stopTranscription]\": (s)=>({\n                        ...s,\n                        isTranscribing: false\n                    })\n            }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n        }\n    }[\"useWhisperLive.useCallback[stopTranscription]\"], []);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[disconnect]\": ()=>{\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            stopTranscription();\n            setState({\n                isConnected: false,\n                isTranscribing: false,\n                transcript: '',\n                error: null\n            });\n        }\n    }[\"useWhisperLive.useCallback[disconnect]\"], [\n        stopTranscription\n    ]);\n    const clearTranscript = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[clearTranscript]\": ()=>{\n            setState({\n                \"useWhisperLive.useCallback[clearTranscript]\": (s)=>({\n                        ...s,\n                        transcript: ''\n                    })\n            }[\"useWhisperLive.useCallback[clearTranscript]\"]);\n        }\n    }[\"useWhisperLive.useCallback[clearTranscript]\"], []);\n    return {\n        state,\n        connect,\n        startTranscription,\n        stopTranscription,\n        disconnect,\n        clearTranscript,\n        wsRef\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utd2hpc3Blci1saXZlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7b0VBRXFEO0FBQ1Q7QUF1QnJDLFNBQVNJLGVBQWVDLE1BQXlCO0lBQ3BELE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHUCwrQ0FBUUEsQ0FBbUI7UUFDakRRLGFBQWE7UUFDYkMsZ0JBQWdCO1FBQ2hCQyxZQUFZO1FBQ1pDLE9BQU87SUFDWDtJQUVBLE1BQU1DLFFBQVFYLDZDQUFNQSxDQUFtQjtJQUN2QyxNQUFNWSxTQUFTWiw2Q0FBTUEsQ0FDakIsT0FBT2EsV0FBVyxlQUFlQSxPQUFPQyxVQUFVLEdBQzVDRCxPQUFPQyxVQUFVLEtBQ2pCQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxLQUFLLENBQUM7SUFFM0MsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR2pCLDBEQUFRQTtJQUUxQixNQUFNa0IsVUFBVW5CLGtEQUFXQTsrQ0FBQztZQUN4Qm9CLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0JsQjtZQUMzQyxJQUFJTyxNQUFNWSxPQUFPLEVBQUU7Z0JBQ2ZaLE1BQU1ZLE9BQU8sQ0FBQ0MsS0FBSztnQkFDbkJiLE1BQU1ZLE9BQU8sR0FBRztZQUNwQjtZQUNBakI7dURBQVNtQixDQUFBQSxJQUFNO3dCQUFFLEdBQUdBLENBQUM7d0JBQUVmLE9BQU87b0JBQUs7O1lBRW5DLE1BQU1nQixLQUFLLElBQUlDLFVBQVUsUUFBNEJ2QixPQUFwQkEsT0FBT3dCLFNBQVMsRUFBQyxLQUFlLE9BQVp4QixPQUFPeUIsSUFBSTtZQUNoRUgsR0FBR0ksVUFBVSxHQUFHO1lBQ2hCbkIsTUFBTVksT0FBTyxHQUFHRztZQUVoQkEsR0FBR0ssTUFBTTt1REFBRztvQkFDUixNQUFNQyxXQUFXNUIsT0FBTzZCLFNBQVMsR0FBRyxjQUFjO29CQUNsRFAsR0FBR1EsSUFBSSxDQUNIQyxLQUFLQyxTQUFTLENBQUM7d0JBQ1hDLE1BQU1MO3dCQUNO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S2hELFVBQVUzQyxPQUFPLEdBQUc7WUFBTTtZQUN6RyxJQUFJNEMsT0FBTzVDLE9BQU8sRUFBRTtnQkFBRTRDLE9BQU81QyxPQUFPLENBQUNDLEtBQUs7Z0JBQUkyQyxPQUFPNUMsT0FBTyxHQUFHO1lBQU07WUFFckVqQjtpRUFBU21CLENBQUFBLElBQU07d0JBQUUsR0FBR0EsQ0FBQzt3QkFBRWpCLGdCQUFnQjtvQkFBTTs7UUFDakQ7d0RBQUcsRUFBRTtJQUdMLE1BQU1zRyxhQUFhN0csa0RBQVdBO2tEQUFDO1lBQzNCLElBQUlVLE1BQU1ZLE9BQU8sRUFBRTtnQkFDZlosTUFBTVksT0FBTyxDQUFDQyxLQUFLO2dCQUNuQmIsTUFBTVksT0FBTyxHQUFHO1lBQ3BCO1lBQ0FxRjtZQUNBdEcsU0FBUztnQkFBRUMsYUFBYTtnQkFBT0MsZ0JBQWdCO2dCQUFPQyxZQUFZO2dCQUFJQyxPQUFPO1lBQUs7UUFDdEY7aURBQUc7UUFBQ2tHO0tBQWtCO0lBRXRCLE1BQU1PLGtCQUFrQmxILGtEQUFXQTt1REFBQztZQUNoQ0s7K0RBQVNtQixDQUFBQSxJQUFNO3dCQUFFLEdBQUdBLENBQUM7d0JBQUVoQixZQUFZO29CQUFHOztRQUMxQztzREFBRyxFQUFFO0lBRUwsT0FBTztRQUNISjtRQUNBZTtRQUNBaUQ7UUFDQXVDO1FBQ0FFO1FBQ0FLO1FBQ0F4RztJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIkU6XFxBaXZvaWNldG90ZXh0XFxzcmNcXGhvb2tzXFx1c2Utd2hpc3Blci1saXZlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgdXNlVG9hc3QgfSBmcm9tICdAL2hvb2tzL3VzZS10b2FzdCdcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2hpc3BlckxpdmVDb25maWcge1xyXG4gICAgc2VydmVyVXJsOiBzdHJpbmdcclxuICAgIHBvcnQ6IG51bWJlclxyXG4gICAgbGFuZ3VhZ2U6IHN0cmluZ1xyXG4gICAgdHJhbnNsYXRlOiBib29sZWFuXHJcbiAgICBtb2RlbDogc3RyaW5nXHJcbiAgICB2YWQ6IGJvb2xlYW5cclxuICAgIHNhdmVSZWNvcmRpbmc6IGJvb2xlYW5cclxuICAgIG91dHB1dEZpbGVuYW1lOiBzdHJpbmdcclxuICAgIG1heENsaWVudHM6IG51bWJlclxyXG4gICAgbWF4Q29ubmVjdGlvblRpbWU6IG51bWJlclxyXG4gICAgYXVkaW9Tb3VyY2VzPzogeyBtaWNyb3Bob25lOiBib29sZWFuOyBzeXN0ZW1BdWRpbzogYm9vbGVhbiB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBXaGlzcGVyTGl2ZVN0YXRlIHtcclxuICAgIGlzQ29ubmVjdGVkOiBib29sZWFuXHJcbiAgICBpc1RyYW5zY3JpYmluZzogYm9vbGVhblxyXG4gICAgdHJhbnNjcmlwdDogc3RyaW5nXHJcbiAgICBlcnJvcjogc3RyaW5nIHwgbnVsbFxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlV2hpc3BlckxpdmUoY29uZmlnOiBXaGlzcGVyTGl2ZUNvbmZpZykge1xyXG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxXaGlzcGVyTGl2ZVN0YXRlPih7XHJcbiAgICAgICAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzVHJhbnNjcmliaW5nOiBmYWxzZSxcclxuICAgICAgICB0cmFuc2NyaXB0OiAnJyxcclxuICAgICAgICBlcnJvcjogbnVsbCxcclxuICAgIH0pXHJcblxyXG4gICAgY29uc3Qgd3NSZWYgPSB1c2VSZWY8V2ViU29ja2V0IHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IHVpZFJlZiA9IHVzZVJlZihcclxuICAgICAgICB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRFxyXG4gICAgICAgICAgICA/IGNyeXB0by5yYW5kb21VVUlEKClcclxuICAgICAgICAgICAgOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxcclxuICAgIClcclxuICAgIGNvbnN0IHsgdG9hc3QgfSA9IHVzZVRvYXN0KClcclxuXHJcbiAgICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbdXNlV2hpc3BlckxpdmVdICBjb25uZWN0KCknLCBjb25maWcpO1xyXG4gICAgICAgIGlmICh3c1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiBudWxsIH0pKVxyXG5cclxuICAgICAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQoYHdzOi8vJHtjb25maWcuc2VydmVyVXJsfToke2NvbmZpZy5wb3J0fWApXHJcbiAgICAgICAgd3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcclxuICAgICAgICB3c1JlZi5jdXJyZW50ID0gd3NcclxuXHJcbiAgICAgICAgd3Mub25vcGVuID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YXNrTmFtZSA9IGNvbmZpZy50cmFuc2xhdGUgPyAndHJhbnNsYXRlJyA6ICd0cmFuc2NyaWJlJ1xyXG4gICAgICAgICAgICB3cy5zZW5kKFxyXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2s6IHRhc2tOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHVpZDogdWlkUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IGNvbmZpZy5sYW5ndWFnZSxcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbDogY29uZmlnLm1vZGVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhZDogY29uZmlnLnZhZCxcclxuICAgICAgICAgICAgICAgICAgICBzYXZlX3JlY29yZGluZzogY29uZmlnLnNhdmVSZWNvcmRpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0X2ZpbGVuYW1lOiBjb25maWcub3V0cHV0RmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4X2NsaWVudHM6IGNvbmZpZy5tYXhDbGllbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heF9jb25uZWN0aW9uX3RpbWU6IGNvbmZpZy5tYXhDb25uZWN0aW9uVGltZSxcclxuICAgICAgICAgICAgICAgICAgICAvLyAqKmltcG9ydGFudCoqOiBtdXN0IG1hdGNoIHlvdXIgQXVkaW9Db250ZXh0ICYgU2NyaXB0UHJvY2Vzc29yXHJcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlX3JhdGU6IDE2MDAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGNodW5rX3NpemU6IDQwOTYsXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGlzQ29ubmVjdGVkOiB0cnVlIH0pKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd3Mub25tZXNzYWdlID0gZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbV1MgbWVzc2FnZV0nLCBlLmRhdGEpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGUuZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmIChtc2cudHlwZSA9PT0gJ3RyYW5zY3JpcHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCB0cmFuc2NyaXB0OiBzLnRyYW5zY3JpcHQgKyBtc2cudGV4dCB9KSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1zZy50eXBlID09PSAnZXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogbXNnLm1lc3NhZ2UgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIHdzLm9uY2xvc2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNDb25uZWN0ZWQ6IGZhbHNlLCBpc1RyYW5zY3JpYmluZzogZmFsc2UgfSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3cy5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiAnV2ViU29ja2V0IGNvbm5lY3Rpb24gZmFpbGVkJyB9KSlcclxuICAgICAgICAgICAgdG9hc3Qoe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdDb25uZWN0aW9uIEVycm9yJyxcclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmFpbGVkIHRvIGNvbm5lY3QgdG8gV2hpc3BlckxpdmUgc2VydmVyJyxcclxuICAgICAgICAgICAgICAgIHZhcmlhbnQ6ICdkZXN0cnVjdGl2ZScsXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2NvbmZpZywgdG9hc3RdKVxyXG5cclxuICAgIGNvbnN0IG1pY1JlZiA9IHVzZVJlZjxNZWRpYVN0cmVhbSB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCBzeXN0ZW1SZWYgPSB1c2VSZWY8TWVkaWFTdHJlYW0gfCBudWxsPihudWxsKVxyXG4gICAgY29uc3QgY3R4UmVmID0gdXNlUmVmPEF1ZGlvQ29udGV4dCB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCBwcm9jZXNzb3JSZWYgPSB1c2VSZWY8U2NyaXB0UHJvY2Vzc29yTm9kZSB8IG51bGw+KG51bGwpXHJcblxyXG4gICAgY29uc3Qgc3RhcnRUcmFuc2NyaXB0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGlmICghd3NSZWYuY3VycmVudCB8fCB3c1JlZi5jdXJyZW50LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgZXJyb3I6ICdOb3QgY29ubmVjdGVkJyB9KSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIDEpIFNjcmVlbiArIHN5c3RlbSBhdWRpbyAoaWYgZW5hYmxlZClcclxuICAgICAgICAgICAgbGV0IHN5c3RlbVN0cmVhbTogTWVkaWFTdHJlYW0gfCBudWxsID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5hdWRpb1NvdXJjZXM/LnN5c3RlbUF1ZGlvKSB7XHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1TdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlkZW86IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHN5c3RlbVJlZi5jdXJyZW50ID0gc3lzdGVtU3RyZWFtO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAyKSBNaWNyb3Bob25lXHJcbiAgICAgICAgICAgIGNvbnN0IG1pY1N0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcclxuICAgICAgICAgICAgICAgIGF1ZGlvOiB7IHNhbXBsZVJhdGU6IDE2MDAwLCBjaGFubmVsQ291bnQ6IDEgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1pY1JlZi5jdXJyZW50ID0gbWljU3RyZWFtO1xyXG5cclxuICAgICAgICAgICAgLy8gMykgQnVpbGQgYW4gQXVkaW9Db250ZXh0ICsgYSBzaW5nbGUgZGVzdGluYXRpb24gdG8gbWl4IGludG9cclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gbmV3IEF1ZGlvQ29udGV4dCh7IHNhbXBsZVJhdGU6IDE2MDAwIH0pO1xyXG4gICAgICAgICAgICBjdHhSZWYuY3VycmVudCA9IGN0eDtcclxuICAgICAgICAgICAgY29uc3QgZGVzdCA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICAvLyA0KSBXaXJlIG1pYyDihpIgZGVzdFxyXG4gICAgICAgICAgICBjb25zdCBtaWNTcmMgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobWljU3RyZWFtKTtcclxuICAgICAgICAgICAgbWljU3JjLmNvbm5lY3QoZGVzdCk7XHJcblxyXG4gICAgICAgICAgICAvLyA1KSBXaXJlIHN5c3RlbSBhdWRpbyDihpIgZGVzdFxyXG4gICAgICAgICAgICBpZiAoc3lzdGVtU3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzeXNTcmMgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3lzdGVtU3RyZWFtKTtcclxuICAgICAgICAgICAgICAgIHN5c1NyYy5jb25uZWN0KGRlc3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyA2KSBJbnN0ZWFkIG9mIHdpcmluZyBtaWMrc3lzIGRpcmVjdGx5IHRvIHRoZSBwcm9jZXNzb3IsIHdlXHJcbiAgICAgICAgICAgIC8vICAgIHRha2UgdGhlIG1peGVkIGRlc3Quc3RyZWFtIGFuZCBob29rIHRoYXQgdXA6XHJcbiAgICAgICAgICAgIGNvbnN0IG1peGVkU3JjID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKGRlc3Quc3RyZWFtKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDcpIENyZWF0ZSB5b3VyIFNjcmlwdFByb2Nlc3NvciAoYnVmZmVyU2l6ZT00MDk2LCBtb25vIGluL291dClcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gY3R4LmNyZWF0ZVNjcmlwdFByb2Nlc3Nvcig0MDk2LCAxLCAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDgpIFdpcmUgdGhlIG1peGVkIGF1ZGlvIGludG8gdGhlIHByb2Nlc3NvclxyXG4gICAgICAgICAgICBtaXhlZFNyYy5jb25uZWN0KHByb2Nlc3Nvcik7XHJcblxyXG4gICAgICAgICAgICAvLyA5KSBPbiBlYWNoIG9uYXVkaW9wcm9jZXNzLCBidWlsZCBleGFjdGx5IG9uZSBwYWNrZXRcclxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uYXVkaW9wcm9jZXNzID0gZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmbG9hdDMyID0gZS5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGludDE2ID0gbmV3IEludDE2QXJyYXkoZmxvYXQzMi5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbG9hdDMyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50MTZbaV0gPSBNYXRoLm1heCgtMzI3NjgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKDMyNzY3LCBmbG9hdDMyW2ldICogMzI3NjcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh3c1JlZi5jdXJyZW50Py5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQuc2VuZChpbnQxNi5idWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gMTApIFN0YXJ0IGl0XHJcbiAgICAgICAgICAgIHByb2Nlc3Nvci5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgICAgIHByb2Nlc3NvclJlZi5jdXJyZW50ID0gcHJvY2Vzc29yO1xyXG5cclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBpc1RyYW5zY3JpYmluZzogdHJ1ZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiBgRmFpbGVkIHRvIHN0YXJ0IHRyYW5zY3JpcHRpb246ICR7ZXJyLm1lc3NhZ2V9YCB9KSk7XHJcbiAgICAgICAgICAgIHRvYXN0KHsgdGl0bGU6ICdUcmFuc2NyaXB0aW9uIEVycm9yJywgZGVzY3JpcHRpb246IGVyci5tZXNzYWdlLCB2YXJpYW50OiAnZGVzdHJ1Y3RpdmUnIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtjb25maWcsIHRvYXN0XSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHN0b3BUcmFuc2NyaXB0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGlmICh3c1JlZi5jdXJyZW50Py5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICAvLyB6ZXJv4oCRbGVuZ3RoIEFycmF5QnVmZmVyIHNpZ25hbHMg4oCccGxlYXNlIGZsdXNoICYgZmluaXNo4oCdXHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQuc2VuZChuZXcgQXJyYXlCdWZmZXIoMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGVhciBkb3duIGF1ZGlvIGdyYXBoIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgaWYgKHByb2Nlc3NvclJlZi5jdXJyZW50KSB7IHByb2Nlc3NvclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTsgcHJvY2Vzc29yUmVmLmN1cnJlbnQgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKG1pY1JlZi5jdXJyZW50KSB7IG1pY1JlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSk7IG1pY1JlZi5jdXJyZW50ID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChzeXN0ZW1SZWYuY3VycmVudCkgeyBzeXN0ZW1SZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKHQgPT4gdC5zdG9wKCkpOyBzeXN0ZW1SZWYuY3VycmVudCA9IG51bGw7IH1cclxuICAgICAgICBpZiAoY3R4UmVmLmN1cnJlbnQpIHsgY3R4UmVmLmN1cnJlbnQuY2xvc2UoKTsgY3R4UmVmLmN1cnJlbnQgPSBudWxsOyB9XHJcblxyXG4gICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNUcmFuc2NyaWJpbmc6IGZhbHNlIH0pKTtcclxuICAgIH0sIFtdKTtcclxuXHJcblxyXG4gICAgY29uc3QgZGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAod3NSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50LmNsb3NlKClcclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudCA9IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RvcFRyYW5zY3JpcHRpb24oKVxyXG4gICAgICAgIHNldFN0YXRlKHsgaXNDb25uZWN0ZWQ6IGZhbHNlLCBpc1RyYW5zY3JpYmluZzogZmFsc2UsIHRyYW5zY3JpcHQ6ICcnLCBlcnJvcjogbnVsbCB9KVxyXG4gICAgfSwgW3N0b3BUcmFuc2NyaXB0aW9uXSlcclxuXHJcbiAgICBjb25zdCBjbGVhclRyYW5zY3JpcHQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCB0cmFuc2NyaXB0OiAnJyB9KSlcclxuICAgIH0sIFtdKVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgY29ubmVjdCxcclxuICAgICAgICBzdGFydFRyYW5zY3JpcHRpb24sXHJcbiAgICAgICAgc3RvcFRyYW5zY3JpcHRpb24sXHJcbiAgICAgICAgZGlzY29ubmVjdCxcclxuICAgICAgICBjbGVhclRyYW5zY3JpcHQsXHJcbiAgICAgICAgd3NSZWYsXHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VUb2FzdCIsInVzZVdoaXNwZXJMaXZlIiwiY29uZmlnIiwic3RhdGUiLCJzZXRTdGF0ZSIsImlzQ29ubmVjdGVkIiwiaXNUcmFuc2NyaWJpbmciLCJ0cmFuc2NyaXB0IiwiZXJyb3IiLCJ3c1JlZiIsInVpZFJlZiIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsInRvYXN0IiwiY29ubmVjdCIsImNvbnNvbGUiLCJsb2ciLCJjdXJyZW50IiwiY2xvc2UiLCJzIiwid3MiLCJXZWJTb2NrZXQiLCJzZXJ2ZXJVcmwiLCJwb3J0IiwiYmluYXJ5VHlwZSIsIm9ub3BlbiIsInRhc2tOYW1lIiwidHJhbnNsYXRlIiwic2VuZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0YXNrIiwidWlkIiwibGFuZ3VhZ2UiLCJtb2RlbCIsInZhZCIsInNhdmVfcmVjb3JkaW5nIiwic2F2ZVJlY29yZGluZyIsIm91dHB1dF9maWxlbmFtZSIsIm91dHB1dEZpbGVuYW1lIiwibWF4X2NsaWVudHMiLCJtYXhDbGllbnRzIiwibWF4X2Nvbm5lY3Rpb25fdGltZSIsIm1heENvbm5lY3Rpb25UaW1lIiwic2FtcGxlX3JhdGUiLCJjaHVua19zaXplIiwib25tZXNzYWdlIiwiZSIsImRhdGEiLCJtc2ciLCJwYXJzZSIsInR5cGUiLCJ0ZXh0IiwibWVzc2FnZSIsIm9uY2xvc2UiLCJvbmVycm9yIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInZhcmlhbnQiLCJtaWNSZWYiLCJzeXN0ZW1SZWYiLCJjdHhSZWYiLCJwcm9jZXNzb3JSZWYiLCJzdGFydFRyYW5zY3JpcHRpb24iLCJyZWFkeVN0YXRlIiwiT1BFTiIsInN5c3RlbVN0cmVhbSIsImF1ZGlvU291cmNlcyIsInN5c3RlbUF1ZGlvIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0RGlzcGxheU1lZGlhIiwidmlkZW8iLCJhdWRpbyIsIm1pY1N0cmVhbSIsImdldFVzZXJNZWRpYSIsInNhbXBsZVJhdGUiLCJjaGFubmVsQ291bnQiLCJjdHgiLCJBdWRpb0NvbnRleHQiLCJkZXN0IiwiY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbiIsIm1pY1NyYyIsImNyZWF0ZU1lZGlhU3RyZWFtU291cmNlIiwic3lzU3JjIiwibWl4ZWRTcmMiLCJzdHJlYW0iLCJwcm9jZXNzb3IiLCJjcmVhdGVTY3JpcHRQcm9jZXNzb3IiLCJvbmF1ZGlvcHJvY2VzcyIsImZsb2F0MzIiLCJpbnB1dEJ1ZmZlciIsImdldENoYW5uZWxEYXRhIiwiaW50MTYiLCJJbnQxNkFycmF5IiwibGVuZ3RoIiwiaSIsIm1heCIsIm1pbiIsImJ1ZmZlciIsImRlc3RpbmF0aW9uIiwiZXJyIiwic3RvcFRyYW5zY3JpcHRpb24iLCJBcnJheUJ1ZmZlciIsImRpc2Nvbm5lY3QiLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidCIsInN0b3AiLCJjbGVhclRyYW5zY3JpcHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-whisper-live.ts\n"));

/***/ })

});