"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/notes/page",{

/***/ "(app-pages-browser)/./src/hooks/use-whisper-live.ts":
/*!***************************************!*\
  !*** ./src/hooks/use-whisper-live.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWhisperLive: () => (/* binding */ useWhisperLive)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/hooks/use-toast */ \"(app-pages-browser)/./src/hooks/use-toast.ts\");\n/* __next_internal_client_entry_do_not_use__ useWhisperLive auto */ \n\nfunction useWhisperLive(config) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        isTranscribing: false,\n        transcript: '',\n        error: null\n    });\n    const [audioData, setAudioData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [dataUpdateTrigger, setDataUpdateTrigger] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const uidRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));\n    const { toast } = (0,_hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__.useToast)();\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[connect]\": ()=>{\n            console.log('[useWhisperLive]  connect()', config);\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            // 1) create AudioContext now so we can hand its real sampleRate to the server\n            const ctx = new AudioContext({\n                sampleRate: 16000\n            });\n            ctxRef.current = ctx;\n            const actualSampleRate = ctx.sampleRate;\n            console.log('[useWhisperLive] audioContext.sampleRate =', actualSampleRate);\n            setState({\n                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                        ...s,\n                        error: null\n                    })\n            }[\"useWhisperLive.useCallback[connect]\"]);\n            const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\n            const ws = new WebSocket(\"\".concat(protocol, \"://\").concat(config.serverUrl, \":\").concat(config.port));\n            ws.binaryType = 'arraybuffer';\n            wsRef.current = ws;\n            ws.onopen = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    console.log('[useWhisperLive] ðŸŸ¢ WebSocket OPEN');\n                    const taskName = config.translate ? 'translate' : 'transcribe';\n                    ws.send(JSON.stringify({\n                        task: taskName,\n                        uid: uidRef.current,\n                        language: config.language,\n                        model: config.model,\n                        vad: config.vad,\n                        save_recording: config.saveRecording,\n                        output_filename: config.outputFilename,\n                        max_clients: config.maxClients,\n                        max_connection_time: config.maxConnectionTime,\n                        // **important**: must match your AudioContext & ScriptProcessor\n                        sample_rate: actualSampleRate,\n                        chunk_size: 4096\n                    }));\n                    startTranscription();\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: true\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            // inside your connect()\n            ws.onmessage = ({\n                \"useWhisperLive.useCallback[connect]\": (e)=>{\n                    console.log('Raw WS Message:', e.data);\n                    if (typeof e.data !== 'string') return;\n                    const msg = JSON.parse(e.data);\n                    // ignore handshake\n                    if (msg.message === 'SERVER_READY') return;\n                    // errors\n                    if (msg.type === 'error') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    error: msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // oldâ€style partial/final (if you ever toggle that back on)\n                    if (msg.type === 'partial' || msg.type === 'transcript') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + msg.text\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    if (msg.type === 'final') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: false,\n                                    transcript: s.transcript + msg.text + '\\n'\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // â† NEW: handle the `segments` array\n                    if (Array.isArray(msg.segments)) {\n                        // pull every segment.text, concatenate, append\n                        console.log('[useWhisperLive] got segments â†’', msg.segments);\n                        const batch = msg.segments.map({\n                            \"useWhisperLive.useCallback[connect].batch\": (seg)=>seg.text\n                        }[\"useWhisperLive.useCallback[connect].batch\"]).join('');\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + batch\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // fallback to any stray `msg.message`\n                    if (msg.message && msg.message !== 'SERVER_READY') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                    }\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onclose = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: false,\n                                isTranscribing: false\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onerror = ({\n                \"useWhisperLive.useCallback[connect]\": (err)=>{\n                    console.warn('[useWhisperLive] WebSocket error (nonâ€‘fatal)', err);\n                // donâ€™t setState or toast here\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n        }\n    }[\"useWhisperLive.useCallback[connect]\"], [\n        config,\n        toast\n    ]);\n    const micRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const systemRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ctxRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const processorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const startTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[startTranscription]\": async ()=>{\n            if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: 'Not connected'\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                return;\n            }\n            try {\n                var _config_audioSources;\n                // 1) Screen + system audio (if enabled)\n                let systemStream = null;\n                if ((_config_audioSources = config.audioSources) === null || _config_audioSources === void 0 ? void 0 : _config_audioSources.systemAudio) {\n                    systemStream = await navigator.mediaDevices.getDisplayMedia({\n                        video: true,\n                        audio: true\n                    });\n                    systemRef.current = systemStream;\n                }\n                // 2) Microphone\n                const micStream = await navigator.mediaDevices.getUserMedia({\n                    audio: {\n                        sampleRate: 16000,\n                        channelCount: 1\n                    }\n                });\n                micRef.current = micStream;\n                const ctx = ctxRef.current;\n                const dest = ctx.createMediaStreamDestination();\n                // 4) Wire mic â†’ dest\n                const micSrc = ctx.createMediaStreamSource(micStream);\n                micSrc.connect(dest);\n                // 5) Wire system audio â†’ dest\n                if (systemStream) {\n                    const sysSrc = ctx.createMediaStreamSource(systemStream);\n                    sysSrc.connect(dest);\n                }\n                // 6) Instead of wiring mic+sys directly to the processor, we\n                //    take the mixed dest.stream and hook that up:\n                const mixedSrc = ctx.createMediaStreamSource(dest.stream);\n                // 7) Create your ScriptProcessor (bufferSize=4096, mono in/out)\n                const processor = ctx.createScriptProcessor(3200, 1, 1);\n                // 8) Wire the mixed audio into the processor\n                mixedSrc.connect(processor);\n                // 9) On each onaudioprocess, build exactly one packet\n                processor.onaudioprocess = ({\n                    \"useWhisperLive.useCallback[startTranscription]\": (e)=>{\n                        var _wsRef_current;\n                        const float32 = e.inputBuffer.getChannelData(0);\n                        const float32Buffer = new Float32Array(float32.length);\n                        for(let i = 0; i < float32.length; i++){\n                            float32Buffer[i] = float32[i];\n                        }\n                        if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                            wsRef.current.send(float32Buffer.buffer);\n                        }\n                        // â† NEW: capture for visualization\n                        setAudioData(float32Buffer);\n                        setDataUpdateTrigger({\n                            \"useWhisperLive.useCallback[startTranscription]\": (t)=>t + 1\n                        }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                    }\n                })[\"useWhisperLive.useCallback[startTranscription]\"];\n                // 10) Start it\n                processor.connect(ctx.destination);\n                processorRef.current = processor;\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            isTranscribing: true\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n            } catch (err) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: \"Failed to start transcription: \".concat(err.message)\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                toast({\n                    title: 'Transcription Error',\n                    description: err.message,\n                    variant: 'destructive'\n                });\n            }\n        }\n    }[\"useWhisperLive.useCallback[startTranscription]\"], [\n        config,\n        toast\n    ]);\n    const stopTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[stopTranscription]\": ()=>{\n            var _wsRef_current;\n            if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                // zeroâ€‘length ArrayBuffer signals â€œplease flush & finishâ€\n                wsRef.current.send(new ArrayBuffer(0));\n            }\n            // tear down audio graph immediately\n            if (processorRef.current) {\n                processorRef.current.disconnect();\n                processorRef.current = null;\n            }\n            if (micRef.current) {\n                micRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                micRef.current = null;\n            }\n            if (systemRef.current) {\n                systemRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                systemRef.current = null;\n            }\n            if (ctxRef.current) {\n                ctxRef.current.close();\n                ctxRef.current = null;\n            }\n            setState({\n                \"useWhisperLive.useCallback[stopTranscription]\": (s)=>({\n                        ...s,\n                        isTranscribing: false\n                    })\n            }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n        }\n    }[\"useWhisperLive.useCallback[stopTranscription]\"], []);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[disconnect]\": ()=>{\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            stopTranscription();\n            setState({\n                isConnected: false,\n                isTranscribing: false,\n                transcript: '',\n                error: null\n            });\n        }\n    }[\"useWhisperLive.useCallback[disconnect]\"], [\n        stopTranscription\n    ]);\n    const clearTranscript = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[clearTranscript]\": ()=>{\n            setState({\n                \"useWhisperLive.useCallback[clearTranscript]\": (s)=>({\n                        ...s,\n                        transcript: ''\n                    })\n            }[\"useWhisperLive.useCallback[clearTranscript]\"]);\n        }\n    }[\"useWhisperLive.useCallback[clearTranscript]\"], []);\n    return {\n        state,\n        connect,\n        startTranscription,\n        stopTranscription,\n        disconnect,\n        clearTranscript,\n        wsRef,\n        audioData,\n        dataUpdateTrigger\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utd2hpc3Blci1saXZlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7b0VBRXFEO0FBQ1Q7QUF1QnJDLFNBQVNJLGVBQWVDLE1BQXlCO0lBQ3BELE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHUCwrQ0FBUUEsQ0FBbUI7UUFDakRRLGFBQWE7UUFDYkMsZ0JBQWdCO1FBQ2hCQyxZQUFZO1FBQ1pDLE9BQU87SUFDWDtJQUNBLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHYiwrQ0FBUUEsQ0FBb0I7SUFDOUQsTUFBTSxDQUFDYyxtQkFBbUJDLHFCQUFxQixHQUFHZiwrQ0FBUUEsQ0FBQztJQUMzRCxNQUFNZ0IsUUFBUWYsNkNBQU1BLENBQW1CO0lBQ3ZDLE1BQU1nQixTQUFTaEIsNkNBQU1BLENBQ2pCLE9BQU9pQixXQUFXLGVBQWVBLE9BQU9DLFVBQVUsR0FDNUNELE9BQU9DLFVBQVUsS0FDakJDLEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLEtBQUssQ0FBQztJQUUzQyxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHckIsMERBQVFBO0lBRTFCLE1BQU1zQixVQUFVdkIsa0RBQVdBOytDQUFDO1lBQ3hCd0IsUUFBUUMsR0FBRyxDQUFDLCtCQUErQnRCO1lBQzNDLElBQUlXLE1BQU1ZLE9BQU8sRUFBRTtnQkFDZlosTUFBTVksT0FBTyxDQUFDQyxLQUFLO2dCQUNuQmIsTUFBTVksT0FBTyxHQUFHO1lBQ3BCO1lBQ0EsOEVBQThFO1lBQzlFLE1BQU1FLE1BQU0sSUFBSUMsYUFBYTtnQkFBRUMsWUFBWTtZQUFNO1lBQ2pEQyxPQUFPTCxPQUFPLEdBQUdFO1lBQ2pCLE1BQU1JLG1CQUFtQkosSUFBSUUsVUFBVTtZQUN2Q04sUUFBUUMsR0FBRyxDQUFDLDhDQUE4Q087WUFDMUQzQjt1REFBUzRCLENBQUFBLElBQU07d0JBQUUsR0FBR0EsQ0FBQzt3QkFBRXhCLE9BQU87b0JBQUs7O1lBRW5DLE1BQU15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QUtBLEVBQUVVLElBQUk7O2dCQUFLNUMsT0FBT3pELE9BQU8sR0FBRztZQUFNO1lBQ2hHLElBQUkwRCxVQUFVMUQsT0FBTyxFQUFFO2dCQUFFMEQsVUFBVTFELE9BQU8sQ0FBQ21HLFNBQVMsR0FBR0MsT0FBTztxRUFBQ1QsQ0FBQUEsSUFBS0EsRUFBRVUsSUFBSTs7Z0JBQUszQyxVQUFVMUQsT0FBTyxHQUFHO1lBQU07WUFDekcsSUFBSUssT0FBT0wsT0FBTyxFQUFFO2dCQUFFSyxPQUFPTCxPQUFPLENBQUNDLEtBQUs7Z0JBQUlJLE9BQU9MLE9BQU8sR0FBRztZQUFNO1lBRXJFckI7aUVBQVM0QixDQUFBQSxJQUFNO3dCQUFFLEdBQUdBLENBQUM7d0JBQUUxQixnQkFBZ0I7b0JBQU07O1FBQ2pEO3dEQUFHLEVBQUU7SUFHTCxNQUFNcUgsYUFBYTVILGtEQUFXQTtrREFBQztZQUMzQixJQUFJYyxNQUFNWSxPQUFPLEVBQUU7Z0JBQ2ZaLE1BQU1ZLE9BQU8sQ0FBQ0MsS0FBSztnQkFDbkJiLE1BQU1ZLE9BQU8sR0FBRztZQUNwQjtZQUNBZ0c7WUFDQXJILFNBQVM7Z0JBQUVDLGFBQWE7Z0JBQU9DLGdCQUFnQjtnQkFBT0MsWUFBWTtnQkFBSUMsT0FBTztZQUFLO1FBQ3RGO2lEQUFHO1FBQUNpSDtLQUFrQjtJQUV0QixNQUFNTSxrQkFBa0JoSSxrREFBV0E7dURBQUM7WUFDaENLOytEQUFTNEIsQ0FBQUEsSUFBTTt3QkFBRSxHQUFHQSxDQUFDO3dCQUFFekIsWUFBWTtvQkFBRzs7UUFDMUM7c0RBQUcsRUFBRTtJQUVMLE9BQU87UUFDSEo7UUFDQW1CO1FBQ0F3QztRQUNBMkQ7UUFDQUU7UUFDQUk7UUFDQWxIO1FBQ0NKO1FBQ1BFO0lBQ0U7QUFDSiIsInNvdXJjZXMiOlsiRTpcXEFpdm9pY2V0b3RleHRcXHNyY1xcaG9va3NcXHVzZS13aGlzcGVyLWxpdmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgeyB1c2VUb2FzdCB9IGZyb20gJ0AvaG9va3MvdXNlLXRvYXN0J1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXaGlzcGVyTGl2ZUNvbmZpZyB7XHJcbiAgICBzZXJ2ZXJVcmw6IHN0cmluZ1xyXG4gICAgcG9ydDogbnVtYmVyXHJcbiAgICBsYW5ndWFnZTogc3RyaW5nXHJcbiAgICB0cmFuc2xhdGU6IGJvb2xlYW5cclxuICAgIG1vZGVsOiBzdHJpbmdcclxuICAgIHZhZDogYm9vbGVhblxyXG4gICAgc2F2ZVJlY29yZGluZzogYm9vbGVhblxyXG4gICAgb3V0cHV0RmlsZW5hbWU6IHN0cmluZ1xyXG4gICAgbWF4Q2xpZW50czogbnVtYmVyXHJcbiAgICBtYXhDb25uZWN0aW9uVGltZTogbnVtYmVyXHJcbiAgICBhdWRpb1NvdXJjZXM/OiB7IG1pY3JvcGhvbmU6IGJvb2xlYW47IHN5c3RlbUF1ZGlvOiBib29sZWFuIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIFdoaXNwZXJMaXZlU3RhdGUge1xyXG4gICAgaXNDb25uZWN0ZWQ6IGJvb2xlYW5cclxuICAgIGlzVHJhbnNjcmliaW5nOiBib29sZWFuXHJcbiAgICB0cmFuc2NyaXB0OiBzdHJpbmdcclxuICAgIGVycm9yOiBzdHJpbmcgfCBudWxsXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VXaGlzcGVyTGl2ZShjb25maWc6IFdoaXNwZXJMaXZlQ29uZmlnKSB7XHJcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPFdoaXNwZXJMaXZlU3RhdGU+KHtcclxuICAgICAgICBpc0Nvbm5lY3RlZDogZmFsc2UsXHJcbiAgICAgICAgaXNUcmFuc2NyaWJpbmc6IGZhbHNlLFxyXG4gICAgICAgIHRyYW5zY3JpcHQ6ICcnLFxyXG4gICAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgfSlcclxuICAgIGNvbnN0IFthdWRpb0RhdGEsIHNldEF1ZGlvRGF0YV0gPSB1c2VTdGF0ZTxVaW50OEFycmF5IHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IFtkYXRhVXBkYXRlVHJpZ2dlciwgc2V0RGF0YVVwZGF0ZVRyaWdnZXJdID0gdXNlU3RhdGUoMClcclxuICAgIGNvbnN0IHdzUmVmID0gdXNlUmVmPFdlYlNvY2tldCB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCB1aWRSZWYgPSB1c2VSZWYoXHJcbiAgICAgICAgdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSURcclxuICAgICAgICAgICAgPyBjcnlwdG8ucmFuZG9tVVVJRCgpXHJcbiAgICAgICAgICAgIDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksXHJcbiAgICApXHJcbiAgICBjb25zdCB7IHRvYXN0IH0gPSB1c2VUb2FzdCgpXHJcblxyXG4gICAgY29uc3QgY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnW3VzZVdoaXNwZXJMaXZlXSAgY29ubmVjdCgpJywgY29uZmlnKTtcclxuICAgICAgICBpZiAod3NSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50LmNsb3NlKClcclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudCA9IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMSkgY3JlYXRlIEF1ZGlvQ29udGV4dCBub3cgc28gd2UgY2FuIGhhbmQgaXRzIHJlYWwgc2FtcGxlUmF0ZSB0byB0aGUgc2VydmVyXHJcbiAgICAgICAgY29uc3QgY3R4ID0gbmV3IEF1ZGlvQ29udGV4dCh7IHNhbXBsZVJhdGU6IDE2MDAwIH0pO1xyXG4gICAgICAgIGN0eFJlZi5jdXJyZW50ID0gY3R4XHJcbiAgICAgICAgY29uc3QgYWN0dWFsU2FtcGxlUmF0ZSA9IGN0eC5zYW1wbGVSYXRlXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1t1c2VXaGlzcGVyTGl2ZV0gYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgPScsIGFjdHVhbFNhbXBsZVJhdGUpXHJcbiAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogbnVsbCB9KSlcclxuXHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonID8gJ3dzcycgOiAnd3MnO1xyXG4gICAgICAgIGNvbnN0IHdzID0gbmV3IFdlYlNvY2tldChgJHtwcm90b2NvbH06Ly8ke2NvbmZpZy5zZXJ2ZXJVcmx9OiR7Y29uZmlnLnBvcnR9YCk7XHJcbiAgICAgICAgd3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcclxuICAgICAgICB3c1JlZi5jdXJyZW50ID0gd3NcclxuXHJcbiAgICAgICAgd3Mub25vcGVuID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZVdoaXNwZXJMaXZlXSDwn5+iIFdlYlNvY2tldCBPUEVOJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhc2tOYW1lID0gY29uZmlnLnRyYW5zbGF0ZSA/ICd0cmFuc2xhdGUnIDogJ3RyYW5zY3JpYmUnXHJcbiAgICAgICAgICAgIHdzLnNlbmQoXHJcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzazogdGFza05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWRSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZTogY29uZmlnLmxhbmd1YWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBjb25maWcubW9kZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFkOiBjb25maWcudmFkLFxyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVfcmVjb3JkaW5nOiBjb25maWcuc2F2ZVJlY29yZGluZyxcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRfZmlsZW5hbWU6IGNvbmZpZy5vdXRwdXRGaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhfY2xpZW50czogY29uZmlnLm1heENsaWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4X2Nvbm5lY3Rpb25fdGltZTogY29uZmlnLm1heENvbm5lY3Rpb25UaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICoqaW1wb3J0YW50Kio6IG11c3QgbWF0Y2ggeW91ciBBdWRpb0NvbnRleHQgJiBTY3JpcHRQcm9jZXNzb3JcclxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVfcmF0ZTogYWN0dWFsU2FtcGxlUmF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBjaHVua19zaXplOiA0MDk2LFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgc3RhcnRUcmFuc2NyaXB0aW9uKCk7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNDb25uZWN0ZWQ6IHRydWUgfSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpbnNpZGUgeW91ciBjb25uZWN0KClcclxuICAgICAgICB3cy5vbm1lc3NhZ2UgPSBlID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JhdyBXUyBNZXNzYWdlOicsIGUuZGF0YSlcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRhdGEgIT09ICdzdHJpbmcnKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSBoYW5kc2hha2VcclxuICAgICAgICAgICAgaWYgKG1zZy5tZXNzYWdlID09PSAnU0VSVkVSX1JFQURZJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gZXJyb3JzXHJcbiAgICAgICAgICAgIGlmIChtc2cudHlwZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogbXNnLm1lc3NhZ2UgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBvbGTigJBzdHlsZSBwYXJ0aWFsL2ZpbmFsIChpZiB5b3UgZXZlciB0b2dnbGUgdGhhdCBiYWNrIG9uKVxyXG4gICAgICAgICAgICBpZiAobXNnLnR5cGUgPT09ICdwYXJ0aWFsJyB8fCBtc2cudHlwZSA9PT0gJ3RyYW5zY3JpcHQnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucyxcclxuICAgICAgICAgICAgICAgICAgICBpc1RyYW5zY3JpYmluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NyaXB0OiBzLnRyYW5zY3JpcHQgKyBtc2cudGV4dFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtc2cudHlwZSA9PT0gJ2ZpbmFsJykge1xyXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUcmFuc2NyaWJpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY3JpcHQ6IHMudHJhbnNjcmlwdCArIG1zZy50ZXh0ICsgJ1xcbidcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g4oaQIE5FVzogaGFuZGxlIHRoZSBgc2VnbWVudHNgIGFycmF5XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1zZy5zZWdtZW50cykpIHtcclxuICAgICAgICAgICAgICAgIC8vIHB1bGwgZXZlcnkgc2VnbWVudC50ZXh0LCBjb25jYXRlbmF0ZSwgYXBwZW5kXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZVdoaXNwZXJMaXZlXSBnb3Qgc2VnbWVudHMg4oaSJywgbXNnLnNlZ21lbnRzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gbXNnLnNlZ21lbnRzLm1hcCgoc2VnOiBhbnkpID0+IHNlZy50ZXh0KS5qb2luKCcnKTtcclxuICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVHJhbnNjcmliaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY3JpcHQ6IHMudHJhbnNjcmlwdCArIGJhdGNoXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIGFueSBzdHJheSBgbXNnLm1lc3NhZ2VgXHJcbiAgICAgICAgICAgIGlmIChtc2cubWVzc2FnZSAmJiBtc2cubWVzc2FnZSAhPT0gJ1NFUlZFUl9SRUFEWScpIHtcclxuICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVHJhbnNjcmliaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY3JpcHQ6IHMudHJhbnNjcmlwdCArIG1zZy5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgd3Mub25jbG9zZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBpc0Nvbm5lY3RlZDogZmFsc2UsIGlzVHJhbnNjcmliaW5nOiBmYWxzZSB9KSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdzLm9uZXJyb3IgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW3VzZVdoaXNwZXJMaXZlXSBXZWJTb2NrZXQgZXJyb3IgKG5vbuKAkWZhdGFsKScsIGVycik7XHJcbiAgICAgICAgICAgIC8vIGRvbuKAmXQgc2V0U3RhdGUgb3IgdG9hc3QgaGVyZVxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbY29uZmlnLCB0b2FzdF0pXHJcblxyXG4gICAgY29uc3QgbWljUmVmID0gdXNlUmVmPE1lZGlhU3RyZWFtIHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IHN5c3RlbVJlZiA9IHVzZVJlZjxNZWRpYVN0cmVhbSB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCBjdHhSZWYgPSB1c2VSZWY8QXVkaW9Db250ZXh0IHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IHByb2Nlc3NvclJlZiA9IHVzZVJlZjxTY3JpcHRQcm9jZXNzb3JOb2RlIHwgbnVsbD4obnVsbClcclxuXHJcbiAgICBjb25zdCBzdGFydFRyYW5zY3JpcHRpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCF3c1JlZi5jdXJyZW50IHx8IHdzUmVmLmN1cnJlbnQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogJ05vdCBjb25uZWN0ZWQnIH0pKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gMSkgU2NyZWVuICsgc3lzdGVtIGF1ZGlvIChpZiBlbmFibGVkKVxyXG4gICAgICAgICAgICBsZXQgc3lzdGVtU3RyZWFtOiBNZWRpYVN0cmVhbSB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmF1ZGlvU291cmNlcz8uc3lzdGVtQXVkaW8pIHtcclxuICAgICAgICAgICAgICAgIHN5c3RlbVN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKHtcclxuICAgICAgICAgICAgICAgICAgICB2aWRlbzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBhdWRpbzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3lzdGVtUmVmLmN1cnJlbnQgPSBzeXN0ZW1TdHJlYW07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDIpIE1pY3JvcGhvbmVcclxuICAgICAgICAgICAgY29uc3QgbWljU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xyXG4gICAgICAgICAgICAgICAgYXVkaW86IHsgc2FtcGxlUmF0ZTogMTYwMDAsIGNoYW5uZWxDb3VudDogMSB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbWljUmVmLmN1cnJlbnQgPSBtaWNTdHJlYW07XHJcblxyXG5cclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gY3R4UmVmLmN1cnJlbnQhXHJcbiAgICAgICAgICAgIGNvbnN0IGRlc3QgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpXHJcblxyXG4gICAgICAgICAgICAvLyA0KSBXaXJlIG1pYyDihpIgZGVzdFxyXG4gICAgICAgICAgICBjb25zdCBtaWNTcmMgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobWljU3RyZWFtKTtcclxuICAgICAgICAgICAgbWljU3JjLmNvbm5lY3QoZGVzdCk7XHJcblxyXG4gICAgICAgICAgICAvLyA1KSBXaXJlIHN5c3RlbSBhdWRpbyDihpIgZGVzdFxyXG4gICAgICAgICAgICBpZiAoc3lzdGVtU3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzeXNTcmMgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3lzdGVtU3RyZWFtKTtcclxuICAgICAgICAgICAgICAgIHN5c1NyYy5jb25uZWN0KGRlc3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyA2KSBJbnN0ZWFkIG9mIHdpcmluZyBtaWMrc3lzIGRpcmVjdGx5IHRvIHRoZSBwcm9jZXNzb3IsIHdlXHJcbiAgICAgICAgICAgIC8vICAgIHRha2UgdGhlIG1peGVkIGRlc3Quc3RyZWFtIGFuZCBob29rIHRoYXQgdXA6XHJcbiAgICAgICAgICAgIGNvbnN0IG1peGVkU3JjID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKGRlc3Quc3RyZWFtKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDcpIENyZWF0ZSB5b3VyIFNjcmlwdFByb2Nlc3NvciAoYnVmZmVyU2l6ZT00MDk2LCBtb25vIGluL291dClcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gY3R4LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcigzMjAwLCAxLCAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDgpIFdpcmUgdGhlIG1peGVkIGF1ZGlvIGludG8gdGhlIHByb2Nlc3NvclxyXG4gICAgICAgICAgICBtaXhlZFNyYy5jb25uZWN0KHByb2Nlc3Nvcik7XHJcblxyXG4gICAgICAgICAgICAvLyA5KSBPbiBlYWNoIG9uYXVkaW9wcm9jZXNzLCBidWlsZCBleGFjdGx5IG9uZSBwYWNrZXRcclxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uYXVkaW9wcm9jZXNzID0gZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmbG9hdDMyID0gZS5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZsb2F0MzJCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGZsb2F0MzIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmxvYXQzMi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0MzJCdWZmZXJbaV0gPSBmbG9hdDMyW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHdzUmVmLmN1cnJlbnQ/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd3NSZWYuY3VycmVudC5zZW5kKGZsb2F0MzJCdWZmZXIuYnVmZmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDihpAgTkVXOiBjYXB0dXJlIGZvciB2aXN1YWxpemF0aW9uXHJcbiAgICAgICAgICAgICAgICBzZXRBdWRpb0RhdGEoZmxvYXQzMkJ1ZmZlcilcclxuICAgICAgICAgICAgICAgIHNldERhdGFVcGRhdGVUcmlnZ2VyKHQgPT4gdCArIDEpXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyAxMCkgU3RhcnQgaXRcclxuICAgICAgICAgICAgcHJvY2Vzc29yLmNvbm5lY3QoY3R4LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICAgICAgcHJvY2Vzc29yUmVmLmN1cnJlbnQgPSBwcm9jZXNzb3I7XHJcblxyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGlzVHJhbnNjcmliaW5nOiB0cnVlIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgZXJyb3I6IGBGYWlsZWQgdG8gc3RhcnQgdHJhbnNjcmlwdGlvbjogJHtlcnIubWVzc2FnZX1gIH0pKTtcclxuICAgICAgICAgICAgdG9hc3QoeyB0aXRsZTogJ1RyYW5zY3JpcHRpb24gRXJyb3InLCBkZXNjcmlwdGlvbjogZXJyLm1lc3NhZ2UsIHZhcmlhbnQ6ICdkZXN0cnVjdGl2ZScgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2NvbmZpZywgdG9hc3RdKTtcclxuXHJcblxyXG4gICAgY29uc3Qgc3RvcFRyYW5zY3JpcHRpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKHdzUmVmLmN1cnJlbnQ/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgICAgIC8vIHplcm/igJFsZW5ndGggQXJyYXlCdWZmZXIgc2lnbmFscyDigJxwbGVhc2UgZmx1c2ggJiBmaW5pc2jigJ1cclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudC5zZW5kKG5ldyBBcnJheUJ1ZmZlcigwKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0ZWFyIGRvd24gYXVkaW8gZ3JhcGggaW1tZWRpYXRlbHlcclxuICAgICAgICBpZiAocHJvY2Vzc29yUmVmLmN1cnJlbnQpIHsgcHJvY2Vzc29yUmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpOyBwcm9jZXNzb3JSZWYuY3VycmVudCA9IG51bGw7IH1cclxuICAgICAgICBpZiAobWljUmVmLmN1cnJlbnQpIHsgbWljUmVmLmN1cnJlbnQuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTsgbWljUmVmLmN1cnJlbnQgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKHN5c3RlbVJlZi5jdXJyZW50KSB7IHN5c3RlbVJlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSk7IHN5c3RlbVJlZi5jdXJyZW50ID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChjdHhSZWYuY3VycmVudCkgeyBjdHhSZWYuY3VycmVudC5jbG9zZSgpOyBjdHhSZWYuY3VycmVudCA9IG51bGw7IH1cclxuXHJcbiAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBpc1RyYW5zY3JpYmluZzogZmFsc2UgfSkpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuXHJcbiAgICBjb25zdCBkaXNjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGlmICh3c1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICAgIH1cclxuICAgICAgICBzdG9wVHJhbnNjcmlwdGlvbigpXHJcbiAgICAgICAgc2V0U3RhdGUoeyBpc0Nvbm5lY3RlZDogZmFsc2UsIGlzVHJhbnNjcmliaW5nOiBmYWxzZSwgdHJhbnNjcmlwdDogJycsIGVycm9yOiBudWxsIH0pXHJcbiAgICB9LCBbc3RvcFRyYW5zY3JpcHRpb25dKVxyXG5cclxuICAgIGNvbnN0IGNsZWFyVHJhbnNjcmlwdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIHRyYW5zY3JpcHQ6ICcnIH0pKVxyXG4gICAgfSwgW10pXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0ZSxcclxuICAgICAgICBjb25uZWN0LFxyXG4gICAgICAgIHN0YXJ0VHJhbnNjcmlwdGlvbixcclxuICAgICAgICBzdG9wVHJhbnNjcmlwdGlvbixcclxuICAgICAgICBkaXNjb25uZWN0LFxyXG4gICAgICAgIGNsZWFyVHJhbnNjcmlwdCxcclxuICAgICAgICB3c1JlZixcclxuICAgICAgICAgYXVkaW9EYXRhLFxyXG4gIGRhdGFVcGRhdGVUcmlnZ2VyLFxyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwidXNlVG9hc3QiLCJ1c2VXaGlzcGVyTGl2ZSIsImNvbmZpZyIsInN0YXRlIiwic2V0U3RhdGUiLCJpc0Nvbm5lY3RlZCIsImlzVHJhbnNjcmliaW5nIiwidHJhbnNjcmlwdCIsImVycm9yIiwiYXVkaW9EYXRhIiwic2V0QXVkaW9EYXRhIiwiZGF0YVVwZGF0ZVRyaWdnZXIiLCJzZXREYXRhVXBkYXRlVHJpZ2dlciIsIndzUmVmIiwidWlkUmVmIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwidG9hc3QiLCJjb25uZWN0IiwiY29uc29sZSIsImxvZyIsImN1cnJlbnQiLCJjbG9zZSIsImN0eCIsIkF1ZGlvQ29udGV4dCIsInNhbXBsZVJhdGUiLCJjdHhSZWYiLCJhY3R1YWxTYW1wbGVSYXRlIiwicyIsInByb3RvY29sIiwid2luZG93IiwibG9jYXRpb24iLCJ3cyIsIldlYlNvY2tldCIsInNlcnZlclVybCIsInBvcnQiLCJiaW5hcnlUeXBlIiwib25vcGVuIiwidGFza05hbWUiLCJ0cmFuc2xhdGUiLCJzZW5kIiwiSlNPTiIsInN0cmluZ2lmeSIsInRhc2siLCJ1aWQiLCJsYW5ndWFnZSIsIm1vZGVsIiwidmFkIiwic2F2ZV9yZWNvcmRpbmciLCJzYXZlUmVjb3JkaW5nIiwib3V0cHV0X2ZpbGVuYW1lIiwib3V0cHV0RmlsZW5hbWUiLCJtYXhfY2xpZW50cyIsIm1heENsaWVudHMiLCJtYXhfY29ubmVjdGlvbl90aW1lIiwibWF4Q29ubmVjdGlvblRpbWUiLCJzYW1wbGVfcmF0ZSIsImNodW5rX3NpemUiLCJzdGFydFRyYW5zY3JpcHRpb24iLCJvbm1lc3NhZ2UiLCJlIiwiZGF0YSIsIm1zZyIsInBhcnNlIiwibWVzc2FnZSIsInR5cGUiLCJ0ZXh0IiwiQXJyYXkiLCJpc0FycmF5Iiwic2VnbWVudHMiLCJiYXRjaCIsIm1hcCIsInNlZyIsImpvaW4iLCJvbmNsb3NlIiwib25lcnJvciIsImVyciIsIndhcm4iLCJtaWNSZWYiLCJzeXN0ZW1SZWYiLCJwcm9jZXNzb3JSZWYiLCJyZWFkeVN0YXRlIiwiT1BFTiIsInN5c3RlbVN0cmVhbSIsImF1ZGlvU291cmNlcyIsInN5c3RlbUF1ZGlvIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0RGlzcGxheU1lZGlhIiwidmlkZW8iLCJhdWRpbyIsIm1pY1N0cmVhbSIsImdldFVzZXJNZWRpYSIsImNoYW5uZWxDb3VudCIsImRlc3QiLCJjcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uIiwibWljU3JjIiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJzeXNTcmMiLCJtaXhlZFNyYyIsInN0cmVhbSIsInByb2Nlc3NvciIsImNyZWF0ZVNjcmlwdFByb2Nlc3NvciIsIm9uYXVkaW9wcm9jZXNzIiwiZmxvYXQzMiIsImlucHV0QnVmZmVyIiwiZ2V0Q2hhbm5lbERhdGEiLCJmbG9hdDMyQnVmZmVyIiwiRmxvYXQzMkFycmF5IiwibGVuZ3RoIiwiaSIsImJ1ZmZlciIsInQiLCJkZXN0aW5hdGlvbiIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJ2YXJpYW50Iiwic3RvcFRyYW5zY3JpcHRpb24iLCJBcnJheUJ1ZmZlciIsImRpc2Nvbm5lY3QiLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwic3RvcCIsImNsZWFyVHJhbnNjcmlwdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-whisper-live.ts\n"));

/***/ })

});