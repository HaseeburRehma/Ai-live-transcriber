"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/notes/page",{

/***/ "(app-pages-browser)/./src/hooks/use-whisper-live.ts":
/*!***************************************!*\
  !*** ./src/hooks/use-whisper-live.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWhisperLive: () => (/* binding */ useWhisperLive)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/hooks/use-toast */ \"(app-pages-browser)/./src/hooks/use-toast.ts\");\n/* __next_internal_client_entry_do_not_use__ useWhisperLive auto */ \n\nfunction useWhisperLive(config) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        isTranscribing: false,\n        transcript: '',\n        error: null\n    });\n    const [audioData, setAudioData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [dataUpdateTrigger, setDataUpdateTrigger] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const lastSegmentIndexRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const uidRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));\n    const { toast } = (0,_hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__.useToast)();\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[connect]\": ()=>{\n            console.log('[useWhisperLive]  connect()', config);\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            // 1) create AudioContext now so we can hand its real sampleRate to the server\n            const ctx = new AudioContext({\n                sampleRate: 16000\n            });\n            ctxRef.current = ctx;\n            const actualSampleRate = ctx.sampleRate;\n            console.log('[useWhisperLive] audioContext.sampleRate =', actualSampleRate);\n            setState({\n                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                        ...s,\n                        error: null\n                    })\n            }[\"useWhisperLive.useCallback[connect]\"]);\n            const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\n            const ws = new WebSocket(\"\".concat(protocol, \"://\").concat(config.serverUrl, \":\").concat(config.port));\n            ws.binaryType = 'arraybuffer';\n            wsRef.current = ws;\n            ws.onopen = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    console.log('[useWhisperLive] ðŸŸ¢ WebSocket OPEN');\n                    const taskName = config.translate ? 'translate' : 'transcribe';\n                    ws.send(JSON.stringify({\n                        task: taskName,\n                        uid: uidRef.current,\n                        language: config.language,\n                        model: config.model,\n                        use_vad: config.vad,\n                        // only send us the newest segment each time:\n                        send_last_n_segments: 1,\n                        save_recording: config.saveRecording,\n                        output_filename: config.outputFilename,\n                        max_clients: config.maxClients,\n                        max_connection_time: config.maxConnectionTime,\n                        // **important**: must match your AudioContext & ScriptProcessor\n                        sample_rate: actualSampleRate,\n                        chunk_size: 4096\n                    }));\n                    startTranscription();\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: true\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            // inside your connect()\n            ws.onmessage = ({\n                \"useWhisperLive.useCallback[connect]\": (e)=>{\n                    console.log('Raw WS Message:', e.data);\n                    if (typeof e.data !== 'string') return;\n                    const msg = JSON.parse(e.data);\n                    // ignore handshake\n                    if (msg.message === 'SERVER_READY') return;\n                    // errors\n                    if (msg.type === 'error') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    error: msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // oldâ€style partial/final (if you ever toggle that back on)\n                    if (msg.type === 'partial' || msg.type === 'transcript') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + msg.text\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    if (msg.type === 'final') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: false,\n                                    transcript: s.transcript + msg.text + '\\n'\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // â† NEW: handle the `segments` array\n                    if (Array.isArray(msg.segments)) {\n                        const segments = msg.segments;\n                        // grab only those we havenâ€™t appended yet\n                        const newSegments = segments.slice(lastSegmentIndexRef.current);\n                        if (newSegments.length) {\n                            const textToAppend = newSegments.map({\n                                \"useWhisperLive.useCallback[connect].textToAppend\": (s)=>s.text\n                            }[\"useWhisperLive.useCallback[connect].textToAppend\"]).join('');\n                            setState({\n                                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                        ...s,\n                                        isTranscribing: true,\n                                        transcript: s.transcript + textToAppend\n                                    })\n                            }[\"useWhisperLive.useCallback[connect]\"]);\n                            // remember how many weâ€™ve consumed\n                            lastSegmentIndexRef.current = segments.length;\n                        }\n                        return;\n                    }\n                    // fallback to any stray `msg.message`\n                    if (msg.message && msg.message !== 'SERVER_READY') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                    }\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onclose = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: false,\n                                isTranscribing: false\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onerror = ({\n                \"useWhisperLive.useCallback[connect]\": (err)=>{\n                    console.warn('[useWhisperLive] WebSocket error (nonâ€‘fatal)', err);\n                // donâ€™t setState or toast here\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n        }\n    }[\"useWhisperLive.useCallback[connect]\"], [\n        config,\n        toast\n    ]);\n    const micRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const systemRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ctxRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const processorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const startTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[startTranscription]\": async ()=>{\n            if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: 'Not connected'\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                return;\n            }\n            try {\n                var _config_audioSources;\n                // 1) Screen + system audio (if enabled)\n                let systemStream = null;\n                if ((_config_audioSources = config.audioSources) === null || _config_audioSources === void 0 ? void 0 : _config_audioSources.systemAudio) {\n                    systemStream = await navigator.mediaDevices.getDisplayMedia({\n                        video: true,\n                        audio: true\n                    });\n                    systemRef.current = systemStream;\n                }\n                // 2) Microphone\n                const micStream = await navigator.mediaDevices.getUserMedia({\n                    audio: {\n                        sampleRate: 16000,\n                        channelCount: 1\n                    }\n                });\n                micRef.current = micStream;\n                const ctx = ctxRef.current;\n                const dest = ctx.createMediaStreamDestination();\n                // 4) Wire mic â†’ dest\n                const micSrc = ctx.createMediaStreamSource(micStream);\n                micSrc.connect(dest);\n                // 5) Wire system audio â†’ dest\n                if (systemStream) {\n                    const sysSrc = ctx.createMediaStreamSource(systemStream);\n                    sysSrc.connect(dest);\n                }\n                // 6) Instead of wiring mic+sys directly to the processor, we\n                //    take the mixed dest.stream and hook that up:\n                const mixedSrc = ctx.createMediaStreamSource(dest.stream);\n                // 7) Create your ScriptProcessor (bufferSize=4096, mono in/out)\n                const processor = ctx.createScriptProcessor(4096, 1, 1);\n                // 8) Wire the mixed audio into the processor\n                mixedSrc.connect(processor);\n                // 9) On each onaudioprocess, build exactly one packet\n                processor.onaudioprocess = ({\n                    \"useWhisperLive.useCallback[startTranscription]\": (e)=>{\n                        const float32 = e.inputBuffer.getChannelData(0);\n                        const float32Buffer = new Float32Array(float32);\n                        // â†’ convert to Uint8Array [0..255]\n                        const ui8 = new Uint8Array(float32Buffer.length);\n                        for(let i = 0; i < float32Buffer.length; i++){\n                            ui8[i] = Math.min(255, Math.max(0, Math.floor((float32Buffer[i] + 1) * 127.5)));\n                        }\n                        // send raw float32 PCM to server\n                        if (wsRef.current.readyState === WebSocket.OPEN) {\n                            wsRef.current.send(float32Buffer.buffer);\n                        }\n                        // update visualizer\n                        setAudioData(ui8);\n                        setDataUpdateTrigger({\n                            \"useWhisperLive.useCallback[startTranscription]\": (t)=>t + 1\n                        }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                    }\n                })[\"useWhisperLive.useCallback[startTranscription]\"];\n                // 10) Start it\n                processor.connect(ctx.destination);\n                processorRef.current = processor;\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            isTranscribing: true\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n            } catch (err) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: \"Failed to start transcription: \".concat(err.message)\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                toast({\n                    title: 'Transcription Error',\n                    description: err.message,\n                    variant: 'destructive'\n                });\n            }\n        }\n    }[\"useWhisperLive.useCallback[startTranscription]\"], [\n        config,\n        toast\n    ]);\n    const stopTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[stopTranscription]\": ()=>{\n            var _wsRef_current;\n            if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                // zeroâ€‘length ArrayBuffer signals â€œplease flush & finishâ€\n                wsRef.current.send(new TextEncoder().encode(\"END_OF_AUDIO\"));\n            }\n            // tear down audio graph immediately\n            if (processorRef.current) {\n                processorRef.current.disconnect();\n                processorRef.current = null;\n            }\n            if (micRef.current) {\n                micRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                micRef.current = null;\n            }\n            if (systemRef.current) {\n                systemRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                systemRef.current = null;\n            }\n            if (ctxRef.current) {\n                ctxRef.current.close();\n                ctxRef.current = null;\n            }\n            setState({\n                \"useWhisperLive.useCallback[stopTranscription]\": (s)=>({\n                        ...s,\n                        isTranscribing: false\n                    })\n            }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n        }\n    }[\"useWhisperLive.useCallback[stopTranscription]\"], []);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[disconnect]\": ()=>{\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            stopTranscription();\n            setState({\n                isConnected: false,\n                isTranscribing: false,\n                transcript: '',\n                error: null\n            });\n        }\n    }[\"useWhisperLive.useCallback[disconnect]\"], [\n        stopTranscription\n    ]);\n    const clearTranscript = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[clearTranscript]\": ()=>{\n            setState({\n                \"useWhisperLive.useCallback[clearTranscript]\": (s)=>({\n                        ...s,\n                        transcript: ''\n                    })\n            }[\"useWhisperLive.useCallback[clearTranscript]\"]);\n        }\n    }[\"useWhisperLive.useCallback[clearTranscript]\"], []);\n    return {\n        state,\n        connect,\n        startTranscription,\n        stopTranscription,\n        disconnect,\n        clearTranscript,\n        wsRef,\n        audioData,\n        dataUpdateTrigger\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utd2hpc3Blci1saXZlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7b0VBRXFEO0FBQ1Q7QUF1QnJDLFNBQVNJLGVBQWVDLE1BQXlCO0lBQ3BELE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHUCwrQ0FBUUEsQ0FBbUI7UUFDakRRLGFBQWE7UUFDYkMsZ0JBQWdCO1FBQ2hCQyxZQUFZO1FBQ1pDLE9BQU87SUFDWDtJQUNBLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHYiwrQ0FBUUEsQ0FBb0I7SUFDOUQsTUFBTSxDQUFDYyxtQkFBbUJDLHFCQUFxQixHQUFHZiwrQ0FBUUEsQ0FBQztJQUMzRCxNQUFNZ0IsUUFBUWYsNkNBQU1BLENBQW1CO0lBQ3ZDLE1BQU1nQixzQkFBc0JoQiw2Q0FBTUEsQ0FBQztJQUVuQyxNQUFNaUIsU0FBU2pCLDZDQUFNQSxDQUNqQixPQUFPa0IsV0FBVyxlQUFlQSxPQUFPQyxVQUFVLEdBQzVDRCxPQUFPQyxVQUFVLEtBQ2pCQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxLQUFLLENBQUM7SUFFM0MsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR3RCLDBEQUFRQTtJQUUxQixNQUFNdUIsVUFBVXhCLGtEQUFXQTsrQ0FBQztZQUN4QnlCLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0J2QjtZQUMzQyxJQUFJVyxNQUFNYSxPQUFPLEVBQUU7Z0JBQ2ZiLE1BQU1hLE9BQU8sQ0FBQ0MsS0FBSztnQkFDbkJkLE1BQU1hLE9BQU8sR0FBRztZQUNwQjtZQUNBLDhFQUE4RTtZQUM5RSxNQUFNRSxNQUFNLElBQUlDLGFBQWE7Z0JBQUVDLFlBQVk7WUFBTTtZQUNqREMsT0FBT0wsT0FBTyxHQUFHRTtZQUNqQixNQUFNSSxtQkFBbUJKLElBQUlFLFVBQVU7WUFDdkNOLFFBQVFDLEdBQUcsQ0FBQyw4Q0FBOENPO1lBQzFENUI7dURBQVM2QixDQUFBQSxJQUFNO3dCQUFFLEdBQUdBLENB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O1lBQ2hDSzsrREFBUzZCLENBQUFBLElBQU07d0JBQUUsR0FBR0EsQ0FBQzt3QkFBRTFCLFlBQVk7b0JBQUc7O1FBQzFDO3NEQUFHLEVBQUU7SUFFTCxPQUFPO1FBQ0hKO1FBQ0FvQjtRQUNBMEM7UUFDQWdFO1FBQ0FHO1FBQ0FJO1FBQ0EzSDtRQUNBSjtRQUNBRTtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIkU6XFxBaXZvaWNldG90ZXh0XFxzcmNcXGhvb2tzXFx1c2Utd2hpc3Blci1saXZlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgdXNlVG9hc3QgfSBmcm9tICdAL2hvb2tzL3VzZS10b2FzdCdcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2hpc3BlckxpdmVDb25maWcge1xyXG4gICAgc2VydmVyVXJsOiBzdHJpbmdcclxuICAgIHBvcnQ6IG51bWJlclxyXG4gICAgbGFuZ3VhZ2U6IHN0cmluZ1xyXG4gICAgdHJhbnNsYXRlOiBib29sZWFuXHJcbiAgICBtb2RlbDogc3RyaW5nXHJcbiAgICB2YWQ6IGJvb2xlYW5cclxuICAgIHNhdmVSZWNvcmRpbmc6IGJvb2xlYW5cclxuICAgIG91dHB1dEZpbGVuYW1lOiBzdHJpbmdcclxuICAgIG1heENsaWVudHM6IG51bWJlclxyXG4gICAgbWF4Q29ubmVjdGlvblRpbWU6IG51bWJlclxyXG4gICAgYXVkaW9Tb3VyY2VzPzogeyBtaWNyb3Bob25lOiBib29sZWFuOyBzeXN0ZW1BdWRpbzogYm9vbGVhbiB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBXaGlzcGVyTGl2ZVN0YXRlIHtcclxuICAgIGlzQ29ubmVjdGVkOiBib29sZWFuXHJcbiAgICBpc1RyYW5zY3JpYmluZzogYm9vbGVhblxyXG4gICAgdHJhbnNjcmlwdDogc3RyaW5nXHJcbiAgICBlcnJvcjogc3RyaW5nIHwgbnVsbFxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlV2hpc3BlckxpdmUoY29uZmlnOiBXaGlzcGVyTGl2ZUNvbmZpZykge1xyXG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxXaGlzcGVyTGl2ZVN0YXRlPih7XHJcbiAgICAgICAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzVHJhbnNjcmliaW5nOiBmYWxzZSxcclxuICAgICAgICB0cmFuc2NyaXB0OiAnJyxcclxuICAgICAgICBlcnJvcjogbnVsbCxcclxuICAgIH0pXHJcbiAgICBjb25zdCBbYXVkaW9EYXRhLCBzZXRBdWRpb0RhdGFdID0gdXNlU3RhdGU8VWludDhBcnJheSB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCBbZGF0YVVwZGF0ZVRyaWdnZXIsIHNldERhdGFVcGRhdGVUcmlnZ2VyXSA9IHVzZVN0YXRlKDApXHJcbiAgICBjb25zdCB3c1JlZiA9IHVzZVJlZjxXZWJTb2NrZXQgfCBudWxsPihudWxsKVxyXG4gICAgY29uc3QgbGFzdFNlZ21lbnRJbmRleFJlZiA9IHVzZVJlZigwKVxyXG5cclxuICAgIGNvbnN0IHVpZFJlZiA9IHVzZVJlZihcclxuICAgICAgICB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRFxyXG4gICAgICAgICAgICA/IGNyeXB0by5yYW5kb21VVUlEKClcclxuICAgICAgICAgICAgOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxcclxuICAgIClcclxuICAgIGNvbnN0IHsgdG9hc3QgfSA9IHVzZVRvYXN0KClcclxuXHJcbiAgICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbdXNlV2hpc3BlckxpdmVdICBjb25uZWN0KCknLCBjb25maWcpO1xyXG4gICAgICAgIGlmICh3c1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAxKSBjcmVhdGUgQXVkaW9Db250ZXh0IG5vdyBzbyB3ZSBjYW4gaGFuZCBpdHMgcmVhbCBzYW1wbGVSYXRlIHRvIHRoZSBzZXJ2ZXJcclxuICAgICAgICBjb25zdCBjdHggPSBuZXcgQXVkaW9Db250ZXh0KHsgc2FtcGxlUmF0ZTogMTYwMDAgfSk7XHJcbiAgICAgICAgY3R4UmVmLmN1cnJlbnQgPSBjdHhcclxuICAgICAgICBjb25zdCBhY3R1YWxTYW1wbGVSYXRlID0gY3R4LnNhbXBsZVJhdGVcclxuICAgICAgICBjb25zb2xlLmxvZygnW3VzZVdoaXNwZXJMaXZlXSBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSA9JywgYWN0dWFsU2FtcGxlUmF0ZSlcclxuICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiBudWxsIH0pKVxyXG5cclxuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnd3NzJyA6ICd3cyc7XHJcbiAgICAgICAgY29uc3Qgd3MgPSBuZXcgV2ViU29ja2V0KGAke3Byb3RvY29sfTovLyR7Y29uZmlnLnNlcnZlclVybH06JHtjb25maWcucG9ydH1gKTtcclxuICAgICAgICB3cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xyXG4gICAgICAgIHdzUmVmLmN1cnJlbnQgPSB3c1xyXG5cclxuICAgICAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbdXNlV2hpc3BlckxpdmVdIPCfn6IgV2ViU29ja2V0IE9QRU4nKTtcclxuICAgICAgICAgICAgY29uc3QgdGFza05hbWUgPSBjb25maWcudHJhbnNsYXRlID8gJ3RyYW5zbGF0ZScgOiAndHJhbnNjcmliZSdcclxuICAgICAgICAgICAgd3Muc2VuZChcclxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrOiB0YXNrTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZFJlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBjb25maWcubGFuZ3VhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IGNvbmZpZy5tb2RlbCxcclxuICAgICAgICAgICAgICAgICAgICB1c2VfdmFkOiBjb25maWcudmFkLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgc2VuZCB1cyB0aGUgbmV3ZXN0IHNlZ21lbnQgZWFjaCB0aW1lOlxyXG4gICAgICAgICAgICAgICAgICAgIHNlbmRfbGFzdF9uX3NlZ21lbnRzOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVfcmVjb3JkaW5nOiBjb25maWcuc2F2ZVJlY29yZGluZyxcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRfZmlsZW5hbWU6IGNvbmZpZy5vdXRwdXRGaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhfY2xpZW50czogY29uZmlnLm1heENsaWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4X2Nvbm5lY3Rpb25fdGltZTogY29uZmlnLm1heENvbm5lY3Rpb25UaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICoqaW1wb3J0YW50Kio6IG11c3QgbWF0Y2ggeW91ciBBdWRpb0NvbnRleHQgJiBTY3JpcHRQcm9jZXNzb3JcclxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVfcmF0ZTogYWN0dWFsU2FtcGxlUmF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBjaHVua19zaXplOiA0MDk2LFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgc3RhcnRUcmFuc2NyaXB0aW9uKCk7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNDb25uZWN0ZWQ6IHRydWUgfSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpbnNpZGUgeW91ciBjb25uZWN0KClcclxuICAgICAgICB3cy5vbm1lc3NhZ2UgPSBlID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JhdyBXUyBNZXNzYWdlOicsIGUuZGF0YSlcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRhdGEgIT09ICdzdHJpbmcnKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSBoYW5kc2hha2VcclxuICAgICAgICAgICAgaWYgKG1zZy5tZXNzYWdlID09PSAnU0VSVkVSX1JFQURZJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gZXJyb3JzXHJcbiAgICAgICAgICAgIGlmIChtc2cudHlwZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogbXNnLm1lc3NhZ2UgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBvbGTigJBzdHlsZSBwYXJ0aWFsL2ZpbmFsIChpZiB5b3UgZXZlciB0b2dnbGUgdGhhdCBiYWNrIG9uKVxyXG4gICAgICAgICAgICBpZiAobXNnLnR5cGUgPT09ICdwYXJ0aWFsJyB8fCBtc2cudHlwZSA9PT0gJ3RyYW5zY3JpcHQnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucyxcclxuICAgICAgICAgICAgICAgICAgICBpc1RyYW5zY3JpYmluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NyaXB0OiBzLnRyYW5zY3JpcHQgKyBtc2cudGV4dFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtc2cudHlwZSA9PT0gJ2ZpbmFsJykge1xyXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUcmFuc2NyaWJpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY3JpcHQ6IHMudHJhbnNjcmlwdCArIG1zZy50ZXh0ICsgJ1xcbidcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g4oaQIE5FVzogaGFuZGxlIHRoZSBgc2VnbWVudHNgIGFycmF5XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1zZy5zZWdtZW50cykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0gbXNnLnNlZ21lbnRzXHJcbiAgICAgICAgICAgICAgICAvLyBncmFiIG9ubHkgdGhvc2Ugd2UgaGF2ZW7igJl0IGFwcGVuZGVkIHlldFxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U2VnbWVudHMgPSBzZWdtZW50cy5zbGljZShsYXN0U2VnbWVudEluZGV4UmVmLmN1cnJlbnQpXHJcbiAgICAgICAgICAgICAgICBpZiAobmV3U2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dFRvQXBwZW5kID0gbmV3U2VnbWVudHMubWFwKChzOiBhbnkpID0+IHMudGV4dCkuam9pbignJylcclxuICAgICAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVHJhbnNjcmliaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2NyaXB0OiBzLnRyYW5zY3JpcHQgKyB0ZXh0VG9BcHBlbmRcclxuICAgICAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICAgICAgICAvLyByZW1lbWJlciBob3cgbWFueSB3ZeKAmXZlIGNvbnN1bWVkXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRJbmRleFJlZi5jdXJyZW50ID0gc2VnbWVudHMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBhbnkgc3RyYXkgYG1zZy5tZXNzYWdlYFxyXG4gICAgICAgICAgICBpZiAobXNnLm1lc3NhZ2UgJiYgbXNnLm1lc3NhZ2UgIT09ICdTRVJWRVJfUkVBRFknKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucyxcclxuICAgICAgICAgICAgICAgICAgICBpc1RyYW5zY3JpYmluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NyaXB0OiBzLnRyYW5zY3JpcHQgKyBtc2cubWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIHdzLm9uY2xvc2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNDb25uZWN0ZWQ6IGZhbHNlLCBpc1RyYW5zY3JpYmluZzogZmFsc2UgfSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3cy5vbmVycm9yID0gKGVycikgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t1c2VXaGlzcGVyTGl2ZV0gV2ViU29ja2V0IGVycm9yIChub27igJFmYXRhbCknLCBlcnIpO1xyXG4gICAgICAgICAgICAvLyBkb27igJl0IHNldFN0YXRlIG9yIHRvYXN0IGhlcmVcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2NvbmZpZywgdG9hc3RdKVxyXG5cclxuICAgIGNvbnN0IG1pY1JlZiA9IHVzZVJlZjxNZWRpYVN0cmVhbSB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCBzeXN0ZW1SZWYgPSB1c2VSZWY8TWVkaWFTdHJlYW0gfCBudWxsPihudWxsKVxyXG4gICAgY29uc3QgY3R4UmVmID0gdXNlUmVmPEF1ZGlvQ29udGV4dCB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCBwcm9jZXNzb3JSZWYgPSB1c2VSZWY8U2NyaXB0UHJvY2Vzc29yTm9kZSB8IG51bGw+KG51bGwpXHJcblxyXG4gICAgY29uc3Qgc3RhcnRUcmFuc2NyaXB0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGlmICghd3NSZWYuY3VycmVudCB8fCB3c1JlZi5jdXJyZW50LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgZXJyb3I6ICdOb3QgY29ubmVjdGVkJyB9KSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIDEpIFNjcmVlbiArIHN5c3RlbSBhdWRpbyAoaWYgZW5hYmxlZClcclxuICAgICAgICAgICAgbGV0IHN5c3RlbVN0cmVhbTogTWVkaWFTdHJlYW0gfCBudWxsID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5hdWRpb1NvdXJjZXM/LnN5c3RlbUF1ZGlvKSB7XHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1TdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlkZW86IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHN5c3RlbVJlZi5jdXJyZW50ID0gc3lzdGVtU3RyZWFtO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAyKSBNaWNyb3Bob25lXHJcbiAgICAgICAgICAgIGNvbnN0IG1pY1N0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcclxuICAgICAgICAgICAgICAgIGF1ZGlvOiB7IHNhbXBsZVJhdGU6IDE2MDAwLCBjaGFubmVsQ291bnQ6IDEgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1pY1JlZi5jdXJyZW50ID0gbWljU3RyZWFtO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGN0eFJlZi5jdXJyZW50IVxyXG4gICAgICAgICAgICBjb25zdCBkZXN0ID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKVxyXG5cclxuICAgICAgICAgICAgLy8gNCkgV2lyZSBtaWMg4oaSIGRlc3RcclxuICAgICAgICAgICAgY29uc3QgbWljU3JjID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG1pY1N0cmVhbSk7XHJcbiAgICAgICAgICAgIG1pY1NyYy5jb25uZWN0KGRlc3QpO1xyXG5cclxuICAgICAgICAgICAgLy8gNSkgV2lyZSBzeXN0ZW0gYXVkaW8g4oaSIGRlc3RcclxuICAgICAgICAgICAgaWYgKHN5c3RlbVN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3lzU3JjID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN5c3RlbVN0cmVhbSk7XHJcbiAgICAgICAgICAgICAgICBzeXNTcmMuY29ubmVjdChkZXN0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gNikgSW5zdGVhZCBvZiB3aXJpbmcgbWljK3N5cyBkaXJlY3RseSB0byB0aGUgcHJvY2Vzc29yLCB3ZVxyXG4gICAgICAgICAgICAvLyAgICB0YWtlIHRoZSBtaXhlZCBkZXN0LnN0cmVhbSBhbmQgaG9vayB0aGF0IHVwOlxyXG4gICAgICAgICAgICBjb25zdCBtaXhlZFNyYyA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShkZXN0LnN0cmVhbSk7XHJcblxyXG4gICAgICAgICAgICAvLyA3KSBDcmVhdGUgeW91ciBTY3JpcHRQcm9jZXNzb3IgKGJ1ZmZlclNpemU9NDA5NiwgbW9ubyBpbi9vdXQpXHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NvciA9IGN0eC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoNDA5NiwgMSwgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyA4KSBXaXJlIHRoZSBtaXhlZCBhdWRpbyBpbnRvIHRoZSBwcm9jZXNzb3JcclxuICAgICAgICAgICAgbWl4ZWRTcmMuY29ubmVjdChwcm9jZXNzb3IpO1xyXG5cclxuICAgICAgICAgICAgLy8gOSkgT24gZWFjaCBvbmF1ZGlvcHJvY2VzcywgYnVpbGQgZXhhY3RseSBvbmUgcGFja2V0XHJcbiAgICAgICAgICAgIHByb2Nlc3Nvci5vbmF1ZGlvcHJvY2VzcyA9IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmxvYXQzMiA9IGUuaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMClcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZsb2F0MzJCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGZsb2F0MzIpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8g4oaSIGNvbnZlcnQgdG8gVWludDhBcnJheSBbMC4uMjU1XVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdWk4ID0gbmV3IFVpbnQ4QXJyYXkoZmxvYXQzMkJ1ZmZlci5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZsb2F0MzJCdWZmZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB1aThbaV0gPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgMjU1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgwLCBNYXRoLmZsb29yKChmbG9hdDMyQnVmZmVyW2ldICsgMSkgKiAxMjcuNSkpXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNlbmQgcmF3IGZsb2F0MzIgUENNIHRvIHNlcnZlclxyXG4gICAgICAgICAgICAgICAgaWYgKHdzUmVmLmN1cnJlbnQhLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd3NSZWYuY3VycmVudCEuc2VuZChmbG9hdDMyQnVmZmVyLmJ1ZmZlcilcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdmlzdWFsaXplclxyXG4gICAgICAgICAgICAgICAgc2V0QXVkaW9EYXRhKHVpOClcclxuICAgICAgICAgICAgICAgIHNldERhdGFVcGRhdGVUcmlnZ2VyKHQgPT4gdCArIDEpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDEwKSBTdGFydCBpdFxyXG4gICAgICAgICAgICBwcm9jZXNzb3IuY29ubmVjdChjdHguZGVzdGluYXRpb24pO1xyXG4gICAgICAgICAgICBwcm9jZXNzb3JSZWYuY3VycmVudCA9IHByb2Nlc3NvcjtcclxuXHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNUcmFuc2NyaWJpbmc6IHRydWUgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogYEZhaWxlZCB0byBzdGFydCB0cmFuc2NyaXB0aW9uOiAke2Vyci5tZXNzYWdlfWAgfSkpO1xyXG4gICAgICAgICAgICB0b2FzdCh7IHRpdGxlOiAnVHJhbnNjcmlwdGlvbiBFcnJvcicsIGRlc2NyaXB0aW9uOiBlcnIubWVzc2FnZSwgdmFyaWFudDogJ2Rlc3RydWN0aXZlJyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbY29uZmlnLCB0b2FzdF0pO1xyXG5cclxuXHJcbiAgICBjb25zdCBzdG9wVHJhbnNjcmlwdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAod3NSZWYuY3VycmVudD8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgLy8gemVyb+KAkWxlbmd0aCBBcnJheUJ1ZmZlciBzaWduYWxzIOKAnHBsZWFzZSBmbHVzaCAmIGZpbmlzaOKAnVxyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50LnNlbmQobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFwiRU5EX09GX0FVRElPXCIpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRlYXIgZG93biBhdWRpbyBncmFwaCBpbW1lZGlhdGVseVxyXG4gICAgICAgIGlmIChwcm9jZXNzb3JSZWYuY3VycmVudCkgeyBwcm9jZXNzb3JSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7IHByb2Nlc3NvclJlZi5jdXJyZW50ID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChtaWNSZWYuY3VycmVudCkgeyBtaWNSZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKHQgPT4gdC5zdG9wKCkpOyBtaWNSZWYuY3VycmVudCA9IG51bGw7IH1cclxuICAgICAgICBpZiAoc3lzdGVtUmVmLmN1cnJlbnQpIHsgc3lzdGVtUmVmLmN1cnJlbnQuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTsgc3lzdGVtUmVmLmN1cnJlbnQgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGN0eFJlZi5jdXJyZW50KSB7IGN0eFJlZi5jdXJyZW50LmNsb3NlKCk7IGN0eFJlZi5jdXJyZW50ID0gbnVsbDsgfVxyXG5cclxuICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGlzVHJhbnNjcmliaW5nOiBmYWxzZSB9KSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG5cclxuICAgIGNvbnN0IGRpc2Nvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKHdzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudC5jbG9zZSgpXHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3BUcmFuc2NyaXB0aW9uKClcclxuICAgICAgICBzZXRTdGF0ZSh7IGlzQ29ubmVjdGVkOiBmYWxzZSwgaXNUcmFuc2NyaWJpbmc6IGZhbHNlLCB0cmFuc2NyaXB0OiAnJywgZXJyb3I6IG51bGwgfSlcclxuICAgIH0sIFtzdG9wVHJhbnNjcmlwdGlvbl0pXHJcblxyXG4gICAgY29uc3QgY2xlYXJUcmFuc2NyaXB0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgdHJhbnNjcmlwdDogJycgfSkpXHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXRlLFxyXG4gICAgICAgIGNvbm5lY3QsXHJcbiAgICAgICAgc3RhcnRUcmFuc2NyaXB0aW9uLFxyXG4gICAgICAgIHN0b3BUcmFuc2NyaXB0aW9uLFxyXG4gICAgICAgIGRpc2Nvbm5lY3QsXHJcbiAgICAgICAgY2xlYXJUcmFuc2NyaXB0LFxyXG4gICAgICAgIHdzUmVmLFxyXG4gICAgICAgIGF1ZGlvRGF0YSxcclxuICAgICAgICBkYXRhVXBkYXRlVHJpZ2dlcixcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZVRvYXN0IiwidXNlV2hpc3BlckxpdmUiLCJjb25maWciLCJzdGF0ZSIsInNldFN0YXRlIiwiaXNDb25uZWN0ZWQiLCJpc1RyYW5zY3JpYmluZyIsInRyYW5zY3JpcHQiLCJlcnJvciIsImF1ZGlvRGF0YSIsInNldEF1ZGlvRGF0YSIsImRhdGFVcGRhdGVUcmlnZ2VyIiwic2V0RGF0YVVwZGF0ZVRyaWdnZXIiLCJ3c1JlZiIsImxhc3RTZWdtZW50SW5kZXhSZWYiLCJ1aWRSZWYiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJ0b2FzdCIsImNvbm5lY3QiLCJjb25zb2xlIiwibG9nIiwiY3VycmVudCIsImNsb3NlIiwiY3R4IiwiQXVkaW9Db250ZXh0Iiwic2FtcGxlUmF0ZSIsImN0eFJlZiIsImFjdHVhbFNhbXBsZVJhdGUiLCJzIiwicHJvdG9jb2wiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIndzIiwiV2ViU29ja2V0Iiwic2VydmVyVXJsIiwicG9ydCIsImJpbmFyeVR5cGUiLCJvbm9wZW4iLCJ0YXNrTmFtZSIsInRyYW5zbGF0ZSIsInNlbmQiLCJKU09OIiwic3RyaW5naWZ5IiwidGFzayIsInVpZCIsImxhbmd1YWdlIiwibW9kZWwiLCJ1c2VfdmFkIiwidmFkIiwic2VuZF9sYXN0X25fc2VnbWVudHMiLCJzYXZlX3JlY29yZGluZyIsInNhdmVSZWNvcmRpbmciLCJvdXRwdXRfZmlsZW5hbWUiLCJvdXRwdXRGaWxlbmFtZSIsIm1heF9jbGllbnRzIiwibWF4Q2xpZW50cyIsIm1heF9jb25uZWN0aW9uX3RpbWUiLCJtYXhDb25uZWN0aW9uVGltZSIsInNhbXBsZV9yYXRlIiwiY2h1bmtfc2l6ZSIsInN0YXJ0VHJhbnNjcmlwdGlvbiIsIm9ubWVzc2FnZSIsImUiLCJkYXRhIiwibXNnIiwicGFyc2UiLCJtZXNzYWdlIiwidHlwZSIsInRleHQiLCJBcnJheSIsImlzQXJyYXkiLCJzZWdtZW50cyIsIm5ld1NlZ21lbnRzIiwibGVuZ3RoIiwidGV4dFRvQXBwZW5kIiwibWFwIiwiam9pbiIsIm9uY2xvc2UiLCJvbmVycm9yIiwiZXJyIiwid2FybiIsIm1pY1JlZiIsInN5c3RlbVJlZiIsInByb2Nlc3NvclJlZiIsInJlYWR5U3RhdGUiLCJPUEVOIiwic3lzdGVtU3RyZWFtIiwiYXVkaW9Tb3VyY2VzIiwic3lzdGVtQXVkaW8iLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXREaXNwbGF5TWVkaWEiLCJ2aWRlbyIsImF1ZGlvIiwibWljU3RyZWFtIiwiZ2V0VXNlck1lZGlhIiwiY2hhbm5lbENvdW50IiwiZGVzdCIsImNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24iLCJtaWNTcmMiLCJjcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSIsInN5c1NyYyIsIm1peGVkU3JjIiwic3RyZWFtIiwicHJvY2Vzc29yIiwiY3JlYXRlU2NyaXB0UHJvY2Vzc29yIiwib25hdWRpb3Byb2Nlc3MiLCJmbG9hdDMyIiwiaW5wdXRCdWZmZXIiLCJnZXRDaGFubmVsRGF0YSIsImZsb2F0MzJCdWZmZXIiLCJGbG9hdDMyQXJyYXkiLCJ1aTgiLCJVaW50OEFycmF5IiwiaSIsIm1pbiIsIm1heCIsImZsb29yIiwiYnVmZmVyIiwidCIsImRlc3RpbmF0aW9uIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInZhcmlhbnQiLCJzdG9wVHJhbnNjcmlwdGlvbiIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiZGlzY29ubmVjdCIsImdldFRyYWNrcyIsImZvckVhY2giLCJzdG9wIiwiY2xlYXJUcmFuc2NyaXB0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-whisper-live.ts\n"));

/***/ })

});