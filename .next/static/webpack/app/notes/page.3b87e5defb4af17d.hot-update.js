"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/notes/page",{

/***/ "(app-pages-browser)/./src/hooks/use-whisper-live.ts":
/*!***************************************!*\
  !*** ./src/hooks/use-whisper-live.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWhisperLive: () => (/* binding */ useWhisperLive)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/hooks/use-toast */ \"(app-pages-browser)/./src/hooks/use-toast.ts\");\n/* __next_internal_client_entry_do_not_use__ useWhisperLive auto */ \n\nfunction useWhisperLive(config) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        isTranscribing: false,\n        transcript: '',\n        error: null\n    });\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const uidRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));\n    const { toast } = (0,_hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__.useToast)();\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[connect]\": ()=>{\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            setState({\n                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                        ...s,\n                        error: null\n                    })\n            }[\"useWhisperLive.useCallback[connect]\"]);\n            const ws = new WebSocket(\"ws://\".concat(config.serverUrl, \":\").concat(config.port));\n            ws.binaryType = 'arraybuffer';\n            wsRef.current = ws;\n            ws.onopen = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    const taskName = config.translate ? 'translate' : 'transcribe';\n                    ws.send(JSON.stringify({\n                        task: taskName,\n                        uid: uidRef.current,\n                        language: config.language,\n                        model: config.model,\n                        vad: config.vad,\n                        save_recording: config.saveRecording,\n                        output_filename: config.outputFilename,\n                        max_clients: config.maxClients,\n                        max_connection_time: config.maxConnectionTime,\n                        // **important**: must match your AudioContext & ScriptProcessor\n                        sample_rate: 16000,\n                        chunk_size: 4096\n                    }));\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: true\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onmessage = ({\n                \"useWhisperLive.useCallback[connect]\": (e)=>{\n                    console.log('[WS message]', e.data);\n                    if (typeof e.data === 'string') {\n                        const msg = JSON.parse(e.data);\n                        if (msg.type === 'transcript') {\n                            setState({\n                                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                        ...s,\n                                        transcript: s.transcript + msg.text\n                                    })\n                            }[\"useWhisperLive.useCallback[connect]\"]);\n                        } else if (msg.type === 'error') {\n                            setState({\n                                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                        ...s,\n                                        error: msg.message\n                                    })\n                            }[\"useWhisperLive.useCallback[connect]\"]);\n                        }\n                    }\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onclose = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: false,\n                                isTranscribing: false\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onerror = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                error: 'WebSocket connection failed'\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                    toast({\n                        title: 'Connection Error',\n                        description: 'Failed to connect to WhisperLive server',\n                        variant: 'destructive'\n                    });\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n        }\n    }[\"useWhisperLive.useCallback[connect]\"], [\n        config,\n        toast\n    ]);\n    const micRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const systemRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ctxRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const processorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const startTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[startTranscription]\": async ()=>{\n            if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: 'Not connected'\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                return;\n            }\n            try {\n                var _config_audioSources;\n                // 1) Screen + system audio (if enabled)\n                let systemStream = null;\n                if ((_config_audioSources = config.audioSources) === null || _config_audioSources === void 0 ? void 0 : _config_audioSources.systemAudio) {\n                    systemStream = await navigator.mediaDevices.getDisplayMedia({\n                        video: true,\n                        audio: true\n                    });\n                    systemRef.current = systemStream;\n                }\n                // 2) Microphone\n                const micStream = await navigator.mediaDevices.getUserMedia({\n                    audio: {\n                        sampleRate: 16000,\n                        channelCount: 1\n                    }\n                });\n                micRef.current = micStream;\n                // 3) Build an AudioContext + a single destination to mix into\n                const ctx = new AudioContext({\n                    sampleRate: 16000\n                });\n                ctxRef.current = ctx;\n                const dest = ctx.createMediaStreamDestination();\n                // 4) Wire mic → dest\n                const micSrc = ctx.createMediaStreamSource(micStream);\n                micSrc.connect(dest);\n                // 5) Wire system audio → dest\n                if (systemStream) {\n                    const sysSrc = ctx.createMediaStreamSource(systemStream);\n                    sysSrc.connect(dest);\n                }\n                // 6) Instead of wiring mic+sys directly to the processor, we\n                //    take the mixed dest.stream and hook that up:\n                const mixedSrc = ctx.createMediaStreamSource(dest.stream);\n                // 7) Create your ScriptProcessor (bufferSize=4096, mono in/out)\n                const processor = ctx.createScriptProcessor(4096, 1, 1);\n                // 8) Wire the mixed audio into the processor\n                mixedSrc.connect(processor);\n                // 9) On each onaudioprocess, build exactly one packet\n                processor.onaudioprocess = ({\n                    \"useWhisperLive.useCallback[startTranscription]\": (e)=>{\n                        var _wsRef_current;\n                        const float32 = e.inputBuffer.getChannelData(0);\n                        const int16 = new Int16Array(float32.length);\n                        for(let i = 0; i < float32.length; i++){\n                            int16[i] = Math.max(-32768, Math.min(32767, float32[i] * 32767));\n                        }\n                        if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                            wsRef.current.send(int16.buffer);\n                        }\n                    }\n                })[\"useWhisperLive.useCallback[startTranscription]\"];\n                // 10) Start it\n                processor.connect(ctx.destination);\n                processorRef.current = processor;\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            isTranscribing: true\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n            } catch (err) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: \"Failed to start transcription: \".concat(err.message)\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                toast({\n                    title: 'Transcription Error',\n                    description: err.message,\n                    variant: 'destructive'\n                });\n            }\n        }\n    }[\"useWhisperLive.useCallback[startTranscription]\"], [\n        config,\n        toast\n    ]);\n    const stopTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[stopTranscription]\": ()=>{\n            var _wsRef_current;\n            if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                // zero‑length ArrayBuffer signals “please flush & finish”\n                wsRef.current.send(new ArrayBuffer(0));\n            }\n            // tear down audio graph immediately\n            if (processorRef.current) {\n                processorRef.current.disconnect();\n                processorRef.current = null;\n            }\n            if (micRef.current) {\n                micRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                micRef.current = null;\n            }\n            if (systemRef.current) {\n                systemRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                systemRef.current = null;\n            }\n            if (ctxRef.current) {\n                ctxRef.current.close();\n                ctxRef.current = null;\n            }\n            setState({\n                \"useWhisperLive.useCallback[stopTranscription]\": (s)=>({\n                        ...s,\n                        isTranscribing: false\n                    })\n            }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n        }\n    }[\"useWhisperLive.useCallback[stopTranscription]\"], []);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[disconnect]\": ()=>{\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            stopTranscription();\n            setState({\n                isConnected: false,\n                isTranscribing: false,\n                transcript: '',\n                error: null\n            });\n        }\n    }[\"useWhisperLive.useCallback[disconnect]\"], [\n        stopTranscription\n    ]);\n    const clearTranscript = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[clearTranscript]\": ()=>{\n            setState({\n                \"useWhisperLive.useCallback[clearTranscript]\": (s)=>({\n                        ...s,\n                        transcript: ''\n                    })\n            }[\"useWhisperLive.useCallback[clearTranscript]\"]);\n        }\n    }[\"useWhisperLive.useCallback[clearTranscript]\"], []);\n    return {\n        state,\n        connect,\n        startTranscription,\n        stopTranscription,\n        disconnect,\n        clearTranscript,\n        wsRef\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utd2hpc3Blci1saXZlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7b0VBRXFEO0FBQ1Q7QUF1QnJDLFNBQVNJLGVBQWVDLE1BQXlCO0lBQ3BELE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHUCwrQ0FBUUEsQ0FBbUI7UUFDakRRLGFBQWE7UUFDYkMsZ0JBQWdCO1FBQ2hCQyxZQUFZO1FBQ1pDLE9BQU87SUFDWDtJQUVBLE1BQU1DLFFBQVFYLDZDQUFNQSxDQUFtQjtJQUN2QyxNQUFNWSxTQUFTWiw2Q0FBTUEsQ0FDakIsT0FBT2EsV0FBVyxlQUFlQSxPQUFPQyxVQUFVLEdBQzVDRCxPQUFPQyxVQUFVLEtBQ2pCQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxLQUFLLENBQUM7SUFFM0MsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR2pCLDBEQUFRQTtJQUUxQixNQUFNa0IsVUFBVW5CLGtEQUFXQTsrQ0FBQztZQUN4QixJQUFJVSxNQUFNVSxPQUFPLEVBQUU7Z0JBQ2ZWLE1BQU1VLE9BQU8sQ0FBQ0MsS0FBSztnQkFDbkJYLE1BQU1VLE9BQU8sR0FBRztZQUNwQjtZQUNBZjt1REFBU2lCLENBQUFBLElBQU07d0JBQUUsR0FBR0EsQ0FBQzt3QkFBRWIsT0FBTztvQkFBSzs7WUFFbkMsTUFBTWMsS0FBSyxJQUFJQyxVQUFVLFFBQTRCckIsT0FBcEJBLE9BQU9zQixTQUFTLEVBQUMsS0FBZSxPQUFadEIsT0FBT3VCLElBQUk7WUFDaEVILEdBQUdJLFVBQVUsR0FBRztZQUNoQmpCLE1BQU1VLE9BQU8sR0FBR0c7WUFFaEJBLEdBQUdLLE1BQU07dURBQUc7b0JBQ1IsTUFBTUMsV0FBVzFCLE9BQU8yQixTQUFTLEdBQUcsY0FBYztvQkFDbERQLEdBQUdRLElBQUksQ0FDSEMsS0FBS0MsU0FBUyxDQUFDO3dCQUNYQyxNQUFNTDt3QkFDTk0sS0FBS3hCLE9BQU9TLE9BQU87d0JBQ25CZ0IsVUFBVWpDLE9BQU9pQyxRQUFRO3dCQUN6QkMsT0FBT2xDLE9BQU9rQyxLQUFLO3dCQUNuQkMsS0FBS25DLE9BQU9tQyxHQUFHO3dCQUNmQyxnQkFBZ0JwQyxPQUFPcUMsYUFBYTt3QkFDcENDLGlCQUFpQnRDLE9BQU91QyxjQUFjO3dCQUN0Q0MsYUFBYXhDLE9BQU95QyxVQUFVO3dCQUM5QkMscUJBQXFCMUMsT0FBTzJDLGlCQUFpQjt3QkFDN0MsZ0VBQWdFO3dCQUNoRUMsYUFBYTt3QkFDYkMsWUFBWTtvQkFDaEI7b0JBRUozQzsrREFBU2lCLENBQUFBLElBQU07Z0NBQUUsR0FBR0EsQ0FBQztnQ0FBRWhCLGFBQWE7NEJBQUs7O2dCQUM3Qzs7WUFFQWlCLEdBQUcwQixTQUFTO3VEQUFHQyxDQUFBQTtvQkFDWEMsUUFBUUMsR0FBRyxDQUFDLGdCQUFnQkYsRUFBRUcsSUFBSTtvQkFDbEMsSUFBSSxPQUFPSCxFQUFFRyxJQUFJLEtBQUssVUFBVTt3QkFDNUIsTUFBTUMsTUFBTXRCLEtBQUt1QixLQUFLLENBQUNMLEVBQUVHLElBQUk7d0JBQzdCLElBQUlDLElBQUlFLElBQUksS0FBSyxjQUFjOzRCQUMzQm5EO3VFQUFTaUIsQ0FBQUEsSUFBTTt3Q0FBRSxHQUFHQSxDQUFDO3dDQUFFZCxZQUFZYyxFQUFFZCxVQUFVLEdBQUc4QyxJQUFJRyxJQUFJO29DQUFDOzt3QkFDL0QsT0FBTyxJQUFJSCxJQUFJRSxJQUFJLEtBQUssU0FBUzs0QkFDN0JuRDt1RUFBU2lCLENBQUFBLElBQU07d0NBQUUsR0FBR0EsQ0FBQzt3Q0FBRWIsT0FBTzZDLElBQUlJLE9BQU87b0NBQUM7O3dCQUM5QztvQkFDSjtnQkFDSjs7WUFHQW5DLEdBQUdvQyxPQUFPO3VEQUFHO29CQUNUdEQ7K0RBQVNpQixDQUFBQSxJQUFNO2dDQUFFLEdBQUdBLENBQUM7Z0NBQUVoQixhQUFhO2dDQUFPQyxnQkFBZ0I7NEJBQU07O2dCQUNyRTs7WUFFQWdCLEdBQUdxQyxPQUFPO3VEQUFHO29CQUNUdkQ7K0RBQVNpQixDQUFBQSxJQUFNO2dDQUFFLEdBQUdBLENBQUM7Z0NBQUViLE9BQU87NEJBQThCOztvQkFDNURTLE1BQU07d0JBQ0YyQyxPQUFPO3dCQUNQQyxhQUFhO3dCQUNiQyxTQUFTO29CQUNiO2dCQUNKOztRQUNKOzhDQUFHO1FBQUM1RDtRQUFRZTtLQUFNO0lBRWxCLE1BQU04QyxTQUFTakUsNkNBQU1BLENBQXFCO0lBQzFDLE1BQU1rRSxZQUFZbEUsNkNBQU1BLENBQXFCO0lBQzdDLE1BQU1tRSxTQUFTbkUsNkNBQU1BLENBQXNCO0lBQzNDLE1BQU1vRSxlQUFlcEUsNkNBQU1BLENBQTZCO0lBRXhELE1BQU1xRSxxQkFBcUJwRSxrREFBV0E7MERBQUM7WUFDbkMsSUFBSSxDQUFDVSxNQUFNVSxPQUFPLElBQUlWLE1BQU1VLE9BQU8sQ0FBQ2lELFVBQVUsS0FBSzdDLFVBQVU4QyxJQUFJLEVBQUU7Z0JBQy9EakU7c0VBQVNpQixDQUFBQSxJQUFNOzRCQUFFLEdBQUdBLENBQUM7NEJBQUViLE9BQU87d0JBQWdCOztnQkFDOUM7WUFDSjtZQUVBLElBQUk7b0JBR0lOO2dCQUZKLHdDQUF3QztnQkFDeEMsSUFBSW9FLGVBQW1DO2dCQUN2QyxLQUFJcEUsdUJBQUFBLE9BQU9xRSxZQUFZLGNBQW5CckUsMkNBQUFBLHFCQUFxQnNFLFdBQVcsRUFBRTtvQkFDbENGLGVBQWUsTUFBTUcsVUFBVUMsWUFBWSxDQUFDQyxlQUFlLENBQUM7d0JBQ3hEQyxPQUFPO3dCQUNQQyxPQUFPO29CQUNYO29CQUNBYixVQUFVN0MsT0FBTyxHQUFHbUQ7Z0JBQ3hCO2dCQUVBLGdCQUFnQjtnQkFDaEIsTUFBTVEsWUFBWSxNQUFNTCxVQUFVQyxZQUFZLENBQUNLLFlBQVksQ0FBQztvQkFDeERGLE9BQU87d0JBQUVHLFlBQVk7d0JBQU9DLGNBQWM7b0JBQUU7Z0JBQ2hEO2dCQUNBbEIsT0FBTzVDLE9BQU8sR0FBRzJEO2dCQUVqQiw4REFBOEQ7Z0JBQzlELE1BQU1JLE1BQU0sSUFBSUMsYUFBYTtvQkFBRUgsWUFBWTtnQkFBTTtnQkFDakRmLE9BQU85QyxPQUFPLEdBQUcrRDtnQkFDakIsTUFBTUUsT0FBT0YsSUFBSUcsNEJBQTRCO2dCQUU3QyxxQkFBcUI7Z0JBQ3JCLE1BQU1DLFNBQVNKLElBQUlLLHVCQUF1QixDQUFDVDtnQkFDM0NRLE9BQU9wRSxPQUFPLENBQUNrRTtnQkFFZiw4QkFBOEI7Z0JBQzlCLElBQUlkLGNBQWM7b0JBQ2QsTUFBTWtCLFNBQVNOLElBQUlLLHVCQUF1QixDQUFDakI7b0JBQzNDa0IsT0FBT3RFLE9BQU8sQ0FBQ2tFO2dCQUNuQjtnQkFFQSw2REFBNkQ7Z0JBQzdELGtEQUFrRDtnQkFDbEQsTUFBTUssV0FBV1AsSUFBSUssdUJBQXVCLENBQUNILEtBQUtNLE1BQU07Z0JBRXhELGdFQUFnRTtnQkFDaEUsTUFBTUMsWUFBWVQsSUFBSVUscUJBQXFCLENBQUMsTUFBTSxHQUFHO2dCQUVyRCw2Q0FBNkM7Z0JBQzdDSCxTQUFTdkUsT0FBTyxDQUFDeUU7Z0JBRWpCLHNEQUFzRDtnQkFDdERBLFVBQVVFLGNBQWM7c0VBQUc1QyxDQUFBQTs0QkFPbkJ4Qzt3QkFOSixNQUFNcUYsVUFBVTdDLEVBQUU4QyxXQUFXLENBQUNDLGNBQWMsQ0FBQzt3QkFDN0MsTUFBTUMsUUFBUSxJQUFJQyxXQUFXSixRQUFRSyxNQUFNO3dCQUMzQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sUUFBUUssTUFBTSxFQUFFQyxJQUFLOzRCQUNyQ0gsS0FBSyxDQUFDRyxFQUFFLEdBQUd2RixLQUFLd0YsR0FBRyxDQUFDLENBQUMsT0FDakJ4RixLQUFLeUYsR0FBRyxDQUFDLE9BQU9SLE9BQU8sQ0FBQ00sRUFBRSxHQUFHO3dCQUNyQzt3QkFDQSxJQUFJM0YsRUFBQUEsaUJBQUFBLE1BQU1VLE9BQU8sY0FBYlYscUNBQUFBLGVBQWUyRCxVQUFVLE1BQUs3QyxVQUFVOEMsSUFBSSxFQUFFOzRCQUM5QzVELE1BQU1VLE9BQU8sQ0FBQ1csSUFBSSxDQUFDbUUsTUFBTU0sTUFBTTt3QkFDbkM7b0JBQ0o7O2dCQUVBLGVBQWU7Z0JBQ2ZaLFVBQVV6RSxPQUFPLENBQUNnRSxJQUFJc0IsV0FBVztnQkFDakN0QyxhQUFhL0MsT0FBTyxHQUFHd0U7Z0JBRXZCdkY7c0VBQVNpQixDQUFBQSxJQUFNOzRCQUFFLEdBQUdBLENBQUM7NEJBQUVmLGdCQUFnQjt3QkFBSzs7WUFDaEQsRUFDQSxPQUFPbUcsS0FBVTtnQkFDYnJHO3NFQUFTaUIsQ0FBQUEsSUFBTTs0QkFBRSxHQUFHQSxDQUFDOzRCQUFFYixPQUFPLGtDQUE4QyxPQUFaaUcsSUFBSWhELE9BQU87d0JBQUc7O2dCQUM5RXhDLE1BQU07b0JBQUUyQyxPQUFPO29CQUF1QkMsYUFBYTRDLElBQUloRCxPQUFPO29CQUFFSyxTQUFTO2dCQUFjO1lBQzNGO1FBQ0o7eURBQUc7UUFBQzVEO1FBQVFlO0tBQU07SUFHbEIsTUFBTXlGLG9CQUFvQjNHLGtEQUFXQTt5REFBQztnQkFDOUJVO1lBQUosSUFBSUEsRUFBQUEsaUJBQUFBLE1BQU1VLE9BQU8sY0FBYlYscUNBQUFBLGVBQWUyRCxVQUFVLE1BQUs3QyxVQUFVOEMsSUFBSSxFQUFFO2dCQUM5QywwREFBMEQ7Z0JBQzFENUQsTUFBTVUsT0FBTyxDQUFDVyxJQUFJLENBQUMsSUFBSTZFLFlBQVk7WUFDdkM7WUFFQSxvQ0FBb0M7WUFDcEMsSUFBSXpDLGFBQWEvQyxPQUFPLEVBQUU7Z0JBQUUrQyxhQUFhL0MsT0FBTyxDQUFDeUYsVUFBVTtnQkFBSTFDLGFBQWEvQyxPQUFPLEdBQUc7WUFBTTtZQUM1RixJQUFJNEMsT0FBTzVDLE9BQU8sRUFBRTtnQkFBRTRDLE9BQU81QyxPQUFPLENBQUMwRixTQUFTLEdBQUdDLE9BQU87cUVBQUNDLENBQUFBLElBQUtBLEVBQUVDLElBQUk7O2dCQUFLakQsT0FBTzVDLE9BQU8sR0FBRztZQUFNO1lBQ2hHLElBQUk2QyxVQUFVN0MsT0FBTyxFQUFFO2dCQUFFNkMsVUFBVTdDLE9BQU8sQ0FBQzBGLFNBQVMsR0FBR0MsT0FBTztxRUFBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsSUFBSTs7Z0JBQUtoRCxVQUFVN0MsT0FBTyxHQUFHO1lBQU07WUFDekcsSUFBSThDLE9BQU85QyxPQUFPLEVBQUU7Z0JBQUU4QyxPQUFPOUMsT0FBTyxDQUFDQyxLQUFLO2dCQUFJNkMsT0FBTzlDLE9BQU8sR0FBRztZQUFNO1lBRXJFZjtpRUFBU2lCLENBQUFBLElBQU07d0JBQUUsR0FBR0EsQ0FBQzt3QkFBRWYsZ0JBQWdCO29CQUFNOztRQUNqRDt3REFBRyxFQUFFO0lBR0wsTUFBTXNHLGFBQWE3RyxrREFBV0E7a0RBQUM7WUFDM0IsSUFBSVUsTUFBTVUsT0FBTyxFQUFFO2dCQUNmVixNQUFNVSxPQUFPLENBQUNDLEtBQUs7Z0JBQ25CWCxNQUFNVSxPQUFPLEdBQUc7WUFDcEI7WUFDQXVGO1lBQ0F0RyxTQUFTO2dCQUFFQyxhQUFhO2dCQUFPQyxnQkFBZ0I7Z0JBQU9DLFlBQVk7Z0JBQUlDLE9BQU87WUFBSztRQUN0RjtpREFBRztRQUFDa0c7S0FBa0I7SUFFdEIsTUFBTU8sa0JBQWtCbEgsa0RBQVdBO3VEQUFDO1lBQ2hDSzsrREFBU2lCLENBQUFBLElBQU07d0JBQUUsR0FBR0EsQ0FBQzt3QkFBRWQsWUFBWTtvQkFBRzs7UUFDMUM7c0RBQUcsRUFBRTtJQUVMLE9BQU87UUFDSEo7UUFDQWU7UUFDQWlEO1FBQ0F1QztRQUNBRTtRQUNBSztRQUNBeEc7SUFDSjtBQUNKIiwic291cmNlcyI6WyJFOlxcQWl2b2ljZXRvdGV4dFxcc3JjXFxob29rc1xcdXNlLXdoaXNwZXItbGl2ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IHVzZVRvYXN0IH0gZnJvbSAnQC9ob29rcy91c2UtdG9hc3QnXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFdoaXNwZXJMaXZlQ29uZmlnIHtcclxuICAgIHNlcnZlclVybDogc3RyaW5nXHJcbiAgICBwb3J0OiBudW1iZXJcclxuICAgIGxhbmd1YWdlOiBzdHJpbmdcclxuICAgIHRyYW5zbGF0ZTogYm9vbGVhblxyXG4gICAgbW9kZWw6IHN0cmluZ1xyXG4gICAgdmFkOiBib29sZWFuXHJcbiAgICBzYXZlUmVjb3JkaW5nOiBib29sZWFuXHJcbiAgICBvdXRwdXRGaWxlbmFtZTogc3RyaW5nXHJcbiAgICBtYXhDbGllbnRzOiBudW1iZXJcclxuICAgIG1heENvbm5lY3Rpb25UaW1lOiBudW1iZXJcclxuICAgIGF1ZGlvU291cmNlcz86IHsgbWljcm9waG9uZTogYm9vbGVhbjsgc3lzdGVtQXVkaW86IGJvb2xlYW4gfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgV2hpc3BlckxpdmVTdGF0ZSB7XHJcbiAgICBpc0Nvbm5lY3RlZDogYm9vbGVhblxyXG4gICAgaXNUcmFuc2NyaWJpbmc6IGJvb2xlYW5cclxuICAgIHRyYW5zY3JpcHQ6IHN0cmluZ1xyXG4gICAgZXJyb3I6IHN0cmluZyB8IG51bGxcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVdoaXNwZXJMaXZlKGNvbmZpZzogV2hpc3BlckxpdmVDb25maWcpIHtcclxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8V2hpc3BlckxpdmVTdGF0ZT4oe1xyXG4gICAgICAgIGlzQ29ubmVjdGVkOiBmYWxzZSxcclxuICAgICAgICBpc1RyYW5zY3JpYmluZzogZmFsc2UsXHJcbiAgICAgICAgdHJhbnNjcmlwdDogJycsXHJcbiAgICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICB9KVxyXG5cclxuICAgIGNvbnN0IHdzUmVmID0gdXNlUmVmPFdlYlNvY2tldCB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCB1aWRSZWYgPSB1c2VSZWYoXHJcbiAgICAgICAgdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSURcclxuICAgICAgICAgICAgPyBjcnlwdG8ucmFuZG9tVVVJRCgpXHJcbiAgICAgICAgICAgIDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksXHJcbiAgICApXHJcbiAgICBjb25zdCB7IHRvYXN0IH0gPSB1c2VUb2FzdCgpXHJcblxyXG4gICAgY29uc3QgY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAod3NSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50LmNsb3NlKClcclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudCA9IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogbnVsbCB9KSlcclxuXHJcbiAgICAgICAgY29uc3Qgd3MgPSBuZXcgV2ViU29ja2V0KGB3czovLyR7Y29uZmlnLnNlcnZlclVybH06JHtjb25maWcucG9ydH1gKVxyXG4gICAgICAgIHdzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXHJcbiAgICAgICAgd3NSZWYuY3VycmVudCA9IHdzXHJcblxyXG4gICAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFza05hbWUgPSBjb25maWcudHJhbnNsYXRlID8gJ3RyYW5zbGF0ZScgOiAndHJhbnNjcmliZSdcclxuICAgICAgICAgICAgd3Muc2VuZChcclxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrOiB0YXNrTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZFJlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBjb25maWcubGFuZ3VhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IGNvbmZpZy5tb2RlbCxcclxuICAgICAgICAgICAgICAgICAgICB2YWQ6IGNvbmZpZy52YWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZV9yZWNvcmRpbmc6IGNvbmZpZy5zYXZlUmVjb3JkaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dF9maWxlbmFtZTogY29uZmlnLm91dHB1dEZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heF9jbGllbnRzOiBjb25maWcubWF4Q2xpZW50cyxcclxuICAgICAgICAgICAgICAgICAgICBtYXhfY29ubmVjdGlvbl90aW1lOiBjb25maWcubWF4Q29ubmVjdGlvblRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKippbXBvcnRhbnQqKjogbXVzdCBtYXRjaCB5b3VyIEF1ZGlvQ29udGV4dCAmIFNjcmlwdFByb2Nlc3NvclxyXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZV9yYXRlOiAxNjAwMCxcclxuICAgICAgICAgICAgICAgICAgICBjaHVua19zaXplOiA0MDk2LFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBpc0Nvbm5lY3RlZDogdHJ1ZSB9KSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdzLm9ubWVzc2FnZSA9IGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW1dTIG1lc3NhZ2VdJywgZS5kYXRhKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRhdGEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBKU09OLnBhcnNlKGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobXNnLnR5cGUgPT09ICd0cmFuc2NyaXB0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgdHJhbnNjcmlwdDogcy50cmFuc2NyaXB0ICsgbXNnLnRleHQgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtc2cudHlwZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgZXJyb3I6IG1zZy5tZXNzYWdlIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICB3cy5vbmNsb3NlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGlzQ29ubmVjdGVkOiBmYWxzZSwgaXNUcmFuc2NyaWJpbmc6IGZhbHNlIH0pKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd3Mub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogJ1dlYlNvY2tldCBjb25uZWN0aW9uIGZhaWxlZCcgfSkpXHJcbiAgICAgICAgICAgIHRvYXN0KHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnQ29ubmVjdGlvbiBFcnJvcicsXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0ZhaWxlZCB0byBjb25uZWN0IHRvIFdoaXNwZXJMaXZlIHNlcnZlcicsXHJcbiAgICAgICAgICAgICAgICB2YXJpYW50OiAnZGVzdHJ1Y3RpdmUnLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtjb25maWcsIHRvYXN0XSlcclxuXHJcbiAgICBjb25zdCBtaWNSZWYgPSB1c2VSZWY8TWVkaWFTdHJlYW0gfCBudWxsPihudWxsKVxyXG4gICAgY29uc3Qgc3lzdGVtUmVmID0gdXNlUmVmPE1lZGlhU3RyZWFtIHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IGN0eFJlZiA9IHVzZVJlZjxBdWRpb0NvbnRleHQgfCBudWxsPihudWxsKVxyXG4gICAgY29uc3QgcHJvY2Vzc29yUmVmID0gdXNlUmVmPFNjcmlwdFByb2Nlc3Nvck5vZGUgfCBudWxsPihudWxsKVxyXG5cclxuICAgIGNvbnN0IHN0YXJ0VHJhbnNjcmlwdGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICBpZiAoIXdzUmVmLmN1cnJlbnQgfHwgd3NSZWYuY3VycmVudC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiAnTm90IGNvbm5lY3RlZCcgfSkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyAxKSBTY3JlZW4gKyBzeXN0ZW0gYXVkaW8gKGlmIGVuYWJsZWQpXHJcbiAgICAgICAgICAgIGxldCBzeXN0ZW1TdHJlYW06IE1lZGlhU3RyZWFtIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChjb25maWcuYXVkaW9Tb3VyY2VzPy5zeXN0ZW1BdWRpbykge1xyXG4gICAgICAgICAgICAgICAgc3lzdGVtU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoe1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1SZWYuY3VycmVudCA9IHN5c3RlbVN0cmVhbTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMikgTWljcm9waG9uZVxyXG4gICAgICAgICAgICBjb25zdCBtaWNTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XHJcbiAgICAgICAgICAgICAgICBhdWRpbzogeyBzYW1wbGVSYXRlOiAxNjAwMCwgY2hhbm5lbENvdW50OiAxIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtaWNSZWYuY3VycmVudCA9IG1pY1N0cmVhbTtcclxuXHJcbiAgICAgICAgICAgIC8vIDMpIEJ1aWxkIGFuIEF1ZGlvQ29udGV4dCArIGEgc2luZ2xlIGRlc3RpbmF0aW9uIHRvIG1peCBpbnRvXHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IG5ldyBBdWRpb0NvbnRleHQoeyBzYW1wbGVSYXRlOiAxNjAwMCB9KTtcclxuICAgICAgICAgICAgY3R4UmVmLmN1cnJlbnQgPSBjdHg7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlc3QgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgLy8gNCkgV2lyZSBtaWMg4oaSIGRlc3RcclxuICAgICAgICAgICAgY29uc3QgbWljU3JjID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG1pY1N0cmVhbSk7XHJcbiAgICAgICAgICAgIG1pY1NyYy5jb25uZWN0KGRlc3QpO1xyXG5cclxuICAgICAgICAgICAgLy8gNSkgV2lyZSBzeXN0ZW0gYXVkaW8g4oaSIGRlc3RcclxuICAgICAgICAgICAgaWYgKHN5c3RlbVN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3lzU3JjID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN5c3RlbVN0cmVhbSk7XHJcbiAgICAgICAgICAgICAgICBzeXNTcmMuY29ubmVjdChkZXN0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gNikgSW5zdGVhZCBvZiB3aXJpbmcgbWljK3N5cyBkaXJlY3RseSB0byB0aGUgcHJvY2Vzc29yLCB3ZVxyXG4gICAgICAgICAgICAvLyAgICB0YWtlIHRoZSBtaXhlZCBkZXN0LnN0cmVhbSBhbmQgaG9vayB0aGF0IHVwOlxyXG4gICAgICAgICAgICBjb25zdCBtaXhlZFNyYyA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShkZXN0LnN0cmVhbSk7XHJcblxyXG4gICAgICAgICAgICAvLyA3KSBDcmVhdGUgeW91ciBTY3JpcHRQcm9jZXNzb3IgKGJ1ZmZlclNpemU9NDA5NiwgbW9ubyBpbi9vdXQpXHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NvciA9IGN0eC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoNDA5NiwgMSwgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyA4KSBXaXJlIHRoZSBtaXhlZCBhdWRpbyBpbnRvIHRoZSBwcm9jZXNzb3JcclxuICAgICAgICAgICAgbWl4ZWRTcmMuY29ubmVjdChwcm9jZXNzb3IpO1xyXG5cclxuICAgICAgICAgICAgLy8gOSkgT24gZWFjaCBvbmF1ZGlvcHJvY2VzcywgYnVpbGQgZXhhY3RseSBvbmUgcGFja2V0XHJcbiAgICAgICAgICAgIHByb2Nlc3Nvci5vbmF1ZGlvcHJvY2VzcyA9IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmxvYXQzMiA9IGUuaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnQxNiA9IG5ldyBJbnQxNkFycmF5KGZsb2F0MzIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmxvYXQzMi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGludDE2W2ldID0gTWF0aC5tYXgoLTMyNzY4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbigzMjc2NywgZmxvYXQzMltpXSAqIDMyNzY3KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAod3NSZWYuY3VycmVudD8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgICAgICAgICB3c1JlZi5jdXJyZW50LnNlbmQoaW50MTYuYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIDEwKSBTdGFydCBpdFxyXG4gICAgICAgICAgICBwcm9jZXNzb3IuY29ubmVjdChjdHguZGVzdGluYXRpb24pO1xyXG4gICAgICAgICAgICBwcm9jZXNzb3JSZWYuY3VycmVudCA9IHByb2Nlc3NvcjtcclxuXHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgaXNUcmFuc2NyaWJpbmc6IHRydWUgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBlcnJvcjogYEZhaWxlZCB0byBzdGFydCB0cmFuc2NyaXB0aW9uOiAke2Vyci5tZXNzYWdlfWAgfSkpO1xyXG4gICAgICAgICAgICB0b2FzdCh7IHRpdGxlOiAnVHJhbnNjcmlwdGlvbiBFcnJvcicsIGRlc2NyaXB0aW9uOiBlcnIubWVzc2FnZSwgdmFyaWFudDogJ2Rlc3RydWN0aXZlJyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbY29uZmlnLCB0b2FzdF0pO1xyXG5cclxuXHJcbiAgICBjb25zdCBzdG9wVHJhbnNjcmlwdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAod3NSZWYuY3VycmVudD8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgLy8gemVyb+KAkWxlbmd0aCBBcnJheUJ1ZmZlciBzaWduYWxzIOKAnHBsZWFzZSBmbHVzaCAmIGZpbmlzaOKAnVxyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50LnNlbmQobmV3IEFycmF5QnVmZmVyKDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRlYXIgZG93biBhdWRpbyBncmFwaCBpbW1lZGlhdGVseVxyXG4gICAgICAgIGlmIChwcm9jZXNzb3JSZWYuY3VycmVudCkgeyBwcm9jZXNzb3JSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7IHByb2Nlc3NvclJlZi5jdXJyZW50ID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChtaWNSZWYuY3VycmVudCkgeyBtaWNSZWYuY3VycmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKHQgPT4gdC5zdG9wKCkpOyBtaWNSZWYuY3VycmVudCA9IG51bGw7IH1cclxuICAgICAgICBpZiAoc3lzdGVtUmVmLmN1cnJlbnQpIHsgc3lzdGVtUmVmLmN1cnJlbnQuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTsgc3lzdGVtUmVmLmN1cnJlbnQgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGN0eFJlZi5jdXJyZW50KSB7IGN0eFJlZi5jdXJyZW50LmNsb3NlKCk7IGN0eFJlZi5jdXJyZW50ID0gbnVsbDsgfVxyXG5cclxuICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGlzVHJhbnNjcmliaW5nOiBmYWxzZSB9KSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG5cclxuICAgIGNvbnN0IGRpc2Nvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKHdzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudC5jbG9zZSgpXHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3BUcmFuc2NyaXB0aW9uKClcclxuICAgICAgICBzZXRTdGF0ZSh7IGlzQ29ubmVjdGVkOiBmYWxzZSwgaXNUcmFuc2NyaWJpbmc6IGZhbHNlLCB0cmFuc2NyaXB0OiAnJywgZXJyb3I6IG51bGwgfSlcclxuICAgIH0sIFtzdG9wVHJhbnNjcmlwdGlvbl0pXHJcblxyXG4gICAgY29uc3QgY2xlYXJUcmFuc2NyaXB0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgdHJhbnNjcmlwdDogJycgfSkpXHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXRlLFxyXG4gICAgICAgIGNvbm5lY3QsXHJcbiAgICAgICAgc3RhcnRUcmFuc2NyaXB0aW9uLFxyXG4gICAgICAgIHN0b3BUcmFuc2NyaXB0aW9uLFxyXG4gICAgICAgIGRpc2Nvbm5lY3QsXHJcbiAgICAgICAgY2xlYXJUcmFuc2NyaXB0LFxyXG4gICAgICAgIHdzUmVmLFxyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwidXNlVG9hc3QiLCJ1c2VXaGlzcGVyTGl2ZSIsImNvbmZpZyIsInN0YXRlIiwic2V0U3RhdGUiLCJpc0Nvbm5lY3RlZCIsImlzVHJhbnNjcmliaW5nIiwidHJhbnNjcmlwdCIsImVycm9yIiwid3NSZWYiLCJ1aWRSZWYiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJ0b2FzdCIsImNvbm5lY3QiLCJjdXJyZW50IiwiY2xvc2UiLCJzIiwid3MiLCJXZWJTb2NrZXQiLCJzZXJ2ZXJVcmwiLCJwb3J0IiwiYmluYXJ5VHlwZSIsIm9ub3BlbiIsInRhc2tOYW1lIiwidHJhbnNsYXRlIiwic2VuZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0YXNrIiwidWlkIiwibGFuZ3VhZ2UiLCJtb2RlbCIsInZhZCIsInNhdmVfcmVjb3JkaW5nIiwic2F2ZVJlY29yZGluZyIsIm91dHB1dF9maWxlbmFtZSIsIm91dHB1dEZpbGVuYW1lIiwibWF4X2NsaWVudHMiLCJtYXhDbGllbnRzIiwibWF4X2Nvbm5lY3Rpb25fdGltZSIsIm1heENvbm5lY3Rpb25UaW1lIiwic2FtcGxlX3JhdGUiLCJjaHVua19zaXplIiwib25tZXNzYWdlIiwiZSIsImNvbnNvbGUiLCJsb2ciLCJkYXRhIiwibXNnIiwicGFyc2UiLCJ0eXBlIiwidGV4dCIsIm1lc3NhZ2UiLCJvbmNsb3NlIiwib25lcnJvciIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJ2YXJpYW50IiwibWljUmVmIiwic3lzdGVtUmVmIiwiY3R4UmVmIiwicHJvY2Vzc29yUmVmIiwic3RhcnRUcmFuc2NyaXB0aW9uIiwicmVhZHlTdGF0ZSIsIk9QRU4iLCJzeXN0ZW1TdHJlYW0iLCJhdWRpb1NvdXJjZXMiLCJzeXN0ZW1BdWRpbyIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldERpc3BsYXlNZWRpYSIsInZpZGVvIiwiYXVkaW8iLCJtaWNTdHJlYW0iLCJnZXRVc2VyTWVkaWEiLCJzYW1wbGVSYXRlIiwiY2hhbm5lbENvdW50IiwiY3R4IiwiQXVkaW9Db250ZXh0IiwiZGVzdCIsImNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24iLCJtaWNTcmMiLCJjcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSIsInN5c1NyYyIsIm1peGVkU3JjIiwic3RyZWFtIiwicHJvY2Vzc29yIiwiY3JlYXRlU2NyaXB0UHJvY2Vzc29yIiwib25hdWRpb3Byb2Nlc3MiLCJmbG9hdDMyIiwiaW5wdXRCdWZmZXIiLCJnZXRDaGFubmVsRGF0YSIsImludDE2IiwiSW50MTZBcnJheSIsImxlbmd0aCIsImkiLCJtYXgiLCJtaW4iLCJidWZmZXIiLCJkZXN0aW5hdGlvbiIsImVyciIsInN0b3BUcmFuc2NyaXB0aW9uIiwiQXJyYXlCdWZmZXIiLCJkaXNjb25uZWN0IiwiZ2V0VHJhY2tzIiwiZm9yRWFjaCIsInQiLCJzdG9wIiwiY2xlYXJUcmFuc2NyaXB0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-whisper-live.ts\n"));

/***/ })

});