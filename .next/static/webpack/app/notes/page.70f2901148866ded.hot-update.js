"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/notes/page",{

/***/ "(app-pages-browser)/./src/hooks/use-whisper-live.ts":
/*!***************************************!*\
  !*** ./src/hooks/use-whisper-live.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWhisperLive: () => (/* binding */ useWhisperLive)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/hooks/use-toast */ \"(app-pages-browser)/./src/hooks/use-toast.ts\");\n/* __next_internal_client_entry_do_not_use__ useWhisperLive auto */ \n\nconst [recordings, setRecordings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\nfunction encodeWAV(samples, sampleRate) {\n    const bitsPerSample = 16;\n    const bytesPerSample = bitsPerSample / 8;\n    const blockAlign = bytesPerSample // mono\n    ;\n    const byteRate = sampleRate * blockAlign;\n    const dataSize = samples.length * bytesPerSample;\n    const buffer = new ArrayBuffer(44 + dataSize);\n    const view = new DataView(buffer);\n    /* RIFF identifier */ writeString(view, 0, 'RIFF');\n    /* file length minus first 8 bytes */ view.setUint32(4, 36 + dataSize, true);\n    /* WAVE type */ writeString(view, 8, 'WAVE');\n    /* fmt  chunk */ writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true) // chunk length\n    ;\n    view.setUint16(20, 1, true) // PCM\n    ;\n    view.setUint16(22, 1, true) // mono\n    ;\n    view.setUint32(24, sampleRate, true) // sampleRate\n    ;\n    view.setUint32(28, byteRate, true) // byteRate\n    ;\n    view.setUint16(32, blockAlign, true) // blockAlign\n    ;\n    view.setUint16(34, bitsPerSample, true) // bitsPerSample\n    ;\n    /* data chunk */ writeString(view, 36, 'data');\n    view.setUint32(40, dataSize, true);\n    // write PCM samples\n    let offset = 44;\n    for(let i = 0; i < samples.length; i++){\n        // clamp\n        const s = Math.max(-1, Math.min(1, samples[i]));\n        // scale to 16‑bit int\n        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n        offset += 2;\n    }\n    return view;\n}\nfunction writeString(view, offset, s) {\n    for(let i = 0; i < s.length; i++){\n        view.setUint8(offset + i, s.charCodeAt(i));\n    }\n}\nfunction useWhisperLive(config) {\n    const [recordings, setRecordings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        isConnected: false,\n        isTranscribing: false,\n        transcript: '',\n        error: null\n    });\n    const [audioData, setAudioData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [dataUpdateTrigger, setDataUpdateTrigger] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const recordingBuffers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const sampleRateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const lastSegmentIndexRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const uidRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));\n    const { toast } = (0,_hooks_use_toast__WEBPACK_IMPORTED_MODULE_1__.useToast)();\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[connect]\": ()=>{\n            console.log('[useWhisperLive]  connect()', config);\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            // 1) create AudioContext now so we can hand its real sampleRate to the server\n            const ctx = new AudioContext({\n                sampleRate: 16000\n            });\n            ctxRef.current = ctx;\n            // immediately save out the sampleRate for later WAV encoding\n            sampleRateRef.current = ctx.sampleRate;\n            // clear out any old floats from a previous session\n            recordingBuffers.current = [];\n            console.log('[useWhisperLive] audioContext.sampleRate =', sampleRateRef.current);\n            setState({\n                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                        ...s,\n                        error: null\n                    })\n            }[\"useWhisperLive.useCallback[connect]\"]);\n            const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\n            const ws = new WebSocket(\"\".concat(protocol, \"://\").concat(config.serverUrl, \":\").concat(config.port));\n            ws.binaryType = 'arraybuffer';\n            wsRef.current = ws;\n            lastSegmentIndexRef.current = 0;\n            ws.onopen = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    console.log('[useWhisperLive] 🟢 WebSocket OPEN');\n                    const taskName = config.translate ? 'translate' : 'transcribe';\n                    ws.send(JSON.stringify({\n                        task: taskName,\n                        uid: uidRef.current,\n                        language: config.language,\n                        model: config.model,\n                        use_vad: false,\n                        // only send us the newest segment each time:\n                        send_last_n_segments: 0,\n                        save_recording: config.saveRecording,\n                        output_filename: config.outputFilename,\n                        max_clients: config.maxClients,\n                        max_connection_time: config.maxConnectionTime,\n                        // **important**: must match your AudioContext & ScriptProcessor\n                        sample_rate: sampleRateRef.current,\n                        chunk_size: 512\n                    }));\n                    startTranscription();\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: true\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            // inside your connect()\n            ws.onmessage = ({\n                \"useWhisperLive.useCallback[connect]\": (e)=>{\n                    console.log('Raw WS Message:', e.data);\n                    if (typeof e.data !== 'string') return;\n                    const msg = JSON.parse(e.data);\n                    // ignore handshake\n                    if (msg.message === 'SERVER_READY') return;\n                    // errors\n                    if (msg.type === 'error') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    error: msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // old‐style partial/final (if you ever toggle that back on)\n                    if (msg.type === 'partial' || msg.type === 'transcript') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + msg.text\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    if (msg.type === 'final') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: false,\n                                    transcript: s.transcript + msg.text + '\\n'\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                        return;\n                    }\n                    // ← NEW: handle the `segments` array\n                    if (Array.isArray(msg.segments)) {\n                        // only take the ones we haven’t seen yet\n                        const all = msg.segments;\n                        const start = lastSegmentIndexRef.current;\n                        if (all.length > start) {\n                            // join just the new bits\n                            const batch = all.slice(start).map({\n                                \"useWhisperLive.useCallback[connect].batch\": (seg)=>seg.text\n                            }[\"useWhisperLive.useCallback[connect].batch\"]).join('');\n                            setState({\n                                \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                        ...s,\n                                        isTranscribing: true,\n                                        transcript: s.transcript + batch\n                                    })\n                            }[\"useWhisperLive.useCallback[connect]\"]);\n                            lastSegmentIndexRef.current = all.length;\n                        }\n                        return;\n                    }\n                    // fallback to any stray `msg.message`\n                    if (msg.message && msg.message !== 'SERVER_READY') {\n                        setState({\n                            \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                    ...s,\n                                    isTranscribing: true,\n                                    transcript: s.transcript + msg.message\n                                })\n                        }[\"useWhisperLive.useCallback[connect]\"]);\n                    }\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onclose = ({\n                \"useWhisperLive.useCallback[connect]\": ()=>{\n                    setState({\n                        \"useWhisperLive.useCallback[connect]\": (s)=>({\n                                ...s,\n                                isConnected: false,\n                                isTranscribing: false\n                            })\n                    }[\"useWhisperLive.useCallback[connect]\"]);\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n            ws.onerror = ({\n                \"useWhisperLive.useCallback[connect]\": (err)=>{\n                    console.warn('[useWhisperLive] WebSocket error (non‑fatal)', err);\n                // don’t setState or toast here\n                }\n            })[\"useWhisperLive.useCallback[connect]\"];\n        }\n    }[\"useWhisperLive.useCallback[connect]\"], [\n        config,\n        toast\n    ]);\n    const micRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const systemRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ctxRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const processorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const startTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[startTranscription]\": async ()=>{\n            if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: 'Not connected'\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                return;\n            }\n            try {\n                var _config_audioSources;\n                // 1) Screen + system audio (if enabled)\n                let systemStream = null;\n                if ((_config_audioSources = config.audioSources) === null || _config_audioSources === void 0 ? void 0 : _config_audioSources.systemAudio) {\n                    systemStream = await navigator.mediaDevices.getDisplayMedia({\n                        video: true,\n                        audio: true\n                    });\n                    systemRef.current = systemStream;\n                }\n                // 2) Microphone\n                const micStream = await navigator.mediaDevices.getUserMedia({\n                    audio: {\n                        sampleRate: 16000,\n                        channelCount: 1\n                    }\n                });\n                micRef.current = micStream;\n                const ctx = ctxRef.current;\n                const dest = ctx.createMediaStreamDestination();\n                // 4) Wire mic → dest\n                const micSrc = ctx.createMediaStreamSource(micStream);\n                micSrc.connect(dest);\n                // 5) Wire system audio → dest\n                if (systemStream) {\n                    const sysSrc = ctx.createMediaStreamSource(systemStream);\n                    sysSrc.connect(dest);\n                }\n                // 6) Instead of wiring mic+sys directly to the processor, we\n                //    take the mixed dest.stream and hook that up:\n                const mixedSrc = ctx.createMediaStreamSource(dest.stream);\n                // 7) Create your ScriptProcessor (bufferSize=512, mono in/out)\n                const processor = ctx.createScriptProcessor(512, 1, 1);\n                // 8) Wire the mixed audio into the processor\n                mixedSrc.connect(processor);\n                // 9) On each onaudioprocess, build exactly one packet\n                processor.onaudioprocess = ({\n                    \"useWhisperLive.useCallback[startTranscription]\": (e)=>{\n                        const float32 = e.inputBuffer.getChannelData(0);\n                        const float32Buffer = new Float32Array(float32);\n                        if (config.saveRecording) {\n                            recordingBuffers.current.push(float32Buffer);\n                        }\n                        // → convert to Uint8Array [0..255]\n                        const ui8 = new Uint8Array(float32Buffer.length);\n                        for(let i = 0; i < float32Buffer.length; i++){\n                            ui8[i] = Math.min(255, Math.max(0, Math.floor((float32Buffer[i] + 1) * 127.5)));\n                        }\n                        // send raw float32 PCM to server\n                        if (wsRef.current.readyState === WebSocket.OPEN) {\n                            wsRef.current.send(float32Buffer.buffer);\n                        }\n                        // update visualizer\n                        setAudioData(ui8);\n                        setDataUpdateTrigger({\n                            \"useWhisperLive.useCallback[startTranscription]\": (t)=>t + 1\n                        }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                    }\n                })[\"useWhisperLive.useCallback[startTranscription]\"];\n                // 10) Start it\n                processor.connect(ctx.destination);\n                processorRef.current = processor;\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            isTranscribing: true\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n            } catch (err) {\n                setState({\n                    \"useWhisperLive.useCallback[startTranscription]\": (s)=>({\n                            ...s,\n                            error: \"Failed to start transcription: \".concat(err.message)\n                        })\n                }[\"useWhisperLive.useCallback[startTranscription]\"]);\n                toast({\n                    title: 'Transcription Error',\n                    description: err.message,\n                    variant: 'destructive'\n                });\n            }\n        }\n    }[\"useWhisperLive.useCallback[startTranscription]\"], [\n        config,\n        toast\n    ]);\n    const stopTranscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[stopTranscription]\": async ()=>{\n            var _wsRef_current;\n            // 1) tell the server “END_OF_AUDIO”\n            if (((_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.readyState) === WebSocket.OPEN) {\n                wsRef.current.send(new TextEncoder().encode(\"END_OF_AUDIO\"));\n            }\n            // 2) immediately tear down the ScriptProcessor & tracks\n            if (processorRef.current) {\n                processorRef.current.disconnect();\n                processorRef.current = null;\n            }\n            if (micRef.current) {\n                micRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                micRef.current = null;\n            }\n            if (systemRef.current) {\n                systemRef.current.getTracks().forEach({\n                    \"useWhisperLive.useCallback[stopTranscription]\": (t)=>t.stop()\n                }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                systemRef.current = null;\n            }\n            // 3) if we’ve been saving, flatten + encode + upload while ctx is still open\n            if (config.saveRecording && recordingBuffers.current.length) {\n                console.log('[useWhisperLive] uploading WAV, buffers:', recordingBuffers.current.length);\n                // ◉ use the saved sampleRate\n                const sampleRate = sampleRateRef.current;\n                // ◉ flatten into one Float32Array\n                const totalLength = recordingBuffers.current.reduce({\n                    \"useWhisperLive.useCallback[stopTranscription].totalLength\": (sum, buf)=>sum + buf.length\n                }[\"useWhisperLive.useCallback[stopTranscription].totalLength\"], 0);\n                const interleaved = new Float32Array(totalLength);\n                let offset = 0;\n                for (const buf of recordingBuffers.current){\n                    interleaved.set(buf, offset);\n                    offset += buf.length;\n                }\n                // ◉ encode + upload\n                const wavView = encodeWAV(interleaved, sampleRate);\n                const blob = new Blob([\n                    wavView.buffer\n                ], {\n                    type: 'audio/wav'\n                });\n                const form = new FormData();\n                form.append('file', blob, config.outputFilename || 'recording.wav');\n                try {\n                    const res = await fetch('/api/upload', {\n                        method: 'POST',\n                        body: form\n                    });\n                    if (!res.ok) throw new Error('upload failed');\n                    const { url } = await res.json();\n                    const rec = {\n                        id: Date.now().toString(),\n                        url,\n                        blob\n                    };\n                    setRecordings({\n                        \"useWhisperLive.useCallback[stopTranscription]\": (rs)=>[\n                                ...rs,\n                                rec\n                            ]\n                    }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n                } catch (err) {\n                    toast({\n                        title: 'Upload Error',\n                        description: String(err),\n                        variant: 'destructive'\n                    });\n                }\n                recordingBuffers.current = [];\n            }\n            // 4) **now** tear down your AudioContext\n            if (ctxRef.current) {\n                ctxRef.current.close();\n                ctxRef.current = null;\n            }\n            // 5) finally, update state\n            setState({\n                \"useWhisperLive.useCallback[stopTranscription]\": (s)=>({\n                        ...s,\n                        isTranscribing: false\n                    })\n            }[\"useWhisperLive.useCallback[stopTranscription]\"]);\n        }\n    }[\"useWhisperLive.useCallback[stopTranscription]\"], [\n        config,\n        toast\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[disconnect]\": ()=>{\n            if (wsRef.current) {\n                wsRef.current.close();\n                wsRef.current = null;\n            }\n            stopTranscription();\n            setState({\n                isConnected: false,\n                isTranscribing: false,\n                transcript: '',\n                error: null\n            });\n        }\n    }[\"useWhisperLive.useCallback[disconnect]\"], [\n        stopTranscription\n    ]);\n    const clearTranscript = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWhisperLive.useCallback[clearTranscript]\": ()=>{\n            setState({\n                \"useWhisperLive.useCallback[clearTranscript]\": (s)=>({\n                        ...s,\n                        transcript: ''\n                    })\n            }[\"useWhisperLive.useCallback[clearTranscript]\"]);\n        }\n    }[\"useWhisperLive.useCallback[clearTranscript]\"], []);\n    return {\n        state,\n        connect,\n        startTranscription,\n        stopTranscription,\n        disconnect,\n        clearTranscript,\n        wsRef,\n        audioData,\n        dataUpdateTrigger,\n        recordings,\n        deleteRecording: (r)=>setRecordings((rs)=>rs.filter((x)=>x.id !== r.id))\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utd2hpc3Blci1saXZlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7b0VBRXFEO0FBQ1Q7QUFJNUMsTUFBTSxDQUFDSSxZQUFZQyxjQUFjLEdBQUdMLCtDQUFRQSxDQUFjLEVBQUU7QUFxQjVELFNBQVNNLFVBQVVDLE9BQXFCLEVBQUVDLFVBQWtCO0lBQ3hELE1BQU1DLGdCQUFnQjtJQUN0QixNQUFNQyxpQkFBaUJELGdCQUFnQjtJQUN2QyxNQUFNRSxhQUFhRCxlQUFlLE9BQU87O0lBQ3pDLE1BQU1FLFdBQVdKLGFBQWFHO0lBQzlCLE1BQU1FLFdBQVdOLFFBQVFPLE1BQU0sR0FBR0o7SUFDbEMsTUFBTUssU0FBUyxJQUFJQyxZQUFZLEtBQUtIO0lBQ3BDLE1BQU1JLE9BQU8sSUFBSUMsU0FBU0g7SUFFMUIsbUJBQW1CLEdBQ25CSSxZQUFZRixNQUFNLEdBQUc7SUFDckIsbUNBQW1DLEdBQ25DQSxLQUFLRyxTQUFTLENBQUMsR0FBRyxLQUFLUCxVQUFVO0lBQ2pDLGFBQWEsR0FDYk0sWUFBWUYsTUFBTSxHQUFHO0lBQ3JCLGNBQWMsR0FDZEUsWUFBWUYsTUFBTSxJQUFJO0lBQ3RCQSxLQUFLRyxTQUFTLENBQUMsSUFBSSxJQUFJLE1BQXFCLGVBQWU7O0lBQzNESCxLQUFLSSxTQUFTLENBQUMsSUFBSSxHQUFHLE1BQXNCLE1BQU07O0lBQ2xESixLQUFLSSxTQUFTLENBQUMsSUFBSSxHQUFHLE1BQXNCLE9BQU87O0lBQ25ESixLQUFLRyxTQUFTLENBQUMsSUFBSVosWUFBWSxNQUFhLGFBQWE7O0lBQ3pEUyxLQUFLRyxTQUFTLENBQUMsSUFBSVIsVUFBVSxNQUFlLFdBQVc7O0lBQ3ZESyxLQUFLSSxTQUFTLENBQUMsSUFBSVYsWUFBWSxNQUFhLGFBQWE7O0lBQ3pETSxLQUFLSSxTQUFTLENBQUMsSUFBSVosZUFBZSxNQUFVLGdCQUFnQjs7SUFDNUQsY0FBYyxHQUNkVSxZQUFZRixNQUFNLElBQUk7SUFDdEJB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O1lBQ2hDZ0M7K0RBQVNWLENBQUFBLElBQU07d0JBQUUsR0FBR0EsQ0FBQzt3QkFBRWEsWUFBWTtvQkFBRzs7UUFDMUM7c0RBQUcsRUFBRTtJQUVMLE9BQU87UUFDSEo7UUFDQXFCO1FBQ0FzQztRQUNBOEQ7UUFDQUc7UUFDQThCO1FBQ0FoSjtRQUNBSjtRQUNBRTtRQUNBckM7UUFDQXdMLGlCQUFpQixDQUFDQyxJQUFpQnhMLGNBQWNvTCxDQUFBQSxLQUFNQSxHQUFHSyxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVULEVBQUUsS0FBS08sRUFBRVAsRUFBRTtJQUN2RjtBQUNKIiwic291cmNlcyI6WyJFOlxcQWl2b2ljZXRvdGV4dFxcc3JjXFxob29rc1xcdXNlLXdoaXNwZXItbGl2ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IHVzZVRvYXN0IH0gZnJvbSAnQC9ob29rcy91c2UtdG9hc3QnXHJcblxyXG5cclxuaW50ZXJmYWNlIFJlY29yZGluZyB7IGlkOiBzdHJpbmc7IHVybDogc3RyaW5nOyBibG9iPzogQmxvYiB9XHJcbmNvbnN0IFtyZWNvcmRpbmdzLCBzZXRSZWNvcmRpbmdzXSA9IHVzZVN0YXRlPFJlY29yZGluZ1tdPihbXSlcclxuZXhwb3J0IGludGVyZmFjZSBXaGlzcGVyTGl2ZUNvbmZpZyB7XHJcbiAgICBzZXJ2ZXJVcmw6IHN0cmluZ1xyXG4gICAgcG9ydDogbnVtYmVyXHJcbiAgICBsYW5ndWFnZTogc3RyaW5nXHJcbiAgICB0cmFuc2xhdGU6IGJvb2xlYW5cclxuICAgIG1vZGVsOiBzdHJpbmdcclxuICAgIHZhZDogYm9vbGVhblxyXG4gICAgc2F2ZVJlY29yZGluZzogYm9vbGVhblxyXG4gICAgb3V0cHV0RmlsZW5hbWU6IHN0cmluZ1xyXG4gICAgbWF4Q2xpZW50czogbnVtYmVyXHJcbiAgICBtYXhDb25uZWN0aW9uVGltZTogbnVtYmVyXHJcbiAgICBhdWRpb1NvdXJjZXM/OiB7IG1pY3JvcGhvbmU6IGJvb2xlYW47IHN5c3RlbUF1ZGlvOiBib29sZWFuIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIFdoaXNwZXJMaXZlU3RhdGUge1xyXG4gICAgaXNDb25uZWN0ZWQ6IGJvb2xlYW5cclxuICAgIGlzVHJhbnNjcmliaW5nOiBib29sZWFuXHJcbiAgICB0cmFuc2NyaXB0OiBzdHJpbmdcclxuICAgIGVycm9yOiBzdHJpbmcgfCBudWxsXHJcbn1cclxuZnVuY3Rpb24gZW5jb2RlV0FWKHNhbXBsZXM6IEZsb2F0MzJBcnJheSwgc2FtcGxlUmF0ZTogbnVtYmVyKTogRGF0YVZpZXcge1xyXG4gICAgY29uc3QgYml0c1BlclNhbXBsZSA9IDE2XHJcbiAgICBjb25zdCBieXRlc1BlclNhbXBsZSA9IGJpdHNQZXJTYW1wbGUgLyA4XHJcbiAgICBjb25zdCBibG9ja0FsaWduID0gYnl0ZXNQZXJTYW1wbGUgLy8gbW9ub1xyXG4gICAgY29uc3QgYnl0ZVJhdGUgPSBzYW1wbGVSYXRlICogYmxvY2tBbGlnblxyXG4gICAgY29uc3QgZGF0YVNpemUgPSBzYW1wbGVzLmxlbmd0aCAqIGJ5dGVzUGVyU2FtcGxlXHJcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNDQgKyBkYXRhU2l6ZSlcclxuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKVxyXG5cclxuICAgIC8qIFJJRkYgaWRlbnRpZmllciAqL1xyXG4gICAgd3JpdGVTdHJpbmcodmlldywgMCwgJ1JJRkYnKVxyXG4gICAgLyogZmlsZSBsZW5ndGggbWludXMgZmlyc3QgOCBieXRlcyAqL1xyXG4gICAgdmlldy5zZXRVaW50MzIoNCwgMzYgKyBkYXRhU2l6ZSwgdHJ1ZSlcclxuICAgIC8qIFdBVkUgdHlwZSAqL1xyXG4gICAgd3JpdGVTdHJpbmcodmlldywgOCwgJ1dBVkUnKVxyXG4gICAgLyogZm10ICBjaHVuayAqL1xyXG4gICAgd3JpdGVTdHJpbmcodmlldywgMTIsICdmbXQgJylcclxuICAgIHZpZXcuc2V0VWludDMyKDE2LCAxNiwgdHJ1ZSkgICAgICAgICAgICAgICAgLy8gY2h1bmsgbGVuZ3RoXHJcbiAgICB2aWV3LnNldFVpbnQxNigyMCwgMSwgdHJ1ZSkgICAgICAgICAgICAgICAgIC8vIFBDTVxyXG4gICAgdmlldy5zZXRVaW50MTYoMjIsIDEsIHRydWUpICAgICAgICAgICAgICAgICAvLyBtb25vXHJcbiAgICB2aWV3LnNldFVpbnQzMigyNCwgc2FtcGxlUmF0ZSwgdHJ1ZSkgICAgICAgIC8vIHNhbXBsZVJhdGVcclxuICAgIHZpZXcuc2V0VWludDMyKDI4LCBieXRlUmF0ZSwgdHJ1ZSkgICAgICAgICAgLy8gYnl0ZVJhdGVcclxuICAgIHZpZXcuc2V0VWludDE2KDMyLCBibG9ja0FsaWduLCB0cnVlKSAgICAgICAgLy8gYmxvY2tBbGlnblxyXG4gICAgdmlldy5zZXRVaW50MTYoMzQsIGJpdHNQZXJTYW1wbGUsIHRydWUpICAgICAvLyBiaXRzUGVyU2FtcGxlXHJcbiAgICAvKiBkYXRhIGNodW5rICovXHJcbiAgICB3cml0ZVN0cmluZyh2aWV3LCAzNiwgJ2RhdGEnKVxyXG4gICAgdmlldy5zZXRVaW50MzIoNDAsIGRhdGFTaXplLCB0cnVlKVxyXG5cclxuICAgIC8vIHdyaXRlIFBDTSBzYW1wbGVzXHJcbiAgICBsZXQgb2Zmc2V0ID0gNDRcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vIGNsYW1wXHJcbiAgICAgICAgY29uc3QgcyA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBzYW1wbGVzW2ldKSlcclxuICAgICAgICAvLyBzY2FsZSB0byAxNuKAkWJpdCBpbnRcclxuICAgICAgICB2aWV3LnNldEludDE2KFxyXG4gICAgICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgICAgIHMgPCAwID8gcyAqIDB4ODAwMCA6IHMgKiAweDdGRkYsXHJcbiAgICAgICAgICAgIHRydWVcclxuICAgICAgICApXHJcbiAgICAgICAgb2Zmc2V0ICs9IDJcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmlld1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZVN0cmluZyh2aWV3OiBEYXRhVmlldywgb2Zmc2V0OiBudW1iZXIsIHM6IHN0cmluZykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyBpLCBzLmNoYXJDb2RlQXQoaSkpXHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVdoaXNwZXJMaXZlKGNvbmZpZzogV2hpc3BlckxpdmVDb25maWcpIHtcclxuICAgIGNvbnN0IFtyZWNvcmRpbmdzLCBzZXRSZWNvcmRpbmdzXSA9IHVzZVN0YXRlPFJlY29yZGluZ1tdPihbXSlcclxuXHJcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPFdoaXNwZXJMaXZlU3RhdGU+KHtcclxuICAgICAgICBpc0Nvbm5lY3RlZDogZmFsc2UsXHJcbiAgICAgICAgaXNUcmFuc2NyaWJpbmc6IGZhbHNlLFxyXG4gICAgICAgIHRyYW5zY3JpcHQ6ICcnLFxyXG4gICAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgfSlcclxuICAgIGNvbnN0IFthdWRpb0RhdGEsIHNldEF1ZGlvRGF0YV0gPSB1c2VTdGF0ZTxVaW50OEFycmF5IHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IFtkYXRhVXBkYXRlVHJpZ2dlciwgc2V0RGF0YVVwZGF0ZVRyaWdnZXJdID0gdXNlU3RhdGUoMClcclxuICAgIGNvbnN0IHdzUmVmID0gdXNlUmVmPFdlYlNvY2tldCB8IG51bGw+KG51bGwpXHJcbiAgICBjb25zdCByZWNvcmRpbmdCdWZmZXJzID0gdXNlUmVmPEZsb2F0MzJBcnJheVtdPihbXSlcclxuICAgIGNvbnN0IHNhbXBsZVJhdGVSZWYgPSB1c2VSZWY8bnVtYmVyPigwKVxyXG4gICAgY29uc3QgbGFzdFNlZ21lbnRJbmRleFJlZiA9IHVzZVJlZigwKVxyXG5cclxuICAgIGNvbnN0IHVpZFJlZiA9IHVzZVJlZihcclxuICAgICAgICB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRFxyXG4gICAgICAgICAgICA/IGNyeXB0by5yYW5kb21VVUlEKClcclxuICAgICAgICAgICAgOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxcclxuICAgIClcclxuICAgIGNvbnN0IHsgdG9hc3QgfSA9IHVzZVRvYXN0KClcclxuXHJcbiAgICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbdXNlV2hpc3BlckxpdmVdICBjb25uZWN0KCknLCBjb25maWcpO1xyXG4gICAgICAgIGlmICh3c1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAxKSBjcmVhdGUgQXVkaW9Db250ZXh0IG5vdyBzbyB3ZSBjYW4gaGFuZCBpdHMgcmVhbCBzYW1wbGVSYXRlIHRvIHRoZSBzZXJ2ZXJcclxuICAgICAgICBjb25zdCBjdHggPSBuZXcgQXVkaW9Db250ZXh0KHsgc2FtcGxlUmF0ZTogMTYwMDAgfSlcclxuICAgICAgICBjdHhSZWYuY3VycmVudCA9IGN0eFxyXG5cclxuICAgICAgICAvLyBpbW1lZGlhdGVseSBzYXZlIG91dCB0aGUgc2FtcGxlUmF0ZSBmb3IgbGF0ZXIgV0FWIGVuY29kaW5nXHJcbiAgICAgICAgc2FtcGxlUmF0ZVJlZi5jdXJyZW50ID0gY3R4LnNhbXBsZVJhdGVcclxuXHJcbiAgICAgICAgLy8gY2xlYXIgb3V0IGFueSBvbGQgZmxvYXRzIGZyb20gYSBwcmV2aW91cyBzZXNzaW9uXHJcbiAgICAgICAgcmVjb3JkaW5nQnVmZmVycy5jdXJyZW50ID0gW11cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1t1c2VXaGlzcGVyTGl2ZV0gYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgPScsIHNhbXBsZVJhdGVSZWYuY3VycmVudClcclxuICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiBudWxsIH0pKVxyXG5cclxuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnd3NzJyA6ICd3cyc7XHJcbiAgICAgICAgY29uc3Qgd3MgPSBuZXcgV2ViU29ja2V0KGAke3Byb3RvY29sfTovLyR7Y29uZmlnLnNlcnZlclVybH06JHtjb25maWcucG9ydH1gKTtcclxuICAgICAgICB3cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xyXG4gICAgICAgIHdzUmVmLmN1cnJlbnQgPSB3c1xyXG4gICAgICAgIGxhc3RTZWdtZW50SW5kZXhSZWYuY3VycmVudCA9IDBcclxuXHJcblxyXG4gICAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1t1c2VXaGlzcGVyTGl2ZV0g8J+foiBXZWJTb2NrZXQgT1BFTicpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXNrTmFtZSA9IGNvbmZpZy50cmFuc2xhdGUgPyAndHJhbnNsYXRlJyA6ICd0cmFuc2NyaWJlJ1xyXG4gICAgICAgICAgICB3cy5zZW5kKFxyXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2s6IHRhc2tOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHVpZDogdWlkUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IGNvbmZpZy5sYW5ndWFnZSxcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbDogY29uZmlnLm1vZGVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZV92YWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgc2VuZCB1cyB0aGUgbmV3ZXN0IHNlZ21lbnQgZWFjaCB0aW1lOlxyXG4gICAgICAgICAgICAgICAgICAgIHNlbmRfbGFzdF9uX3NlZ21lbnRzOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVfcmVjb3JkaW5nOiBjb25maWcuc2F2ZVJlY29yZGluZyxcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRfZmlsZW5hbWU6IGNvbmZpZy5vdXRwdXRGaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhfY2xpZW50czogY29uZmlnLm1heENsaWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4X2Nvbm5lY3Rpb25fdGltZTogY29uZmlnLm1heENvbm5lY3Rpb25UaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICoqaW1wb3J0YW50Kio6IG11c3QgbWF0Y2ggeW91ciBBdWRpb0NvbnRleHQgJiBTY3JpcHRQcm9jZXNzb3JcclxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVfcmF0ZTogc2FtcGxlUmF0ZVJlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGNodW5rX3NpemU6IDUxMixcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIHN0YXJ0VHJhbnNjcmlwdGlvbigpO1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGlzQ29ubmVjdGVkOiB0cnVlIH0pKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaW5zaWRlIHlvdXIgY29ubmVjdCgpXHJcbiAgICAgICAgd3Mub25tZXNzYWdlID0gZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSYXcgV1MgTWVzc2FnZTonLCBlLmRhdGEpXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZS5kYXRhICE9PSAnc3RyaW5nJykgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBtc2cgPSBKU09OLnBhcnNlKGUuZGF0YSk7XHJcblxyXG4gICAgICAgICAgICAvLyBpZ25vcmUgaGFuZHNoYWtlXHJcbiAgICAgICAgICAgIGlmIChtc2cubWVzc2FnZSA9PT0gJ1NFUlZFUl9SRUFEWScpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIGVycm9yc1xyXG4gICAgICAgICAgICBpZiAobXNnLnR5cGUgPT09ICdlcnJvcicpIHtcclxuICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHsgLi4ucywgZXJyb3I6IG1zZy5tZXNzYWdlIH0pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gb2xk4oCQc3R5bGUgcGFydGlhbC9maW5hbCAoaWYgeW91IGV2ZXIgdG9nZ2xlIHRoYXQgYmFjayBvbilcclxuICAgICAgICAgICAgaWYgKG1zZy50eXBlID09PSAncGFydGlhbCcgfHwgbXNnLnR5cGUgPT09ICd0cmFuc2NyaXB0Jykge1xyXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUcmFuc2NyaWJpbmc6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjcmlwdDogcy50cmFuc2NyaXB0ICsgbXNnLnRleHRcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobXNnLnR5cGUgPT09ICdmaW5hbCcpIHtcclxuICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVHJhbnNjcmliaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NyaXB0OiBzLnRyYW5zY3JpcHQgKyBtc2cudGV4dCArICdcXG4nXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOKGkCBORVc6IGhhbmRsZSB0aGUgYHNlZ21lbnRzYCBhcnJheVxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtc2cuc2VnbWVudHMpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHRha2UgdGhlIG9uZXMgd2UgaGF2ZW7igJl0IHNlZW4geWV0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbGwgPSBtc2cuc2VnbWVudHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbGFzdFNlZ21lbnRJbmRleFJlZi5jdXJyZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxsLmxlbmd0aCA+IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gam9pbiBqdXN0IHRoZSBuZXcgYml0c1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gYWxsLnNsaWNlKHN0YXJ0KS5tYXAoc2VnID0+IHNlZy50ZXh0KS5qb2luKCcnKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNUcmFuc2NyaWJpbmc6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zY3JpcHQ6IHMudHJhbnNjcmlwdCArIGJhdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRJbmRleFJlZi5jdXJyZW50ID0gYWxsLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gYW55IHN0cmF5IGBtc2cubWVzc2FnZWBcclxuICAgICAgICAgICAgaWYgKG1zZy5tZXNzYWdlICYmIG1zZy5tZXNzYWdlICE9PSAnU0VSVkVSX1JFQURZJykge1xyXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUcmFuc2NyaWJpbmc6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjcmlwdDogcy50cmFuc2NyaXB0ICsgbXNnLm1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICB3cy5vbmNsb3NlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGlzQ29ubmVjdGVkOiBmYWxzZSwgaXNUcmFuc2NyaWJpbmc6IGZhbHNlIH0pKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd3Mub25lcnJvciA9IChlcnIpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbdXNlV2hpc3BlckxpdmVdIFdlYlNvY2tldCBlcnJvciAobm9u4oCRZmF0YWwpJywgZXJyKTtcclxuICAgICAgICAgICAgLy8gZG9u4oCZdCBzZXRTdGF0ZSBvciB0b2FzdCBoZXJlXHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtjb25maWcsIHRvYXN0XSlcclxuXHJcbiAgICBjb25zdCBtaWNSZWYgPSB1c2VSZWY8TWVkaWFTdHJlYW0gfCBudWxsPihudWxsKVxyXG4gICAgY29uc3Qgc3lzdGVtUmVmID0gdXNlUmVmPE1lZGlhU3RyZWFtIHwgbnVsbD4obnVsbClcclxuICAgIGNvbnN0IGN0eFJlZiA9IHVzZVJlZjxBdWRpb0NvbnRleHQgfCBudWxsPihudWxsKVxyXG4gICAgY29uc3QgcHJvY2Vzc29yUmVmID0gdXNlUmVmPFNjcmlwdFByb2Nlc3Nvck5vZGUgfCBudWxsPihudWxsKVxyXG5cclxuICAgIGNvbnN0IHN0YXJ0VHJhbnNjcmlwdGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICBpZiAoIXdzUmVmLmN1cnJlbnQgfHwgd3NSZWYuY3VycmVudC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiAnTm90IGNvbm5lY3RlZCcgfSkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyAxKSBTY3JlZW4gKyBzeXN0ZW0gYXVkaW8gKGlmIGVuYWJsZWQpXHJcbiAgICAgICAgICAgIGxldCBzeXN0ZW1TdHJlYW06IE1lZGlhU3RyZWFtIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChjb25maWcuYXVkaW9Tb3VyY2VzPy5zeXN0ZW1BdWRpbykge1xyXG4gICAgICAgICAgICAgICAgc3lzdGVtU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoe1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1SZWYuY3VycmVudCA9IHN5c3RlbVN0cmVhbTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMikgTWljcm9waG9uZVxyXG4gICAgICAgICAgICBjb25zdCBtaWNTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XHJcbiAgICAgICAgICAgICAgICBhdWRpbzogeyBzYW1wbGVSYXRlOiAxNjAwMCwgY2hhbm5lbENvdW50OiAxIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtaWNSZWYuY3VycmVudCA9IG1pY1N0cmVhbTtcclxuXHJcblxyXG4gICAgICAgICAgICBjb25zdCBjdHggPSBjdHhSZWYuY3VycmVudCFcclxuICAgICAgICAgICAgY29uc3QgZGVzdCA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKClcclxuXHJcbiAgICAgICAgICAgIC8vIDQpIFdpcmUgbWljIOKGkiBkZXN0XHJcbiAgICAgICAgICAgIGNvbnN0IG1pY1NyYyA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShtaWNTdHJlYW0pO1xyXG4gICAgICAgICAgICBtaWNTcmMuY29ubmVjdChkZXN0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIDUpIFdpcmUgc3lzdGVtIGF1ZGlvIOKGkiBkZXN0XHJcbiAgICAgICAgICAgIGlmIChzeXN0ZW1TdHJlYW0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN5c1NyYyA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzeXN0ZW1TdHJlYW0pO1xyXG4gICAgICAgICAgICAgICAgc3lzU3JjLmNvbm5lY3QoZGVzdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDYpIEluc3RlYWQgb2Ygd2lyaW5nIG1pYytzeXMgZGlyZWN0bHkgdG8gdGhlIHByb2Nlc3Nvciwgd2VcclxuICAgICAgICAgICAgLy8gICAgdGFrZSB0aGUgbWl4ZWQgZGVzdC5zdHJlYW0gYW5kIGhvb2sgdGhhdCB1cDpcclxuICAgICAgICAgICAgY29uc3QgbWl4ZWRTcmMgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UoZGVzdC5zdHJlYW0pO1xyXG5cclxuICAgICAgICAgICAgLy8gNykgQ3JlYXRlIHlvdXIgU2NyaXB0UHJvY2Vzc29yIChidWZmZXJTaXplPTUxMiwgbW9ubyBpbi9vdXQpXHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NvciA9IGN0eC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoNTEyLCAxLCAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDgpIFdpcmUgdGhlIG1peGVkIGF1ZGlvIGludG8gdGhlIHByb2Nlc3NvclxyXG4gICAgICAgICAgICBtaXhlZFNyYy5jb25uZWN0KHByb2Nlc3Nvcik7XHJcblxyXG4gICAgICAgICAgICAvLyA5KSBPbiBlYWNoIG9uYXVkaW9wcm9jZXNzLCBidWlsZCBleGFjdGx5IG9uZSBwYWNrZXRcclxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uYXVkaW9wcm9jZXNzID0gZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmbG9hdDMyID0gZS5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmxvYXQzMkJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoZmxvYXQzMilcclxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuc2F2ZVJlY29yZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudC5wdXNoKGZsb2F0MzJCdWZmZXIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDihpIgY29udmVydCB0byBVaW50OEFycmF5IFswLi4yNTVdXHJcbiAgICAgICAgICAgICAgICBjb25zdCB1aTggPSBuZXcgVWludDhBcnJheShmbG9hdDMyQnVmZmVyLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmxvYXQzMkJ1ZmZlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHVpOFtpXSA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAyNTUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAsIE1hdGguZmxvb3IoKGZsb2F0MzJCdWZmZXJbaV0gKyAxKSAqIDEyNy41KSlcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc2VuZCByYXcgZmxvYXQzMiBQQ00gdG8gc2VydmVyXHJcbiAgICAgICAgICAgICAgICBpZiAod3NSZWYuY3VycmVudCEucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgICAgICAgICB3c1JlZi5jdXJyZW50IS5zZW5kKGZsb2F0MzJCdWZmZXIuYnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB2aXN1YWxpemVyXHJcbiAgICAgICAgICAgICAgICBzZXRBdWRpb0RhdGEodWk4KVxyXG4gICAgICAgICAgICAgICAgc2V0RGF0YVVwZGF0ZVRyaWdnZXIodCA9PiB0ICsgMSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMTApIFN0YXJ0IGl0XHJcbiAgICAgICAgICAgIHByb2Nlc3Nvci5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgICAgIHByb2Nlc3NvclJlZi5jdXJyZW50ID0gcHJvY2Vzc29yO1xyXG5cclxuICAgICAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBpc1RyYW5zY3JpYmluZzogdHJ1ZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIGVycm9yOiBgRmFpbGVkIHRvIHN0YXJ0IHRyYW5zY3JpcHRpb246ICR7ZXJyLm1lc3NhZ2V9YCB9KSk7XHJcbiAgICAgICAgICAgIHRvYXN0KHsgdGl0bGU6ICdUcmFuc2NyaXB0aW9uIEVycm9yJywgZGVzY3JpcHRpb246IGVyci5tZXNzYWdlLCB2YXJpYW50OiAnZGVzdHJ1Y3RpdmUnIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtjb25maWcsIHRvYXN0XSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHN0b3BUcmFuc2NyaXB0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIC8vIDEpIHRlbGwgdGhlIHNlcnZlciDigJxFTkRfT0ZfQVVESU/igJ1cclxuICAgICAgICBpZiAod3NSZWYuY3VycmVudD8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgd3NSZWYuY3VycmVudC5zZW5kKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShcIkVORF9PRl9BVURJT1wiKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAyKSBpbW1lZGlhdGVseSB0ZWFyIGRvd24gdGhlIFNjcmlwdFByb2Nlc3NvciAmIHRyYWNrc1xyXG4gICAgICAgIGlmIChwcm9jZXNzb3JSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBwcm9jZXNzb3JSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIHByb2Nlc3NvclJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1pY1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIG1pY1JlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSk7XHJcbiAgICAgICAgICAgIG1pY1JlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN5c3RlbVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHN5c3RlbVJlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSk7XHJcbiAgICAgICAgICAgIHN5c3RlbVJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDMpIGlmIHdl4oCZdmUgYmVlbiBzYXZpbmcsIGZsYXR0ZW4gKyBlbmNvZGUgKyB1cGxvYWQgd2hpbGUgY3R4IGlzIHN0aWxsIG9wZW5cclxuICAgICAgICBpZiAoY29uZmlnLnNhdmVSZWNvcmRpbmcgJiYgcmVjb3JkaW5nQnVmZmVycy5jdXJyZW50Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZVdoaXNwZXJMaXZlXSB1cGxvYWRpbmcgV0FWLCBidWZmZXJzOicsIHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudC5sZW5ndGgpXHJcbiAgICAgICAgICAgIC8vIOKXiSB1c2UgdGhlIHNhdmVkIHNhbXBsZVJhdGVcclxuICAgICAgICAgICAgY29uc3Qgc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGVSZWYuY3VycmVudDtcclxuXHJcbiAgICAgICAgICAgIC8vIOKXiSBmbGF0dGVuIGludG8gb25lIEZsb2F0MzJBcnJheVxyXG4gICAgICAgICAgICBjb25zdCB0b3RhbExlbmd0aCA9IHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudC5yZWR1Y2UoKHN1bSwgYnVmKSA9PiBzdW0gKyBidWYubGVuZ3RoLCAwKTtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJsZWF2ZWQgPSBuZXcgRmxvYXQzMkFycmF5KHRvdGFsTGVuZ3RoKTtcclxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYnVmIG9mIHJlY29yZGluZ0J1ZmZlcnMuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJsZWF2ZWQuc2V0KGJ1Ziwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBidWYubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyDil4kgZW5jb2RlICsgdXBsb2FkXHJcbiAgICAgICAgICAgIGNvbnN0IHdhdlZpZXcgPSBlbmNvZGVXQVYoaW50ZXJsZWF2ZWQsIHNhbXBsZVJhdGUpO1xyXG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3dhdlZpZXcuYnVmZmVyXSwgeyB0eXBlOiAnYXVkaW8vd2F2JyB9KTtcclxuICAgICAgICAgICAgY29uc3QgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4gICAgICAgICAgICBmb3JtLmFwcGVuZCgnZmlsZScsIGJsb2IsIGNvbmZpZy5vdXRwdXRGaWxlbmFtZSB8fCAncmVjb3JkaW5nLndhdicpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvdXBsb2FkJywgeyBtZXRob2Q6ICdQT1NUJywgYm9keTogZm9ybSB9KVxyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcigndXBsb2FkIGZhaWxlZCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVybCB9ID0gYXdhaXQgcmVzLmpzb24oKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjOiBSZWNvcmRpbmcgPSB7IGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksIHVybCwgYmxvYiB9XHJcbiAgICAgICAgICAgICAgICBzZXRSZWNvcmRpbmdzKHJzID0+IFsuLi5ycywgcmVjXSlcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgICAgICAgICAgIHRvYXN0KHsgdGl0bGU6ICdVcGxvYWQgRXJyb3InLCBkZXNjcmlwdGlvbjogU3RyaW5nKGVyciksIHZhcmlhbnQ6ICdkZXN0cnVjdGl2ZScgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWNvcmRpbmdCdWZmZXJzLmN1cnJlbnQgPSBbXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gNCkgKipub3cqKiB0ZWFyIGRvd24geW91ciBBdWRpb0NvbnRleHRcclxuICAgICAgICBpZiAoY3R4UmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgY3R4UmVmLmN1cnJlbnQuY2xvc2UoKTtcclxuICAgICAgICAgICAgY3R4UmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gNSkgZmluYWxseSwgdXBkYXRlIHN0YXRlXHJcbiAgICAgICAgc2V0U3RhdGUocyA9PiAoeyAuLi5zLCBpc1RyYW5zY3JpYmluZzogZmFsc2UgfSkpO1xyXG4gICAgfSwgW2NvbmZpZywgdG9hc3RdKTtcclxuXHJcblxyXG5cclxuXHJcbiAgICBjb25zdCBkaXNjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGlmICh3c1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHdzUmVmLmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICAgICAgICB3c1JlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICAgIH1cclxuICAgICAgICBzdG9wVHJhbnNjcmlwdGlvbigpXHJcbiAgICAgICAgc2V0U3RhdGUoeyBpc0Nvbm5lY3RlZDogZmFsc2UsIGlzVHJhbnNjcmliaW5nOiBmYWxzZSwgdHJhbnNjcmlwdDogJycsIGVycm9yOiBudWxsIH0pXHJcbiAgICB9LCBbc3RvcFRyYW5zY3JpcHRpb25dKVxyXG5cclxuICAgIGNvbnN0IGNsZWFyVHJhbnNjcmlwdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBzZXRTdGF0ZShzID0+ICh7IC4uLnMsIHRyYW5zY3JpcHQ6ICcnIH0pKVxyXG4gICAgfSwgW10pXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0ZSxcclxuICAgICAgICBjb25uZWN0LFxyXG4gICAgICAgIHN0YXJ0VHJhbnNjcmlwdGlvbixcclxuICAgICAgICBzdG9wVHJhbnNjcmlwdGlvbixcclxuICAgICAgICBkaXNjb25uZWN0LFxyXG4gICAgICAgIGNsZWFyVHJhbnNjcmlwdCxcclxuICAgICAgICB3c1JlZixcclxuICAgICAgICBhdWRpb0RhdGEsXHJcbiAgICAgICAgZGF0YVVwZGF0ZVRyaWdnZXIsXHJcbiAgICAgICAgcmVjb3JkaW5ncyxcclxuICAgICAgICBkZWxldGVSZWNvcmRpbmc6IChyOiBSZWNvcmRpbmcpID0+IHNldFJlY29yZGluZ3MocnMgPT4gcnMuZmlsdGVyKHggPT4geC5pZCAhPT0gci5pZCkpXHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VUb2FzdCIsInJlY29yZGluZ3MiLCJzZXRSZWNvcmRpbmdzIiwiZW5jb2RlV0FWIiwic2FtcGxlcyIsInNhbXBsZVJhdGUiLCJiaXRzUGVyU2FtcGxlIiwiYnl0ZXNQZXJTYW1wbGUiLCJibG9ja0FsaWduIiwiYnl0ZVJhdGUiLCJkYXRhU2l6ZSIsImxlbmd0aCIsImJ1ZmZlciIsIkFycmF5QnVmZmVyIiwidmlldyIsIkRhdGFWaWV3Iiwid3JpdGVTdHJpbmciLCJzZXRVaW50MzIiLCJzZXRVaW50MTYiLCJvZmZzZXQiLCJpIiwicyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJzZXRJbnQxNiIsInNldFVpbnQ4IiwiY2hhckNvZGVBdCIsInVzZVdoaXNwZXJMaXZlIiwiY29uZmlnIiwic3RhdGUiLCJzZXRTdGF0ZSIsImlzQ29ubmVjdGVkIiwiaXNUcmFuc2NyaWJpbmciLCJ0cmFuc2NyaXB0IiwiZXJyb3IiLCJhdWRpb0RhdGEiLCJzZXRBdWRpb0RhdGEiLCJkYXRhVXBkYXRlVHJpZ2dlciIsInNldERhdGFVcGRhdGVUcmlnZ2VyIiwid3NSZWYiLCJyZWNvcmRpbmdCdWZmZXJzIiwic2FtcGxlUmF0ZVJlZiIsImxhc3RTZWdtZW50SW5kZXhSZWYiLCJ1aWRSZWYiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsInRvYXN0IiwiY29ubmVjdCIsImNvbnNvbGUiLCJsb2ciLCJjdXJyZW50IiwiY2xvc2UiLCJjdHgiLCJBdWRpb0NvbnRleHQiLCJjdHhSZWYiLCJwcm90b2NvbCIsIndpbmRvdyIsImxvY2F0aW9uIiwid3MiLCJXZWJTb2NrZXQiLCJzZXJ2ZXJVcmwiLCJwb3J0IiwiYmluYXJ5VHlwZSIsIm9ub3BlbiIsInRhc2tOYW1lIiwidHJhbnNsYXRlIiwic2VuZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0YXNrIiwidWlkIiwibGFuZ3VhZ2UiLCJtb2RlbCIsInVzZV92YWQiLCJzZW5kX2xhc3Rfbl9zZWdtZW50cyIsInNhdmVfcmVjb3JkaW5nIiwic2F2ZVJlY29yZGluZyIsIm91dHB1dF9maWxlbmFtZSIsIm91dHB1dEZpbGVuYW1lIiwibWF4X2NsaWVudHMiLCJtYXhDbGllbnRzIiwibWF4X2Nvbm5lY3Rpb25fdGltZSIsIm1heENvbm5lY3Rpb25UaW1lIiwic2FtcGxlX3JhdGUiLCJjaHVua19zaXplIiwic3RhcnRUcmFuc2NyaXB0aW9uIiwib25tZXNzYWdlIiwiZSIsImRhdGEiLCJtc2ciLCJwYXJzZSIsIm1lc3NhZ2UiLCJ0eXBlIiwidGV4dCIsIkFycmF5IiwiaXNBcnJheSIsInNlZ21lbnRzIiwiYWxsIiwic3RhcnQiLCJiYXRjaCIsIm1hcCIsInNlZyIsImpvaW4iLCJvbmNsb3NlIiwib25lcnJvciIsImVyciIsIndhcm4iLCJtaWNSZWYiLCJzeXN0ZW1SZWYiLCJwcm9jZXNzb3JSZWYiLCJyZWFkeVN0YXRlIiwiT1BFTiIsInN5c3RlbVN0cmVhbSIsImF1ZGlvU291cmNlcyIsInN5c3RlbUF1ZGlvIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0RGlzcGxheU1lZGlhIiwidmlkZW8iLCJhdWRpbyIsIm1pY1N0cmVhbSIsImdldFVzZXJNZWRpYSIsImNoYW5uZWxDb3VudCIsImRlc3QiLCJjcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uIiwibWljU3JjIiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJzeXNTcmMiLCJtaXhlZFNyYyIsInN0cmVhbSIsInByb2Nlc3NvciIsImNyZWF0ZVNjcmlwdFByb2Nlc3NvciIsIm9uYXVkaW9wcm9jZXNzIiwiZmxvYXQzMiIsImlucHV0QnVmZmVyIiwiZ2V0Q2hhbm5lbERhdGEiLCJmbG9hdDMyQnVmZmVyIiwiRmxvYXQzMkFycmF5IiwicHVzaCIsInVpOCIsIlVpbnQ4QXJyYXkiLCJmbG9vciIsInQiLCJkZXN0aW5hdGlvbiIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJ2YXJpYW50Iiwic3RvcFRyYW5zY3JpcHRpb24iLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImRpc2Nvbm5lY3QiLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwic3RvcCIsInRvdGFsTGVuZ3RoIiwicmVkdWNlIiwic3VtIiwiYnVmIiwiaW50ZXJsZWF2ZWQiLCJzZXQiLCJ3YXZWaWV3IiwiYmxvYiIsIkJsb2IiLCJmb3JtIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJyZXMiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJvayIsIkVycm9yIiwidXJsIiwianNvbiIsInJlYyIsImlkIiwiRGF0ZSIsIm5vdyIsInJzIiwiU3RyaW5nIiwiY2xlYXJUcmFuc2NyaXB0IiwiZGVsZXRlUmVjb3JkaW5nIiwiciIsImZpbHRlciIsIngiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-whisper-live.ts\n"));

/***/ })

});